"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const amplify_category_function_1 = require("amplify-category-function");
const path = require("path");
const inquirer = require("inquirer");
const loadMinimal_1 = require("../utils/lambda/loadMinimal");
const utils_1 = require("../utils");
function start(context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!context.input.subCommands || context.input.subCommands.length < 1) {
            throw new Error('Specify the function name to invoke with "amplify mock function <function name>"');
        }
        const resourceName = context.input.subCommands[0];
        const { amplify } = context;
        const resourcePath = path.join(amplify.pathManager.getBackendDirPath(), 'function', resourceName);
        const eventNameValidator = amplify.inputValidation({
            operator: 'regex',
            value: '^[a-zA-Z0-9/._-]+?\\.json$',
            onErrorMsg: 'Provide a valid unix-like path to a .json file',
            required: true,
        });
        let eventName = context.input.options ? context.input.options.event : undefined;
        let promptForEvent = true;
        if (eventName) {
            const validatorOutput = eventNameValidator(eventName);
            const isValid = typeof validatorOutput !== 'string';
            if (!isValid) {
                context.print.warning(validatorOutput);
            }
            else {
                promptForEvent = false;
            }
        }
        if (promptForEvent) {
            const resourceQuestions = [
                {
                    type: 'input',
                    name: 'eventName',
                    message: `Provide the path to the event JSON object relative to ${resourcePath}`,
                    validate: eventNameValidator,
                    default: 'src/event.json',
                },
            ];
            const resourceAnswers = yield inquirer.prompt(resourceQuestions);
            eventName = resourceAnswers.eventName;
        }
        const event = amplify.readJsonFile(path.resolve(path.join(resourcePath, eventName)));
        const lambdaConfig = loadMinimal_1.loadMinimalLambdaConfig(context, resourceName, { env: context.amplify.getEnvInfo().envName });
        if (!lambdaConfig || !lambdaConfig.handler) {
            throw new Error(`Could not parse handler for ${resourceName} from cloudformation file`);
        }
        const { allResources } = yield context.amplify.getResourceStatus();
        const envVars = utils_1.hydrateAllEnvVars(allResources, lambdaConfig.environment);
        const invoker = yield amplify_category_function_1.getInvoker(context, { resourceName, handler: lambdaConfig.handler, envVars });
        context.print.success('Starting execution...');
        yield invoker({ event })
            .then(result => {
            const msg = typeof result === 'object' ? JSON.stringify(result) : result;
            context.print.success('Result:');
            context.print.info(typeof result === 'undefined' ? '' : msg);
        })
            .catch(error => {
            context.print.error(`${resourceName} failed with the following error:`);
            context.print.info(error);
        })
            .then(() => context.print.success('Finished execution.'));
    });
}
exports.start = start;
//# sourceMappingURL=index.js.map