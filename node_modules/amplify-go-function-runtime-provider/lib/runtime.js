"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const which = __importStar(require("which"));
const execa = __importStar(require("execa"));
const archiver_1 = __importDefault(require("archiver"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const semver_1 = require("semver");
const constants_1 = require("./constants");
const executableName = 'go';
const minimumVersion = semver_1.coerce('1.0');
const maximumVersion = semver_1.coerce('2.0');
let executablePath;
exports.executeCommand = (args, streamStdio, env = {}, cwd = undefined, stdioInput = undefined) => {
    const output = execa.sync(executableName, args, {
        stdio: streamStdio === true ? 'inherit' : 'pipe',
        env,
        cwd,
        input: stdioInput,
    });
    if (output.exitCode !== 0) {
        throw new Error(`${executableName} failed, exit code was ${output.exitCode}`);
    }
    return output.stdout;
};
const isBuildStale = (resourceDir, lastBuildTimestamp, outDir) => {
    if (!fs_extra_1.default.existsSync(outDir) || glob_1.default.sync(`${outDir}/**`).length == 0) {
        return true;
    }
    const srcDir = path_1.default.join(resourceDir, constants_1.SRC);
    const dirTime = new Date(fs_extra_1.default.statSync(srcDir).mtime);
    if (dirTime > lastBuildTimestamp) {
        return true;
    }
    const fileUpdatedAfterLastBuild = glob_1.default
        .sync(`${resourceDir}/${constants_1.SRC}/**`)
        .find(file => new Date(fs_extra_1.default.statSync(file).mtime) > lastBuildTimestamp);
    return !!fileUpdatedAfterLastBuild;
};
exports.buildResourceInternal = async (request, context, force, forLocalInvoke) => {
    let rebuilt = false;
    const buildDir = forLocalInvoke === true ? constants_1.BIN_LOCAL : constants_1.BIN;
    const outDir = path_1.default.join(request.srcRoot, buildDir);
    const isWindows = /^win/.test(process.platform);
    const executableName = isWindows === true ? constants_1.MAIN_BINARY_WIN : constants_1.MAIN_BINARY;
    const executablePath = path_1.default.join(outDir, executableName);
    let timestampToCheck;
    if (forLocalInvoke === true) {
        if (fs_extra_1.default.existsSync(executablePath)) {
            timestampToCheck = new Date(fs_extra_1.default.statSync(executablePath).mtime);
        }
    }
    else {
        timestampToCheck = request.lastBuildTimestamp;
    }
    if (force === true || !timestampToCheck || isBuildStale(request.srcRoot, timestampToCheck, outDir)) {
        const srcDir = path_1.default.join(request.srcRoot, constants_1.SRC);
        const entryFile = constants_1.MAIN_SOURCE;
        if (fs_extra_1.default.existsSync(outDir)) {
            fs_extra_1.default.emptyDirSync(outDir);
        }
        else {
            fs_extra_1.default.mkdirSync(outDir);
        }
        const envVars = {};
        if (forLocalInvoke === false) {
            envVars.GOOS = 'linux';
            envVars.GOARCH = 'amd64';
        }
        if (isWindows) {
            envVars.CGO_ENABLED = 0;
        }
        exports.executeCommand(['build', '-o', executablePath, entryFile], true, envVars, srcDir);
        rebuilt = true;
    }
    return {
        rebuilt,
    };
};
exports.checkDependencies = async (_runtimeValue) => {
    executablePath = which.sync(executableName, {
        nothrow: true,
    });
    if (executablePath === null) {
        return {
            hasRequiredDependencies: false,
            errorMessage: `${executableName} executable was not found in PATH, make sure it's available. It can be installed from https://golang.org/doc/install`,
        };
    }
    const versionOutput = exports.executeCommand(['version'], false);
    if (versionOutput) {
        const parts = versionOutput.split(' ');
        if (parts.length !== 4 || !parts[2].startsWith('go') || semver_1.coerce(parts[2].slice(2)) === null) {
            return {
                hasRequiredDependencies: false,
                errorMessage: `Invalid version string: ${versionOutput}`,
            };
        }
        const version = semver_1.coerce(parts[2].slice(2));
        if (semver_1.lt(version, minimumVersion) || semver_1.gte(version, maximumVersion)) {
            return {
                hasRequiredDependencies: false,
                errorMessage: `${executableName} version found was: ${version.format()}, but must be between ${minimumVersion.format()} and ${maximumVersion.format()}`,
            };
        }
    }
    return {
        hasRequiredDependencies: true,
    };
};
exports.buildResource = async (request, context) => exports.buildResourceInternal(request, context, false, false);
exports.packageResource = async (request, context) => {
    if (!request.lastPackageTimestamp || request.lastBuildTimestamp > request.lastPackageTimestamp) {
        const outDir = path_1.default.join(request.srcRoot, constants_1.BIN);
        const mainFile = path_1.default.join(outDir, constants_1.MAIN_BINARY);
        const file = fs_extra_1.default.createWriteStream(request.dstFilename);
        const packageHash = await context.amplify.hashDir(request.srcRoot, [constants_1.DIST]);
        return new Promise(async (resolve, reject) => {
            file.on('close', () => {
                resolve({ packageHash });
            });
            file.on('error', err => {
                reject(new Error(`Failed to zip with error: [${err}]`));
            });
            const zip = archiver_1.default.create('zip', {});
            zip.pipe(file);
            zip.file(mainFile, {
                name: constants_1.MAIN_BINARY,
                mode: 755,
            });
            zip.glob('**/*', {
                cwd: outDir,
                ignore: [mainFile],
            });
            zip.finalize();
        });
    }
    return Promise.resolve({});
};
//# sourceMappingURL=runtime.js.map