{"ast":null,"code":"var AWS = require('../core');\n\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\n\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n\n    self.fillQueue = function () {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' + typeof options.tags + ' provided.');\n      }\n\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' + this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function send(callback) {\n    var self = this;\n    self.failed = false;\n\n    self.callback = callback || function (err) {\n      if (err) throw err;\n    };\n\n    var runFill = true;\n\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.on('error', function (err) {\n          self.cleanup(err);\n        }).on('readable', function () {\n          self.fillQueue();\n        }).on('end', function () {\n          self.isDoneChunking = true;\n          self.numParts = self.totalPartNumbers;\n          self.fillQueue.call(self);\n\n          if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n            self.finishMultiPart();\n          }\n        });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function abort() {\n    var self = this; //abort putObject request\n\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError',\n        retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this; // bind parameters to new service object\n\n    if (!self.service) {\n      self.service = new AWS.S3({\n        params: params\n      });\n    } else {\n      var service = self.service;\n      var config = AWS.util.copy(service._originalConfig || {});\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params = AWS.util.merge(self.service.config.params || {}, params);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n\n    try {\n      // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) {} // try to adjust partSize if we know payload length\n\n\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n    var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();\n\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0; // if we have more than partSize, push the rest back on the queue\n\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n    var partNumber = ++self.totalPartNumbers;\n\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {\n        Body: chunk\n      };\n\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest',\n        retryable: false\n      });\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n\n    if (!self.service.config.params.UploadId) {\n      if (!self.multipartReq) {\n        // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function (resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function (err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else {\n      // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' + AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n    var partInfo = {\n      ETag: null,\n      PartNumber: partNumber\n    };\n    self.completeInfo[partNumber] = partInfo;\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function (err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing',\n          retryable: false\n        });\n      }\n\n      if (err) return self.cleanup(err); //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n\n      if (self.isDoneChunking && self.doneParts === self.numParts) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function () {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return; // clean up stream\n\n    if (typeof self.body.removeAllListeners === 'function' && typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    } // cleanup multipartReq listeners\n\n\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function (partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = {\n      MultipartUpload: {\n        Parts: self.completeInfo.slice(1)\n      }\n    };\n    self.service.completeMultipartUpload(completeParams, function (err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n\n        self.service.putObjectTagging({\n          Tagging: {\n            TagSet: self.tags\n          }\n        }, function (e, d) {\n          if (e) {\n            self.callback(e);\n          } else {\n            self.callback(e, data);\n          }\n        });\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location = [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n/**\n * @api private\n */\n\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n/**\n * @api private\n */\n\n\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n/**\n * @api private\n */\n\nmodule.exports = AWS.S3.ManagedUpload;","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/s3/managed_upload.js"],"names":["AWS","require","byteLength","util","string","Buffer","S3","ManagedUpload","inherit","constructor","options","self","SequentialExecutor","call","body","sliceFn","callback","parts","completeInfo","fillQueue","Error","configure","partSize","minPartSize","queueSize","leavePartsOnError","tags","Array","isArray","service","bindServiceObject","params","validateBody","adjustTotalBytes","maxTotalParts","send","failed","err","runFill","fillBuffer","isNode","Stream","stream","fillStream","partBuffers","on","cleanup","isDoneChunking","numParts","totalPartNumbers","doneParts","finishMultiPart","abort","singlePart","error","code","retryable","config","Body","buffer","toBuffer","arraySliceFn","copy","_originalConfig","signatureVersion","getSignatureVersion","__super__","merge","totalBytes","e","newPartSize","Math","ceil","undefined","partPos","totalChunkedBytes","totalUploadedBytes","activeParts","multipartReq","partBufferLength","bodyLen","nextChunk","endPos","min","buf","read","push","length","pbuf","concat","rest","slice","isDoneSending","chunk","partNumber","Tagging","getTaggingHeader","req","putObject","_managedUpload","progress","finishSinglePart","ContentMD5","ETag","UploadId","createMultipartUpload","resp","data","queueChunks","uploadPart","kvPairStrings","i","uriEscape","Key","Value","join","partParams","ContentLength","PartNumber","partInfo","_lastUploadedBytes","message","isBrowser","removeAllListeners","resume","abortMultipartUpload","each","part","completeParams","MultipartUpload","Parts","completeMultipartUpload","Location","replace","String","putObjectTagging","TagSet","d","upload","request","httpReq","httpRequest","endpoint","protocol","host","path","key","Bucket","info","operation","loaded","total","emit","mixin","addPromisesToClass","PromiseDependency","prototype","promise","promisifyMethod","deletePromisesFromClass","addPromises","module","exports"],"mappings":"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","sourcesContent":["var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function() {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' +\n          typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' +\n                      this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function(callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function(err) { if (err) throw err; };\n\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.\n          on('error', function(err) { self.cleanup(err); }).\n          on('readable', function() { self.fillQueue(); }).\n          on('end', function() {\n            self.isDoneChunking = true;\n            self.numParts = self.totalPartNumbers;\n            self.fillQueue.call(self);\n\n            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n              self.finishMultiPart();\n            }\n          });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function() {\n    var self = this;\n    //abort putObject request\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError', retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({params: params});\n    } else {\n      var service = self.service;\n      var config = AWS.util.copy(service._originalConfig || {});\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params =\n        AWS.util.merge(self.service.config.params || {}, params);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try { // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) { }\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n\n    var buf = self.body.read(self.partSize - self.partBufferLength) ||\n              self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ?\n        self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ?\n          self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {Body: chunk};\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest', retryable: false\n      });\n\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n\n      if (!self.multipartReq) { // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function(resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function(err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else { // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +\n        AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n\n    var partInfo = {ETag: null, PartNumber: partNumber};\n    self.completeInfo[partNumber] = partInfo;\n\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function(err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing', retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.numParts) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function() {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' &&\n        typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function(partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };\n    self.service.completeMultipartUpload(completeParams, function(err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n        self.service.putObjectTagging(\n          {Tagging: {TagSet: self.tags}},\n          function(e, d) {\n            if (e) {\n              self.callback(e);\n            } else {\n              self.callback(e, data);\n            }\n          }\n        );\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location =\n      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\n\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n\n/**\n * @api private\n */\nmodule.exports = AWS.S3.ManagedUpload;\n"]},"metadata":{},"sourceType":"script"}