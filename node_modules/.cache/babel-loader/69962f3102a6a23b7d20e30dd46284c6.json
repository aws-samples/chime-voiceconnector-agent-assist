{"ast":null,"code":"import _regeneratorRuntime from \"/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\n\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking\n} = {}) {\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n    });\n  }\n\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  if (blocking) openPromise.then(db => db.addEventListener('versionchange', blocking));\n  return openPromise;\n}\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\n\n\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\n\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) return;\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) return;\n\n  const method = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(storeName, ...args) {\n      var tx, target, returnVal;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n            tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n            target = tx.store;\n            if (useIndex) target = target.index(args.shift());\n            returnVal = target[targetFuncName](...args);\n\n            if (!isWrite) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 7;\n            return tx.done;\n\n          case 7:\n            return _context.abrupt(\"return\", returnVal);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, this);\n    }));\n\n    return function method(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  cachedMethods.set(prop, method);\n  return method;\n}\n\naddTraps(oldTraps => ({\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nexport { openDB, deleteDB };","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/idb/build/esm/index.js"],"names":["a","wrap","b","addTraps","e","unwrap","openDB","name","version","blocked","upgrade","blocking","request","indexedDB","open","openPromise","addEventListener","event","result","oldVersion","newVersion","transaction","then","db","deleteDB","deleteDatabase","undefined","readMethods","writeMethods","cachedMethods","Map","getMethod","target","prop","IDBDatabase","get","targetFuncName","replace","useIndex","isWrite","includes","IDBIndex","IDBObjectStore","prototype","method","storeName","args","tx","store","index","shift","returnVal","done","set","oldTraps","receiver","has"],"mappings":"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","sourcesContent":["import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n"]},"metadata":{},"sourceType":"module"}