{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { assertValidSDL } from '../validation/validate';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      var typeName = def.name.value;\n\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder = /*#__PURE__*/function () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n\n    _defineProperty(this, \"_options\", void 0);\n\n    _defineProperty(this, \"_resolveType\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n\n    if (!this._cache[typeName]) {\n      if (node.kind === Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return GraphQLList(this._buildWrappedType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      return GraphQLNonNull( // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n\n    return this.buildType(typeNode);\n  };\n\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var interfaces = def.interfaces;\n    return new GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n\n    return def.values ? keyValMap(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n\n    var types = def.types;\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/utilities/buildASTSchema.mjs"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","invariant","keyMap","keyValMap","valueFromAST","assertValidSDL","blockStringValue","TokenKind","parse","getDirectiveValues","Kind","isTypeDefinitionNode","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","introspectionTypes","specifiedScalarTypes","GraphQLSchema","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaDef","typeDefs","nodeMap","create","directiveDefs","i","definitions","length","def","SCHEMA_DEFINITION","typeName","name","Error","concat","push","DIRECTIVE_DEFINITION","operationTypes","getOperationTypes","query","Query","mutation","Mutation","subscription","Subscription","definitionBuilder","ASTDefinitionBuilder","typeRef","directives","map","buildDirective","some","directive","buildType","types","node","astNode","allowedLegacyNames","schema","opTypes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","operationType","_typeName","type","operation","err","return","typeDefinitionsMap","resolveType","_typeDefinitionsMap","_options","_resolveType","_cache","_proto","prototype","NAMED_TYPE","defNode","_makeSchemaDef","_buildWrappedType","typeNode","LIST_TYPE","NON_NULL_TYPE","directiveNode","description","getDescription","locations","args","arguments","_makeInputValues","buildField","field","deprecationReason","getDeprecationReason","buildInputField","defaultValue","buildEnumValue","OBJECT_TYPE_DEFINITION","_makeTypeDef","INTERFACE_TYPE_DEFINITION","_makeInterfaceDef","ENUM_TYPE_DEFINITION","_makeEnumDef","UNION_TYPE_DEFINITION","_makeUnionDef","SCALAR_TYPE_DEFINITION","_makeScalarDef","INPUT_OBJECT_TYPE_DEFINITION","_makeInputObjectDef","_this","interfaces","fields","_makeFieldDefMap","ref","_this2","values","_this3","_this4","_makeValueDefMap","_this5","enumValue","_this6","serialize","_this7","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","line","String","reverse","join","buildSchema","source"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { assertValidSDL } from '../validation/validate';\nimport blockStringValue from '../language/blockStringValue';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport { getDirectiveValues } from '../execution/values';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { introspectionTypes } from '../type/introspection';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { GraphQLSchema } from '../type/schema';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      var typeName = def.name.value;\n\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return opTypes;\n  }\n}\nexport var ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n\n    _defineProperty(this, \"_options\", void 0);\n\n    _defineProperty(this, \"_resolveType\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n\n    if (!this._cache[typeName]) {\n      if (node.kind === Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === Kind.LIST_TYPE) {\n      return GraphQLList(this._buildWrappedType(typeNode.type));\n    }\n\n    if (typeNode.kind === Kind.NON_NULL_TYPE) {\n      return GraphQLNonNull( // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n\n    return this.buildType(typeNode);\n  };\n\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var interfaces = def.interfaces;\n    return new GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? keyValMap(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n\n    return keyValMap(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n\n    return new GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n\n    return def.values ? keyValMap(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n\n    var types = def.types;\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return blockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}"]},"metadata":{},"sourceType":"module"}