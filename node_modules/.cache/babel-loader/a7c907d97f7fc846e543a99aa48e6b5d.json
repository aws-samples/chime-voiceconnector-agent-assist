{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\n/**\n * A lossless representation of a signed, 64-bit integer. Instances of this\n * class may be used in arithmetic expressions as if they were numeric\n * primitives, but the binary representation will be preserved unchanged as the\n * `bytes` property of the object. The bytes should be encoded as big-endian,\n * two's complement integers.\n */\n\n\nvar Int64 =\n/** @class */\nfunction () {\n  function Int64(bytes) {\n    this.bytes = bytes;\n\n    if (bytes.byteLength !== 8) {\n      throw new Error('Int64 buffers must be exactly 8 bytes');\n    }\n  }\n\n  Int64.fromNumber = function (number) {\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\n      throw new Error(number + \" is too large (or, if negative, too small) to represent as an Int64\");\n    }\n\n    var bytes = new Uint8Array(8);\n\n    for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n\n    if (number < 0) {\n      negate(bytes);\n    }\n\n    return new Int64(bytes);\n  };\n  /**\n   * Called implicitly by infix arithmetic operators.\n   */\n\n\n  Int64.prototype.valueOf = function () {\n    var bytes = this.bytes.slice(0);\n    var negative = bytes[0] & 128;\n\n    if (negative) {\n      negate(bytes);\n    }\n\n    return parseInt(util_hex_encoding_1.toHex(bytes), 16) * (negative ? -1 : 1);\n  };\n\n  Int64.prototype.toString = function () {\n    return String(this.valueOf());\n  };\n\n  return Int64;\n}();\n\nexports.Int64 = Int64;\n\nfunction negate(bytes) {\n  for (var i = 0; i < 8; i++) {\n    bytes[i] ^= 0xFF;\n  }\n\n  for (var i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}","map":{"version":3,"sources":["../src/Int64.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,mBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;AAEA;;;;;;;;;AAOA,IAAA,KAAA;AAAA;AAAA,YAAA;AACI,WAAA,KAAA,CAAqB,KAArB,EAAsC;AAAjB,SAAA,KAAA,GAAA,KAAA;;AACjB,QAAI,KAAK,CAAC,UAAN,KAAqB,CAAzB,EAA4B;AACxB,YAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACH;AACJ;;AAEM,EAAA,KAAA,CAAA,UAAA,GAAP,UAAkB,MAAlB,EAAgC;AAC5B,QAAI,MAAM,GAAG,mBAAT,IAAgC,MAAM,GAAG,CAAC,mBAA9C,EAAmE;AAC/D,YAAM,IAAI,KAAJ,CACC,MAAM,GAAA,qEADP,CAAN;AAGH;;AAED,QAAM,KAAK,GAAG,IAAI,UAAJ,CAAe,CAAf,CAAd;;AACA,SACI,IAAI,CAAC,GAAG,CAAR,EAAW,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,KAAL,CAAW,MAAX,CAAT,CAD3B,EAEI,CAAC,GAAG,CAAC,CAAL,IAAU,SAAS,GAAG,CAF1B,EAGI,CAAC,IAAI,SAAS,IAAI,GAHtB,EAIE;AACE,MAAA,KAAK,CAAC,CAAD,CAAL,GAAW,SAAX;AACH;;AAED,QAAI,MAAM,GAAG,CAAb,EAAgB;AACZ,MAAA,MAAM,CAAC,KAAD,CAAN;AACH;;AAED,WAAO,IAAI,KAAJ,CAAU,KAAV,CAAP;AACH,GArBM;AAuBP;;;;;AAGA,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACI,QAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAX,CAAiB,CAAjB,CAAd;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,CAAD,CAAL,GAAW,GAA5B;;AACA,QAAI,QAAJ,EAAc;AACV,MAAA,MAAM,CAAC,KAAD,CAAN;AACH;;AAED,WAAO,QAAQ,CAAC,mBAAA,CAAA,KAAA,CAAM,KAAN,CAAD,EAAe,EAAf,CAAR,IAA8B,QAAQ,GAAG,CAAC,CAAJ,GAAQ,CAA9C,CAAP;AACH,GARD;;AAUA,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACI,WAAO,MAAM,CAAC,KAAK,OAAL,EAAD,CAAb;AACH,GAFD;;AAGJ,SAAA,KAAA;AAAC,CA9CD,EAAA;;AAAa,OAAA,CAAA,KAAA,GAAA,KAAA;;AAgDb,SAAS,MAAT,CAAgB,KAAhB,EAAiC;AAC7B,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AACxB,IAAA,KAAK,CAAC,CAAD,CAAL,IAAY,IAAZ;AACH;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAArB,EAAwB,CAAC,EAAzB,EAA6B;AACzB,IAAA,KAAK,CAAC,CAAD,CAAL;AACA,QAAI,KAAK,CAAC,CAAD,CAAL,KAAa,CAAjB,EAAoB;AACvB;AACJ","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_hex_encoding_1 = require(\"@aws-sdk/util-hex-encoding\");\n/**\n * A lossless representation of a signed, 64-bit integer. Instances of this\n * class may be used in arithmetic expressions as if they were numeric\n * primitives, but the binary representation will be preserved unchanged as the\n * `bytes` property of the object. The bytes should be encoded as big-endian,\n * two's complement integers.\n */\nvar Int64 = /** @class */ (function () {\n    function Int64(bytes) {\n        this.bytes = bytes;\n        if (bytes.byteLength !== 8) {\n            throw new Error('Int64 buffers must be exactly 8 bytes');\n        }\n    }\n    Int64.fromNumber = function (number) {\n        if (number > 9223372036854775807 || number < -9223372036854775808) {\n            throw new Error(number + \" is too large (or, if negative, too small) to represent as an Int64\");\n        }\n        var bytes = new Uint8Array(8);\n        for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n            bytes[i] = remaining;\n        }\n        if (number < 0) {\n            negate(bytes);\n        }\n        return new Int64(bytes);\n    };\n    /**\n     * Called implicitly by infix arithmetic operators.\n     */\n    Int64.prototype.valueOf = function () {\n        var bytes = this.bytes.slice(0);\n        var negative = bytes[0] & 128;\n        if (negative) {\n            negate(bytes);\n        }\n        return parseInt(util_hex_encoding_1.toHex(bytes), 16) * (negative ? -1 : 1);\n    };\n    Int64.prototype.toString = function () {\n        return String(this.valueOf());\n    };\n    return Int64;\n}());\nexports.Int64 = Int64;\nfunction negate(bytes) {\n    for (var i = 0; i < 8; i++) {\n        bytes[i] ^= 0xFF;\n    }\n    for (var i = 7; i > -1; i--) {\n        bytes[i]++;\n        if (bytes[i] !== 0)\n            break;\n    }\n}\n//# sourceMappingURL=Int64.js.map"]},"metadata":{},"sourceType":"script"}