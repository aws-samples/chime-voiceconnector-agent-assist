{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../error/GraphQLError';\nimport find from '../jsutils/find';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { coerceValue } from '../utilities/coerceValue';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      errors.push(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" expected value of type \") + \"\\\"\".concat(print(varDefNode.type), \"\\\" which cannot be used as an input type.\"), [varDefNode.type]));\n    } else {\n      var hasValue = hasOwnProperty(inputs, varName);\n      var value = hasValue ? inputs[varName] : undefined;\n\n      if (!hasValue && varDefNode.defaultValue) {\n        // If no value was provided to a variable with a default value,\n        // use the default value.\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if ((!hasValue || value === null) && isNonNullType(varType)) {\n        // If no value or a nullish value was provided to a variable with a\n        // non-null type (required), produce an error.\n        errors.push(new GraphQLError(hasValue ? \"Variable \\\"$\".concat(varName, \"\\\" of non-null type \") + \"\\\"\".concat(inspect(varType), \"\\\" must not be null.\") : \"Variable \\\"$\".concat(varName, \"\\\" of required type \") + \"\\\"\".concat(inspect(varType), \"\\\" was not provided.\"), [varDefNode]));\n      } else if (hasValue) {\n        if (value === null) {\n          // If the explicit value `null` was provided, an entry in the coerced\n          // values must exist as the value `null`.\n          coercedValues[varName] = null;\n        } else {\n          // Otherwise, a non-null value was provided, coerce it to the expected\n          // type or report an error if coercion fails.\n          var coerced = coerceValue(value, varType, varDefNode);\n          var coercionErrors = coerced.errors;\n\n          if (coercionErrors) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = coercionErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var error = _step.value;\n                error.message = \"Variable \\\"$\".concat(varName, \"\\\" got invalid \") + \"value \".concat(inspect(value), \"; \").concat(error.message);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            errors.push.apply(errors, coercionErrors);\n          } else {\n            coercedValues[varName] = coerced.value;\n          }\n        }\n      }\n    }\n  }\n\n  return errors.length === 0 ? {\n    errors: undefined,\n    coerced: coercedValues\n  } : {\n    errors: errors,\n    coerced: undefined\n  };\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n\n  var argNodeMap = keyMap(argNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var hasValue = void 0;\n    var isNull = void 0;\n\n    if (argumentNode && argumentNode.value.kind === Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n      hasValue = variableValues && hasOwnProperty(variableValues, variableName);\n      isNull = variableValues && variableValues[variableName] === null;\n    } else {\n      hasValue = argumentNode != null;\n      isNull = argumentNode && argumentNode.value.kind === Kind.NULL;\n    }\n\n    if (!hasValue && argDef.defaultValue !== undefined) {\n      // If no argument was provided where the definition has a default value,\n      // use the default value.\n      coercedValues[name] = argDef.defaultValue;\n    } else if ((!hasValue || isNull) && isNonNullType(argType)) {\n      // If no argument or a null value was provided to an argument with a\n      // non-null type (required), produce a field error.\n      if (isNull) {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of non-null type \\\"\").concat(inspect(argType), \"\\\" \") + 'must not be null.', [argumentNode.value]);\n      } else if (argumentNode && argumentNode.value.kind === Kind.VARIABLE) {\n        var _variableName = argumentNode.value.name.value;\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + \"was provided the variable \\\"$\".concat(_variableName, \"\\\" \") + 'which was not provided a runtime value.', [argumentNode.value]);\n      } else {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + 'was not provided.', [node]);\n      }\n    } else if (hasValue) {\n      if (argumentNode.value.kind === Kind.NULL) {\n        // If the explicit value `null` was provided, an entry in the coerced\n        // values must exist as the value `null`.\n        coercedValues[name] = null;\n      } else if (argumentNode.value.kind === Kind.VARIABLE) {\n        var _variableName2 = argumentNode.value.name.value;\n        !variableValues ? invariant(0, 'Must exist for hasValue to be true.') : void 0; // Note: This does no further checking that this variable is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n\n        coercedValues[name] = variableValues[_variableName2];\n      } else {\n        var valueNode = argumentNode.value;\n        var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n        if (coercedValue === undefined) {\n          // Note: ValuesOfCorrectType validation should catch this before\n          // execution. This is a runtime check to ensure execution does not\n          // continue with an invalid argument value.\n          throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" has invalid value \").concat(print(valueNode), \".\"), [argumentNode.value]);\n        }\n\n        coercedValues[name] = coercedValue;\n      }\n    }\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/execution/values.mjs"],"names":["GraphQLError","find","inspect","invariant","keyMap","coerceValue","typeFromAST","valueFromAST","Kind","print","isInputType","isNonNullType","getVariableValues","schema","varDefNodes","inputs","errors","coercedValues","i","length","varDefNode","varName","variable","name","value","varType","type","push","concat","hasValue","hasOwnProperty","undefined","defaultValue","coerced","coercionErrors","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","error","message","err","return","apply","getArgumentValues","def","node","variableValues","argDefs","args","argNodes","arguments","argNodeMap","arg","argDef","argType","argumentNode","isNull","kind","VARIABLE","variableName","NULL","_variableName","_variableName2","valueNode","coercedValue","getDirectiveValues","directiveDef","directiveNode","directives","directive","obj","prop","Object","prototype","call"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../error/GraphQLError';\nimport find from '../jsutils/find';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { coerceValue } from '../utilities/coerceValue';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      errors.push(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" expected value of type \") + \"\\\"\".concat(print(varDefNode.type), \"\\\" which cannot be used as an input type.\"), [varDefNode.type]));\n    } else {\n      var hasValue = hasOwnProperty(inputs, varName);\n      var value = hasValue ? inputs[varName] : undefined;\n\n      if (!hasValue && varDefNode.defaultValue) {\n        // If no value was provided to a variable with a default value,\n        // use the default value.\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if ((!hasValue || value === null) && isNonNullType(varType)) {\n        // If no value or a nullish value was provided to a variable with a\n        // non-null type (required), produce an error.\n        errors.push(new GraphQLError(hasValue ? \"Variable \\\"$\".concat(varName, \"\\\" of non-null type \") + \"\\\"\".concat(inspect(varType), \"\\\" must not be null.\") : \"Variable \\\"$\".concat(varName, \"\\\" of required type \") + \"\\\"\".concat(inspect(varType), \"\\\" was not provided.\"), [varDefNode]));\n      } else if (hasValue) {\n        if (value === null) {\n          // If the explicit value `null` was provided, an entry in the coerced\n          // values must exist as the value `null`.\n          coercedValues[varName] = null;\n        } else {\n          // Otherwise, a non-null value was provided, coerce it to the expected\n          // type or report an error if coercion fails.\n          var coerced = coerceValue(value, varType, varDefNode);\n          var coercionErrors = coerced.errors;\n\n          if (coercionErrors) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = coercionErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var error = _step.value;\n                error.message = \"Variable \\\"$\".concat(varName, \"\\\" got invalid \") + \"value \".concat(inspect(value), \"; \").concat(error.message);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            errors.push.apply(errors, coercionErrors);\n          } else {\n            coercedValues[varName] = coerced.value;\n          }\n        }\n      }\n    }\n  }\n\n  return errors.length === 0 ? {\n    errors: undefined,\n    coerced: coercedValues\n  } : {\n    errors: errors,\n    coerced: undefined\n  };\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n\n  var argNodeMap = keyMap(argNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var hasValue = void 0;\n    var isNull = void 0;\n\n    if (argumentNode && argumentNode.value.kind === Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n      hasValue = variableValues && hasOwnProperty(variableValues, variableName);\n      isNull = variableValues && variableValues[variableName] === null;\n    } else {\n      hasValue = argumentNode != null;\n      isNull = argumentNode && argumentNode.value.kind === Kind.NULL;\n    }\n\n    if (!hasValue && argDef.defaultValue !== undefined) {\n      // If no argument was provided where the definition has a default value,\n      // use the default value.\n      coercedValues[name] = argDef.defaultValue;\n    } else if ((!hasValue || isNull) && isNonNullType(argType)) {\n      // If no argument or a null value was provided to an argument with a\n      // non-null type (required), produce a field error.\n      if (isNull) {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of non-null type \\\"\").concat(inspect(argType), \"\\\" \") + 'must not be null.', [argumentNode.value]);\n      } else if (argumentNode && argumentNode.value.kind === Kind.VARIABLE) {\n        var _variableName = argumentNode.value.name.value;\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + \"was provided the variable \\\"$\".concat(_variableName, \"\\\" \") + 'which was not provided a runtime value.', [argumentNode.value]);\n      } else {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + 'was not provided.', [node]);\n      }\n    } else if (hasValue) {\n      if (argumentNode.value.kind === Kind.NULL) {\n        // If the explicit value `null` was provided, an entry in the coerced\n        // values must exist as the value `null`.\n        coercedValues[name] = null;\n      } else if (argumentNode.value.kind === Kind.VARIABLE) {\n        var _variableName2 = argumentNode.value.name.value;\n        !variableValues ? invariant(0, 'Must exist for hasValue to be true.') : void 0; // Note: This does no further checking that this variable is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n\n        coercedValues[name] = variableValues[_variableName2];\n      } else {\n        var valueNode = argumentNode.value;\n        var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n        if (coercedValue === undefined) {\n          // Note: ValuesOfCorrectType validation should catch this before\n          // execution. This is a runtime check to ensure execution does not\n          // continue with an invalid argument value.\n          throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" has invalid value \").concat(print(valueNode), \".\"), [argumentNode.value]);\n        }\n\n        coercedValues[name] = coercedValue;\n      }\n    }\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}"]},"metadata":{},"sourceType":"module"}