{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport objectValues from '../jsutils/objectValues';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isIntrospectionType } from '../type/introspection';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n\n      if (schema.getType(typeName)) {\n        throw new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n\n      typeDefinitionMap[typeName] = def;\n    } else if (isTypeExtensionNode(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n\n      if (!existingType) {\n        throw new GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n\n      if (existingDirective) {\n        throw new GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n\n    throw new GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n            type = _ref2.type;\n\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n              type = _ref4.type;\n\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = objectValues(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat(objectValues(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n\n  return new GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    var name = type.name;\n\n    if (!extendTypeCache[name]) {\n      if (isScalarType(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if (isObjectType(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if (isInterfaceType(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if (isUnionType(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if (isEnumType(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if (isInputObjectType(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n\n    return extendTypeCache[name];\n  }\n\n  function extendDirective(directive) {\n    return new GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr = Object.keys(oldFieldMap);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = keyMap(type.getValues(), function (value) {\n      return value.name;\n    });\n\n    var _arr2 = Object.keys(oldValueMap);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n\n              if (oldValueMap[valueName]) {\n                throw new GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return newValueMap;\n  }\n\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendArgs(args) {\n    return keyValMap(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value; // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    return possibleTypes;\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value; // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr3 = Object.keys(oldFieldMap);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendType(typeDef.ofType));\n    }\n\n    return extendNamedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_EXTENSION:\n      if (!isObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      if (!isInterfaceType(type)) {\n        throw new GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      if (!isEnumType(type)) {\n        throw new GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.UNION_TYPE_EXTENSION:\n      if (!isUnionType(type)) {\n        throw new GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!isInputObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n  }\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/utilities/extendSchema.mjs"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","invariant","keyMap","keyValMap","objectValues","ASTDefinitionBuilder","assertValidSDLExtension","GraphQLError","isSchema","GraphQLSchema","isIntrospectionType","isSpecifiedScalarType","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLDirective","Kind","isTypeDefinitionNode","isTypeExtensionNode","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","typeDefinitionMap","create","typeExtensionsMap","directiveDefinitions","schemaDef","schemaExtensions","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","push","typeName","name","getType","extendedTypeName","existingType","checkExtensionNode","existingTypeExtensions","DIRECTIVE_DEFINITION","directiveName","existingDirective","getDirective","astBuilder","typeRef","extendNamedType","extendTypeCache","operationTypes","query","extendMaybeNamedType","getQueryType","mutation","getMutationType","subscription","getSubscriptionType","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","_ref2","operation","type","Error","buildType","err","return","_i","schemaExtension","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","_ref4","schemaExtensionASTNodes","extensionASTNodes","types","getTypeMap","map","allowedLegacyNames","__allowedLegacyNames","directives","getMergedDirectives","astNode","existingDirectives","getDirectives","extendDirective","node","buildDirective","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","directive","description","locations","args","extendArgs","fields","extendInputFieldMap","newFieldMap","oldFieldMap","getFields","_arr","_i2","_fieldName","_field","extendType","defaultValue","extensions","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","extension","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","field","fieldName","buildInputField","values","extendValueMap","newValueMap","oldValueMap","getValues","_arr2","_i3","_valueName","_value","deprecationReason","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","valueName","buildEnumValue","serialize","parseValue","parseLiteral","interfaces","extendImplementedInterfaces","extendFieldMap","isTypeOf","arg","resolveType","extendPossibleTypes","possibleTypes","getTypes","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","namedType","getInterfaces","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_arr3","_i4","_fieldName2","_field2","resolve","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","buildField","typeDef","ofType","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","UNION_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION"],"mappings":"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","sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport objectValues from '../jsutils/objectValues';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isSchema, GraphQLSchema } from '../type/schema';\nimport { isIntrospectionType } from '../type/introspection';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { GraphQLDirective } from '../type/directives';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n\n      if (schema.getType(typeName)) {\n        throw new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n\n      typeDefinitionMap[typeName] = def;\n    } else if (isTypeExtensionNode(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n\n      if (!existingType) {\n        throw new GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n\n      if (existingDirective) {\n        throw new GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n\n    throw new GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n            type = _ref2.type;\n\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n              type = _ref4.type;\n\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = objectValues(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat(objectValues(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n\n  return new GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? invariant(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    var name = type.name;\n\n    if (!extendTypeCache[name]) {\n      if (isScalarType(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if (isObjectType(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if (isInterfaceType(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if (isUnionType(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if (isEnumType(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if (isInputObjectType(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n\n    return extendTypeCache[name];\n  }\n\n  function extendDirective(directive) {\n    return new GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr = Object.keys(oldFieldMap);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = keyMap(type.getValues(), function (value) {\n      return value.name;\n    });\n\n    var _arr2 = Object.keys(oldValueMap);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n\n              if (oldValueMap[valueName]) {\n                throw new GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return newValueMap;\n  }\n\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendArgs(args) {\n    return keyValMap(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    return possibleTypes;\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr3 = Object.keys(oldFieldMap);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendType(typeDef) {\n    if (isListType(typeDef)) {\n      return GraphQLList(extendType(typeDef.ofType));\n    }\n\n    if (isNonNullType(typeDef)) {\n      return GraphQLNonNull(extendType(typeDef.ofType));\n    }\n\n    return extendNamedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_EXTENSION:\n      if (!isObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      if (!isInterfaceType(type)) {\n        throw new GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      if (!isEnumType(type)) {\n        throw new GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.UNION_TYPE_EXTENSION:\n      if (!isUnionType(type)) {\n        throw new GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!isInputObjectType(type)) {\n        throw new GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n  }\n}"]},"metadata":{},"sourceType":"module"}