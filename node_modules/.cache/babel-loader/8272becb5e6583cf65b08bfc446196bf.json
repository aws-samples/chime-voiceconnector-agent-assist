{"ast":null,"code":"var AWS = require('./core');\n\nvar AcceptorStateMachine = require('./state_machine');\n\nvar inherit = AWS.util.inherit;\nvar domain = AWS.util.domain;\n\nvar jmespath = require('jmespath');\n/**\n * @api private\n */\n\n\nvar hardErrorStates = {\n  success: 1,\n  error: 1,\n  complete: 1\n};\n\nfunction isTerminalState(machine) {\n  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);\n}\n\nvar fsm = new AcceptorStateMachine();\n\nfsm.setupStates = function () {\n  var transition = function transition(_, done) {\n    var self = this;\n    self._haltHandlersOnError = false;\n    self.emit(self._asm.currentState, function (err) {\n      if (err) {\n        if (isTerminalState(self)) {\n          if (domain && self.domain instanceof domain.Domain) {\n            err.domainEmitter = self;\n            err.domain = self.domain;\n            err.domainThrown = false;\n            self.domain.emit('error', err);\n          } else {\n            throw err;\n          }\n        } else {\n          self.response.error = err;\n          done(err);\n        }\n      } else {\n        done(self.response.error);\n      }\n    });\n  };\n\n  this.addState('validate', 'build', 'error', transition);\n  this.addState('build', 'afterBuild', 'restart', transition);\n  this.addState('afterBuild', 'sign', 'restart', transition);\n  this.addState('sign', 'send', 'retry', transition);\n  this.addState('retry', 'afterRetry', 'afterRetry', transition);\n  this.addState('afterRetry', 'sign', 'error', transition);\n  this.addState('send', 'validateResponse', 'retry', transition);\n  this.addState('validateResponse', 'extractData', 'extractError', transition);\n  this.addState('extractError', 'extractData', 'retry', transition);\n  this.addState('extractData', 'success', 'retry', transition);\n  this.addState('restart', 'build', 'error', transition);\n  this.addState('success', 'complete', 'complete', transition);\n  this.addState('error', 'complete', 'complete', transition);\n  this.addState('complete', null, null, transition);\n};\n\nfsm.setupStates();\n/**\n * ## Asynchronous Requests\n *\n * All requests made through the SDK are asynchronous and use a\n * callback interface. Each service method that kicks off a request\n * returns an `AWS.Request` object that you can use to register\n * callbacks.\n *\n * For example, the following service method returns the request\n * object as \"request\", which can be used to register callbacks:\n *\n * ```javascript\n * // request is an AWS.Request object\n * var request = ec2.describeInstances();\n *\n * // register callbacks on request to retrieve response data\n * request.on('success', function(response) {\n *   console.log(response.data);\n * });\n * ```\n *\n * When a request is ready to be sent, the {send} method should\n * be called:\n *\n * ```javascript\n * request.send();\n * ```\n *\n * Since registered callbacks may or may not be idempotent, requests should only\n * be sent once. To perform the same operation multiple times, you will need to\n * create multiple request objects, each with its own registered callbacks.\n *\n * ## Removing Default Listeners for Events\n *\n * Request objects are built with default listeners for the various events,\n * depending on the service type. In some cases, you may want to remove\n * some built-in listeners to customize behaviour. Doing this requires\n * access to the built-in listener functions, which are exposed through\n * the {AWS.EventListeners.Core} namespace. For instance, you may\n * want to customize the HTTP handler used when sending a request. In this\n * case, you can remove the built-in listener associated with the 'send'\n * event, the {AWS.EventListeners.Core.SEND} listener and add your own.\n *\n * ## Multiple Callbacks and Chaining\n *\n * You can register multiple callbacks on any request object. The\n * callbacks can be registered for different events, or all for the\n * same event. In addition, you can chain callback registration, for\n * example:\n *\n * ```javascript\n * request.\n *   on('success', function(response) {\n *     console.log(\"Success!\");\n *   }).\n *   on('error', function(error, response) {\n *     console.log(\"Error!\");\n *   }).\n *   on('complete', function(response) {\n *     console.log(\"Always!\");\n *   }).\n *   send();\n * ```\n *\n * The above example will print either \"Success! Always!\", or \"Error! Always!\",\n * depending on whether the request succeeded or not.\n *\n * @!attribute httpRequest\n *   @readonly\n *   @!group HTTP Properties\n *   @return [AWS.HttpRequest] the raw HTTP request object\n *     containing request headers and body information\n *     sent by the service.\n *\n * @!attribute startTime\n *   @readonly\n *   @!group Operation Properties\n *   @return [Date] the time that the request started\n *\n * @!group Request Building Events\n *\n * @!event validate(request)\n *   Triggered when a request is being validated. Listeners\n *   should throw an error if the request should not be sent.\n *   @param request [Request] the request object being sent\n *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS\n *   @see AWS.EventListeners.Core.VALIDATE_REGION\n *   @example Ensuring that a certain parameter is set before sending a request\n *     var req = s3.putObject(params);\n *     req.on('validate', function() {\n *       if (!req.params.Body.match(/^Hello\\s/)) {\n *         throw new Error('Body must start with \"Hello \"');\n *       }\n *     });\n *     req.send(function(err, data) { ... });\n *\n * @!event build(request)\n *   Triggered when the request payload is being built. Listeners\n *   should fill the necessary information to send the request\n *   over HTTP.\n *   @param (see AWS.Request~validate)\n *   @example Add a custom HTTP header to a request\n *     var req = s3.putObject(params);\n *     req.on('build', function() {\n *       req.httpRequest.headers['Custom-Header'] = 'value';\n *     });\n *     req.send(function(err, data) { ... });\n *\n * @!event sign(request)\n *   Triggered when the request is being signed. Listeners should\n *   add the correct authentication headers and/or adjust the body,\n *   depending on the authentication mechanism being used.\n *   @param (see AWS.Request~validate)\n *\n * @!group Request Sending Events\n *\n * @!event send(response)\n *   Triggered when the request is ready to be sent. Listeners\n *   should call the underlying transport layer to initiate\n *   the sending of the request.\n *   @param response [Response] the response object\n *   @context [Request] the request object that was sent\n *   @see AWS.EventListeners.Core.SEND\n *\n * @!event retry(response)\n *   Triggered when a request failed and might need to be retried or redirected.\n *   If the response is retryable, the listener should set the\n *   `response.error.retryable` property to `true`, and optionally set\n *   `response.error.retryDelay` to the millisecond delay for the next attempt.\n *   In the case of a redirect, `response.error.redirect` should be set to\n *   `true` with `retryDelay` set to an optional delay on the next request.\n *\n *   If a listener decides that a request should not be retried,\n *   it should set both `retryable` and `redirect` to false.\n *\n *   Note that a retryable error will be retried at most\n *   {AWS.Config.maxRetries} times (based on the service object's config).\n *   Similarly, a request that is redirected will only redirect at most\n *   {AWS.Config.maxRedirects} times.\n *\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @example Adding a custom retry for a 404 response\n *     request.on('retry', function(response) {\n *       // this resource is not yet available, wait 10 seconds to get it again\n *       if (response.httpResponse.statusCode === 404 && response.error) {\n *         response.error.retryable = true;   // retry this error\n *         response.error.retryDelay = 10000; // wait 10 seconds\n *       }\n *     });\n *\n * @!group Data Parsing Events\n *\n * @!event extractError(response)\n *   Triggered on all non-2xx requests so that listeners can extract\n *   error details from the response body. Listeners to this event\n *   should set the `response.error` property.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event extractData(response)\n *   Triggered in successful requests to allow listeners to\n *   de-serialize the response body into `response.data`.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!group Completion Events\n *\n * @!event success(response)\n *   Triggered when the request completed successfully.\n *   `response.data` will contain the response data and\n *   `response.error` will be null.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event error(error, response)\n *   Triggered when an error occurs at any point during the\n *   request. `response.error` will contain details about the error\n *   that occurred. `response.data` will be null.\n *   @param error [Error] the error object containing details about\n *     the error that occurred.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event complete(response)\n *   Triggered whenever a request cycle completes. `response.error`\n *   should be checked, since the request may have failed.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!group HTTP Events\n *\n * @!event httpHeaders(statusCode, headers, response, statusMessage)\n *   Triggered when headers are sent by the remote server\n *   @param statusCode [Integer] the HTTP response code\n *   @param headers [map<String,String>] the response headers\n *   @param (see AWS.Request~send)\n *   @param statusMessage [String] A status message corresponding to the HTTP\n *                                 response code\n *   @context (see AWS.Request~send)\n *\n * @!event httpData(chunk, response)\n *   Triggered when data is sent by the remote server\n *   @param chunk [Buffer] the buffer data containing the next data chunk\n *     from the server\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @see AWS.EventListeners.Core.HTTP_DATA\n *\n * @!event httpUploadProgress(progress, response)\n *   Triggered when the HTTP request has uploaded more data\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @note This event will not be emitted in Node.js 0.8.x.\n *\n * @!event httpDownloadProgress(progress, response)\n *   Triggered when the HTTP request has downloaded more data\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @note This event will not be emitted in Node.js 0.8.x.\n *\n * @!event httpError(error, response)\n *   Triggered when the HTTP request failed\n *   @param error [Error] the error object that was thrown\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event httpDone(response)\n *   Triggered when the server is finished sending data\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @see AWS.Response\n */\n\nAWS.Request = inherit({\n  /**\n   * Creates a request for an operation on a given service with\n   * a set of input parameters.\n   *\n   * @param service [AWS.Service] the service to perform the operation on\n   * @param operation [String] the operation to perform on the service\n   * @param params [Object] parameters to send to the operation.\n   *   See the operation's documentation for the format of the\n   *   parameters.\n   */\n  constructor: function Request(service, operation, params) {\n    var endpoint = service.endpoint;\n    var region = service.config.region;\n    var customUserAgent = service.config.customUserAgent;\n\n    if (service.isGlobalEndpoint) {\n      if (service.signingRegion) {\n        region = service.signingRegion;\n      } else {\n        region = 'us-east-1';\n      }\n    }\n\n    this.domain = domain && domain.active;\n    this.service = service;\n    this.operation = operation;\n    this.params = params || {};\n    this.httpRequest = new AWS.HttpRequest(endpoint, region);\n    this.httpRequest.appendToUserAgent(customUserAgent);\n    this.startTime = service.getSkewCorrectedDate();\n    this.response = new AWS.Response(this);\n    this._asm = new AcceptorStateMachine(fsm.states, 'validate');\n    this._haltHandlersOnError = false;\n    AWS.SequentialExecutor.call(this);\n    this.emit = this.emitEvent;\n  },\n\n  /**\n   * @!group Sending a Request\n   */\n\n  /**\n   * @overload send(callback = null)\n   *   Sends the request object.\n   *\n   *   @callback callback function(err, data)\n   *     If a callback is supplied, it is called when a response is returned\n   *     from the service.\n   *     @context [AWS.Request] the request object being sent.\n   *     @param err [Error] the error object returned from the request.\n   *       Set to `null` if the request is successful.\n   *     @param data [Object] the de-serialized data returned from\n   *       the request. Set to `null` if a request error occurs.\n   *   @example Sending a request with a callback\n   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n   *     request.send(function(err, data) { console.log(err, data); });\n   *   @example Sending a request with no callback (using event handlers)\n   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n   *     request.on('complete', function(response) { ... }); // register a callback\n   *     request.send();\n   */\n  send: function send(callback) {\n    if (callback) {\n      // append to user agent\n      this.httpRequest.appendToUserAgent('callback');\n      this.on('complete', function (resp) {\n        callback.call(resp, resp.error, resp.data);\n      });\n    }\n\n    this.runTo();\n    return this.response;\n  },\n\n  /**\n   * @!method  promise()\n   *   Sends the request and returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [Object] the de-serialized data returned from the request.\n   *   @callback rejectedCallback function(error)\n   *     Called if the promise is rejected.\n   *     @param error [Error] the error object returned from the request.\n   *   @return [Promise] A promise that represents the state of the request.\n   *   @example Sending a request using promises.\n   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n   *     var result = request.promise();\n   *     result.then(function(data) { ... }, function(error) { ... });\n   */\n\n  /**\n   * @api private\n   */\n  build: function build(callback) {\n    return this.runTo('send', callback);\n  },\n\n  /**\n   * @api private\n   */\n  runTo: function runTo(state, done) {\n    this._asm.runTo(state, done, this);\n\n    return this;\n  },\n\n  /**\n   * Aborts a request, emitting the error and complete events.\n   *\n   * @!macro nobrowser\n   * @example Aborting a request after sending\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload\n   *   };\n   *   var request = s3.putObject(params);\n   *   request.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(request.abort.bind(request), 1000);\n   *\n   *   // prints \"Error: RequestAbortedError Request aborted by user\"\n   * @return [AWS.Request] the same request object, for chaining.\n   * @since v1.4.0\n   */\n  abort: function abort() {\n    this.removeAllListeners('validateResponse');\n    this.removeAllListeners('extractError');\n    this.on('validateResponse', function addAbortedError(resp) {\n      resp.error = AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError',\n        retryable: false\n      });\n    });\n\n    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {\n      // abort HTTP stream\n      this.httpRequest.stream.abort();\n\n      if (this.httpRequest._abortCallback) {\n        this.httpRequest._abortCallback();\n      } else {\n        this.removeAllListeners('send'); // haven't sent yet, so let's not\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Iterates over each page of results given a pageable request, calling\n   * the provided callback with each page of data. After all pages have been\n   * retrieved, the callback is called with `null` data.\n   *\n   * @note This operation can generate multiple requests to a service.\n   * @example Iterating over multiple pages of objects in an S3 bucket\n   *   var pages = 1;\n   *   s3.listObjects().eachPage(function(err, data) {\n   *     if (err) return;\n   *     console.log(\"Page\", pages++);\n   *     console.log(data);\n   *   });\n   * @example Iterating over multiple pages with an asynchronous callback\n   *   s3.listObjects(params).eachPage(function(err, data, done) {\n   *     doSomethingAsyncAndOrExpensive(function() {\n   *       // The next page of results isn't fetched until done is called\n   *       done();\n   *     });\n   *   });\n   * @callback callback function(err, data, [doneCallback])\n   *   Called with each page of resulting data from the request. If the\n   *   optional `doneCallback` is provided in the function, it must be called\n   *   when the callback is complete.\n   *\n   *   @param err [Error] an error object, if an error occurred.\n   *   @param data [Object] a single page of response data. If there is no\n   *     more data, this object will be `null`.\n   *   @param doneCallback [Function] an optional done callback. If this\n   *     argument is defined in the function declaration, it should be called\n   *     when the next page is ready to be retrieved. This is useful for\n   *     controlling serial pagination across asynchronous operations.\n   *   @return [Boolean] if the callback returns `false`, pagination will\n   *     stop.\n   *\n   * @see AWS.Request.eachItem\n   * @see AWS.Response.nextPage\n   * @since v1.4.0\n   */\n  eachPage: function eachPage(callback) {\n    // Make all callbacks async-ish\n    callback = AWS.util.fn.makeAsync(callback, 3);\n\n    function wrappedCallback(response) {\n      callback.call(response, response.error, response.data, function (result) {\n        if (result === false) return;\n\n        if (response.hasNextPage()) {\n          response.nextPage().on('complete', wrappedCallback).send();\n        } else {\n          callback.call(response, null, null, AWS.util.fn.noop);\n        }\n      });\n    }\n\n    this.on('complete', wrappedCallback).send();\n  },\n\n  /**\n   * Enumerates over individual items of a request, paging the responses if\n   * necessary.\n   *\n   * @api experimental\n   * @since v1.4.0\n   */\n  eachItem: function eachItem(callback) {\n    var self = this;\n\n    function wrappedCallback(err, data) {\n      if (err) return callback(err, null);\n      if (data === null) return callback(null, null);\n      var config = self.service.paginationConfig(self.operation);\n      var resultKey = config.resultKey;\n      if (Array.isArray(resultKey)) resultKey = resultKey[0];\n      var items = jmespath.search(data, resultKey);\n      var continueIteration = true;\n      AWS.util.arrayEach(items, function (item) {\n        continueIteration = callback(null, item);\n\n        if (continueIteration === false) {\n          return AWS.util.abort;\n        }\n      });\n      return continueIteration;\n    }\n\n    this.eachPage(wrappedCallback);\n  },\n\n  /**\n   * @return [Boolean] whether the operation can return multiple pages of\n   *   response data.\n   * @see AWS.Response.eachPage\n   * @since v1.4.0\n   */\n  isPageable: function isPageable() {\n    return this.service.paginationConfig(this.operation) ? true : false;\n  },\n\n  /**\n   * Sends the request and converts the request object into a readable stream\n   * that can be read from or piped into a writable stream.\n   *\n   * @note The data read from a readable stream contains only\n   *   the raw HTTP body contents.\n   * @example Manually reading from a stream\n   *   request.createReadStream().on('data', function(data) {\n   *     console.log(\"Got data:\", data.toString());\n   *   });\n   * @example Piping a request body into a file\n   *   var out = fs.createWriteStream('/path/to/outfile.jpg');\n   *   s3.service.getObject(params).createReadStream().pipe(out);\n   * @return [Stream] the readable stream object that can be piped\n   *   or read from (by registering 'data' event listeners).\n   * @!macro nobrowser\n   */\n  createReadStream: function createReadStream() {\n    var streams = AWS.util.stream;\n    var req = this;\n    var stream = null;\n\n    if (AWS.HttpClient.streamsApiVersion === 2) {\n      stream = new streams.PassThrough();\n      process.nextTick(function () {\n        req.send();\n      });\n    } else {\n      stream = new streams.Stream();\n      stream.readable = true;\n      stream.sent = false;\n      stream.on('newListener', function (event) {\n        if (!stream.sent && event === 'data') {\n          stream.sent = true;\n          process.nextTick(function () {\n            req.send();\n          });\n        }\n      });\n    }\n\n    this.on('error', function (err) {\n      stream.emit('error', err);\n    });\n    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {\n      if (statusCode < 300) {\n        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);\n        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);\n        req.on('httpError', function streamHttpError(error) {\n          resp.error = error;\n          resp.error.retryable = false;\n        });\n        var shouldCheckContentLength = false;\n        var expectedLen;\n\n        if (req.httpRequest.method !== 'HEAD') {\n          expectedLen = parseInt(headers['content-length'], 10);\n        }\n\n        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {\n          shouldCheckContentLength = true;\n          var receivedLen = 0;\n        }\n\n        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {\n          if (shouldCheckContentLength && receivedLen !== expectedLen) {\n            stream.emit('error', AWS.util.error(new Error('Stream content length mismatch. Received ' + receivedLen + ' of ' + expectedLen + ' bytes.'), {\n              code: 'StreamContentLengthMismatch'\n            }));\n          } else if (AWS.HttpClient.streamsApiVersion === 2) {\n            stream.end();\n          } else {\n            stream.emit('end');\n          }\n        };\n\n        var httpStream = resp.httpResponse.createUnbufferedStream();\n\n        if (AWS.HttpClient.streamsApiVersion === 2) {\n          if (shouldCheckContentLength) {\n            var lengthAccumulator = new streams.PassThrough();\n\n            lengthAccumulator._write = function (chunk) {\n              if (chunk && chunk.length) {\n                receivedLen += chunk.length;\n              }\n\n              return streams.PassThrough.prototype._write.apply(this, arguments);\n            };\n\n            lengthAccumulator.on('end', checkContentLengthAndEmit);\n            stream.on('error', function (err) {\n              shouldCheckContentLength = false;\n              httpStream.unpipe(lengthAccumulator);\n              lengthAccumulator.emit('end');\n              lengthAccumulator.end();\n            });\n            httpStream.pipe(lengthAccumulator).pipe(stream, {\n              end: false\n            });\n          } else {\n            httpStream.pipe(stream);\n          }\n        } else {\n          if (shouldCheckContentLength) {\n            httpStream.on('data', function (arg) {\n              if (arg && arg.length) {\n                receivedLen += arg.length;\n              }\n            });\n          }\n\n          httpStream.on('data', function (arg) {\n            stream.emit('data', arg);\n          });\n          httpStream.on('end', checkContentLengthAndEmit);\n        }\n\n        httpStream.on('error', function (err) {\n          shouldCheckContentLength = false;\n          stream.emit('error', err);\n        });\n      }\n    });\n    return stream;\n  },\n\n  /**\n   * @param [Array,Response] args This should be the response object,\n   *   or an array of args to send to the event.\n   * @api private\n   */\n  emitEvent: function emit(eventName, args, done) {\n    if (typeof args === 'function') {\n      done = args;\n      args = null;\n    }\n\n    if (!done) done = function done() {};\n    if (!args) args = this.eventParameters(eventName, this.response);\n    var origEmit = AWS.SequentialExecutor.prototype.emit;\n    origEmit.call(this, eventName, args, function (err) {\n      if (err) this.response.error = err;\n      done.call(this, err);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  eventParameters: function eventParameters(eventName) {\n    switch (eventName) {\n      case 'restart':\n      case 'validate':\n      case 'sign':\n      case 'build':\n      case 'afterValidate':\n      case 'afterBuild':\n        return [this];\n\n      case 'error':\n        return [this.response.error, this.response];\n\n      default:\n        return [this.response];\n    }\n  },\n\n  /**\n   * @api private\n   */\n  presign: function presign(expires, callback) {\n    if (!callback && typeof expires === 'function') {\n      callback = expires;\n      expires = null;\n    }\n\n    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);\n  },\n\n  /**\n   * @api private\n   */\n  isPresigned: function isPresigned() {\n    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');\n  },\n\n  /**\n   * @api private\n   */\n  toUnauthenticated: function toUnauthenticated() {\n    this._unAuthenticated = true;\n    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);\n    this.removeListener('sign', AWS.EventListeners.Core.SIGN);\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  toGet: function toGet() {\n    if (this.service.api.protocol === 'query' || this.service.api.protocol === 'ec2') {\n      this.removeListener('build', this.buildAsGet);\n      this.addListener('build', this.buildAsGet);\n    }\n\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  buildAsGet: function buildAsGet(request) {\n    request.httpRequest.method = 'GET';\n    request.httpRequest.path = request.service.endpoint.path + '?' + request.httpRequest.body;\n    request.httpRequest.body = ''; // don't need these headers on a GET request\n\n    delete request.httpRequest.headers['Content-Length'];\n    delete request.httpRequest.headers['Content-Type'];\n  },\n\n  /**\n   * @api private\n   */\n  haltHandlersOnError: function haltHandlersOnError() {\n    this._haltHandlersOnError = true;\n  }\n});\n/**\n * @api private\n */\n\nAWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = function promise() {\n    var self = this; // append to user agent\n\n    this.httpRequest.appendToUserAgent('promise');\n    return new PromiseDependency(function (resolve, reject) {\n      self.on('complete', function (resp) {\n        if (resp.error) {\n          reject(resp.error);\n        } else {\n          // define $response property so that it is not enumberable\n          // this prevents circular reference errors when stringifying the JSON object\n          resolve(Object.defineProperty(resp.data || {}, '$response', {\n            value: resp\n          }));\n        }\n      });\n      self.runTo();\n    });\n  };\n};\n/**\n * @api private\n */\n\n\nAWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.Request);\nAWS.util.mixin(AWS.Request, AWS.SequentialExecutor);","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/request.js"],"names":["AWS","require","AcceptorStateMachine","inherit","util","domain","jmespath","hardErrorStates","success","error","complete","isTerminalState","machine","Object","prototype","hasOwnProperty","call","_asm","currentState","fsm","setupStates","transition","_","done","self","_haltHandlersOnError","emit","err","Domain","domainEmitter","domainThrown","response","addState","Request","constructor","service","operation","params","endpoint","region","config","customUserAgent","isGlobalEndpoint","signingRegion","active","httpRequest","HttpRequest","appendToUserAgent","startTime","getSkewCorrectedDate","Response","states","SequentialExecutor","emitEvent","send","callback","on","resp","data","runTo","build","state","abort","removeAllListeners","addAbortedError","Error","code","retryable","stream","didCallback","_abortCallback","eachPage","fn","makeAsync","wrappedCallback","result","hasNextPage","nextPage","noop","eachItem","paginationConfig","resultKey","Array","isArray","items","search","continueIteration","arrayEach","item","isPageable","createReadStream","streams","req","HttpClient","streamsApiVersion","PassThrough","process","nextTick","Stream","readable","sent","event","streamHeaders","statusCode","headers","removeListener","EventListeners","Core","HTTP_DATA","HTTP_ERROR","streamHttpError","shouldCheckContentLength","expectedLen","method","parseInt","undefined","isNaN","receivedLen","checkContentLengthAndEmit","end","httpStream","httpResponse","createUnbufferedStream","lengthAccumulator","_write","chunk","length","apply","arguments","unpipe","pipe","arg","eventName","args","eventParameters","origEmit","presign","expires","Signers","Presign","sign","toGet","isPresigned","toUnauthenticated","_unAuthenticated","VALIDATE_CREDENTIALS","SIGN","api","protocol","buildAsGet","addListener","request","path","body","haltHandlersOnError","addPromisesToClass","PromiseDependency","promise","resolve","reject","defineProperty","value","deletePromisesFromClass","addPromises","mixin"],"mappings":"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","sourcesContent":["var AWS = require('./core');\nvar AcceptorStateMachine = require('./state_machine');\nvar inherit = AWS.util.inherit;\nvar domain = AWS.util.domain;\nvar jmespath = require('jmespath');\n\n/**\n * @api private\n */\nvar hardErrorStates = {success: 1, error: 1, complete: 1};\n\nfunction isTerminalState(machine) {\n  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);\n}\n\nvar fsm = new AcceptorStateMachine();\nfsm.setupStates = function() {\n  var transition = function(_, done) {\n    var self = this;\n    self._haltHandlersOnError = false;\n\n    self.emit(self._asm.currentState, function(err) {\n      if (err) {\n        if (isTerminalState(self)) {\n          if (domain && self.domain instanceof domain.Domain) {\n            err.domainEmitter = self;\n            err.domain = self.domain;\n            err.domainThrown = false;\n            self.domain.emit('error', err);\n          } else {\n            throw err;\n          }\n        } else {\n          self.response.error = err;\n          done(err);\n        }\n      } else {\n        done(self.response.error);\n      }\n    });\n\n  };\n\n  this.addState('validate', 'build', 'error', transition);\n  this.addState('build', 'afterBuild', 'restart', transition);\n  this.addState('afterBuild', 'sign', 'restart', transition);\n  this.addState('sign', 'send', 'retry', transition);\n  this.addState('retry', 'afterRetry', 'afterRetry', transition);\n  this.addState('afterRetry', 'sign', 'error', transition);\n  this.addState('send', 'validateResponse', 'retry', transition);\n  this.addState('validateResponse', 'extractData', 'extractError', transition);\n  this.addState('extractError', 'extractData', 'retry', transition);\n  this.addState('extractData', 'success', 'retry', transition);\n  this.addState('restart', 'build', 'error', transition);\n  this.addState('success', 'complete', 'complete', transition);\n  this.addState('error', 'complete', 'complete', transition);\n  this.addState('complete', null, null, transition);\n};\nfsm.setupStates();\n\n/**\n * ## Asynchronous Requests\n *\n * All requests made through the SDK are asynchronous and use a\n * callback interface. Each service method that kicks off a request\n * returns an `AWS.Request` object that you can use to register\n * callbacks.\n *\n * For example, the following service method returns the request\n * object as \"request\", which can be used to register callbacks:\n *\n * ```javascript\n * // request is an AWS.Request object\n * var request = ec2.describeInstances();\n *\n * // register callbacks on request to retrieve response data\n * request.on('success', function(response) {\n *   console.log(response.data);\n * });\n * ```\n *\n * When a request is ready to be sent, the {send} method should\n * be called:\n *\n * ```javascript\n * request.send();\n * ```\n *\n * Since registered callbacks may or may not be idempotent, requests should only\n * be sent once. To perform the same operation multiple times, you will need to\n * create multiple request objects, each with its own registered callbacks.\n *\n * ## Removing Default Listeners for Events\n *\n * Request objects are built with default listeners for the various events,\n * depending on the service type. In some cases, you may want to remove\n * some built-in listeners to customize behaviour. Doing this requires\n * access to the built-in listener functions, which are exposed through\n * the {AWS.EventListeners.Core} namespace. For instance, you may\n * want to customize the HTTP handler used when sending a request. In this\n * case, you can remove the built-in listener associated with the 'send'\n * event, the {AWS.EventListeners.Core.SEND} listener and add your own.\n *\n * ## Multiple Callbacks and Chaining\n *\n * You can register multiple callbacks on any request object. The\n * callbacks can be registered for different events, or all for the\n * same event. In addition, you can chain callback registration, for\n * example:\n *\n * ```javascript\n * request.\n *   on('success', function(response) {\n *     console.log(\"Success!\");\n *   }).\n *   on('error', function(error, response) {\n *     console.log(\"Error!\");\n *   }).\n *   on('complete', function(response) {\n *     console.log(\"Always!\");\n *   }).\n *   send();\n * ```\n *\n * The above example will print either \"Success! Always!\", or \"Error! Always!\",\n * depending on whether the request succeeded or not.\n *\n * @!attribute httpRequest\n *   @readonly\n *   @!group HTTP Properties\n *   @return [AWS.HttpRequest] the raw HTTP request object\n *     containing request headers and body information\n *     sent by the service.\n *\n * @!attribute startTime\n *   @readonly\n *   @!group Operation Properties\n *   @return [Date] the time that the request started\n *\n * @!group Request Building Events\n *\n * @!event validate(request)\n *   Triggered when a request is being validated. Listeners\n *   should throw an error if the request should not be sent.\n *   @param request [Request] the request object being sent\n *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS\n *   @see AWS.EventListeners.Core.VALIDATE_REGION\n *   @example Ensuring that a certain parameter is set before sending a request\n *     var req = s3.putObject(params);\n *     req.on('validate', function() {\n *       if (!req.params.Body.match(/^Hello\\s/)) {\n *         throw new Error('Body must start with \"Hello \"');\n *       }\n *     });\n *     req.send(function(err, data) { ... });\n *\n * @!event build(request)\n *   Triggered when the request payload is being built. Listeners\n *   should fill the necessary information to send the request\n *   over HTTP.\n *   @param (see AWS.Request~validate)\n *   @example Add a custom HTTP header to a request\n *     var req = s3.putObject(params);\n *     req.on('build', function() {\n *       req.httpRequest.headers['Custom-Header'] = 'value';\n *     });\n *     req.send(function(err, data) { ... });\n *\n * @!event sign(request)\n *   Triggered when the request is being signed. Listeners should\n *   add the correct authentication headers and/or adjust the body,\n *   depending on the authentication mechanism being used.\n *   @param (see AWS.Request~validate)\n *\n * @!group Request Sending Events\n *\n * @!event send(response)\n *   Triggered when the request is ready to be sent. Listeners\n *   should call the underlying transport layer to initiate\n *   the sending of the request.\n *   @param response [Response] the response object\n *   @context [Request] the request object that was sent\n *   @see AWS.EventListeners.Core.SEND\n *\n * @!event retry(response)\n *   Triggered when a request failed and might need to be retried or redirected.\n *   If the response is retryable, the listener should set the\n *   `response.error.retryable` property to `true`, and optionally set\n *   `response.error.retryDelay` to the millisecond delay for the next attempt.\n *   In the case of a redirect, `response.error.redirect` should be set to\n *   `true` with `retryDelay` set to an optional delay on the next request.\n *\n *   If a listener decides that a request should not be retried,\n *   it should set both `retryable` and `redirect` to false.\n *\n *   Note that a retryable error will be retried at most\n *   {AWS.Config.maxRetries} times (based on the service object's config).\n *   Similarly, a request that is redirected will only redirect at most\n *   {AWS.Config.maxRedirects} times.\n *\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @example Adding a custom retry for a 404 response\n *     request.on('retry', function(response) {\n *       // this resource is not yet available, wait 10 seconds to get it again\n *       if (response.httpResponse.statusCode === 404 && response.error) {\n *         response.error.retryable = true;   // retry this error\n *         response.error.retryDelay = 10000; // wait 10 seconds\n *       }\n *     });\n *\n * @!group Data Parsing Events\n *\n * @!event extractError(response)\n *   Triggered on all non-2xx requests so that listeners can extract\n *   error details from the response body. Listeners to this event\n *   should set the `response.error` property.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event extractData(response)\n *   Triggered in successful requests to allow listeners to\n *   de-serialize the response body into `response.data`.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!group Completion Events\n *\n * @!event success(response)\n *   Triggered when the request completed successfully.\n *   `response.data` will contain the response data and\n *   `response.error` will be null.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event error(error, response)\n *   Triggered when an error occurs at any point during the\n *   request. `response.error` will contain details about the error\n *   that occurred. `response.data` will be null.\n *   @param error [Error] the error object containing details about\n *     the error that occurred.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event complete(response)\n *   Triggered whenever a request cycle completes. `response.error`\n *   should be checked, since the request may have failed.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!group HTTP Events\n *\n * @!event httpHeaders(statusCode, headers, response, statusMessage)\n *   Triggered when headers are sent by the remote server\n *   @param statusCode [Integer] the HTTP response code\n *   @param headers [map<String,String>] the response headers\n *   @param (see AWS.Request~send)\n *   @param statusMessage [String] A status message corresponding to the HTTP\n *                                 response code\n *   @context (see AWS.Request~send)\n *\n * @!event httpData(chunk, response)\n *   Triggered when data is sent by the remote server\n *   @param chunk [Buffer] the buffer data containing the next data chunk\n *     from the server\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @see AWS.EventListeners.Core.HTTP_DATA\n *\n * @!event httpUploadProgress(progress, response)\n *   Triggered when the HTTP request has uploaded more data\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @note This event will not be emitted in Node.js 0.8.x.\n *\n * @!event httpDownloadProgress(progress, response)\n *   Triggered when the HTTP request has downloaded more data\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request.\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *   @note This event will not be emitted in Node.js 0.8.x.\n *\n * @!event httpError(error, response)\n *   Triggered when the HTTP request failed\n *   @param error [Error] the error object that was thrown\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @!event httpDone(response)\n *   Triggered when the server is finished sending data\n *   @param (see AWS.Request~send)\n *   @context (see AWS.Request~send)\n *\n * @see AWS.Response\n */\nAWS.Request = inherit({\n\n  /**\n   * Creates a request for an operation on a given service with\n   * a set of input parameters.\n   *\n   * @param service [AWS.Service] the service to perform the operation on\n   * @param operation [String] the operation to perform on the service\n   * @param params [Object] parameters to send to the operation.\n   *   See the operation's documentation for the format of the\n   *   parameters.\n   */\n  constructor: function Request(service, operation, params) {\n    var endpoint = service.endpoint;\n    var region = service.config.region;\n    var customUserAgent = service.config.customUserAgent;\n\n    if (service.isGlobalEndpoint) {\n      if (service.signingRegion) {\n        region = service.signingRegion;\n      } else {\n        region = 'us-east-1';\n      }\n    }\n\n    this.domain = domain && domain.active;\n    this.service = service;\n    this.operation = operation;\n    this.params = params || {};\n    this.httpRequest = new AWS.HttpRequest(endpoint, region);\n    this.httpRequest.appendToUserAgent(customUserAgent);\n    this.startTime = service.getSkewCorrectedDate();\n\n    this.response = new AWS.Response(this);\n    this._asm = new AcceptorStateMachine(fsm.states, 'validate');\n    this._haltHandlersOnError = false;\n\n    AWS.SequentialExecutor.call(this);\n    this.emit = this.emitEvent;\n  },\n\n  /**\n   * @!group Sending a Request\n   */\n\n  /**\n   * @overload send(callback = null)\n   *   Sends the request object.\n   *\n   *   @callback callback function(err, data)\n   *     If a callback is supplied, it is called when a response is returned\n   *     from the service.\n   *     @context [AWS.Request] the request object being sent.\n   *     @param err [Error] the error object returned from the request.\n   *       Set to `null` if the request is successful.\n   *     @param data [Object] the de-serialized data returned from\n   *       the request. Set to `null` if a request error occurs.\n   *   @example Sending a request with a callback\n   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n   *     request.send(function(err, data) { console.log(err, data); });\n   *   @example Sending a request with no callback (using event handlers)\n   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n   *     request.on('complete', function(response) { ... }); // register a callback\n   *     request.send();\n   */\n  send: function send(callback) {\n    if (callback) {\n      // append to user agent\n      this.httpRequest.appendToUserAgent('callback');\n      this.on('complete', function (resp) {\n        callback.call(resp, resp.error, resp.data);\n      });\n    }\n    this.runTo();\n\n    return this.response;\n  },\n\n  /**\n   * @!method  promise()\n   *   Sends the request and returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [Object] the de-serialized data returned from the request.\n   *   @callback rejectedCallback function(error)\n   *     Called if the promise is rejected.\n   *     @param error [Error] the error object returned from the request.\n   *   @return [Promise] A promise that represents the state of the request.\n   *   @example Sending a request using promises.\n   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n   *     var result = request.promise();\n   *     result.then(function(data) { ... }, function(error) { ... });\n   */\n\n  /**\n   * @api private\n   */\n  build: function build(callback) {\n    return this.runTo('send', callback);\n  },\n\n  /**\n   * @api private\n   */\n  runTo: function runTo(state, done) {\n    this._asm.runTo(state, done, this);\n    return this;\n  },\n\n  /**\n   * Aborts a request, emitting the error and complete events.\n   *\n   * @!macro nobrowser\n   * @example Aborting a request after sending\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload\n   *   };\n   *   var request = s3.putObject(params);\n   *   request.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(request.abort.bind(request), 1000);\n   *\n   *   // prints \"Error: RequestAbortedError Request aborted by user\"\n   * @return [AWS.Request] the same request object, for chaining.\n   * @since v1.4.0\n   */\n  abort: function abort() {\n    this.removeAllListeners('validateResponse');\n    this.removeAllListeners('extractError');\n    this.on('validateResponse', function addAbortedError(resp) {\n      resp.error = AWS.util.error(new Error('Request aborted by user'), {\n         code: 'RequestAbortedError', retryable: false\n      });\n    });\n\n    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream\n      this.httpRequest.stream.abort();\n      if (this.httpRequest._abortCallback) {\n         this.httpRequest._abortCallback();\n      } else {\n        this.removeAllListeners('send'); // haven't sent yet, so let's not\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Iterates over each page of results given a pageable request, calling\n   * the provided callback with each page of data. After all pages have been\n   * retrieved, the callback is called with `null` data.\n   *\n   * @note This operation can generate multiple requests to a service.\n   * @example Iterating over multiple pages of objects in an S3 bucket\n   *   var pages = 1;\n   *   s3.listObjects().eachPage(function(err, data) {\n   *     if (err) return;\n   *     console.log(\"Page\", pages++);\n   *     console.log(data);\n   *   });\n   * @example Iterating over multiple pages with an asynchronous callback\n   *   s3.listObjects(params).eachPage(function(err, data, done) {\n   *     doSomethingAsyncAndOrExpensive(function() {\n   *       // The next page of results isn't fetched until done is called\n   *       done();\n   *     });\n   *   });\n   * @callback callback function(err, data, [doneCallback])\n   *   Called with each page of resulting data from the request. If the\n   *   optional `doneCallback` is provided in the function, it must be called\n   *   when the callback is complete.\n   *\n   *   @param err [Error] an error object, if an error occurred.\n   *   @param data [Object] a single page of response data. If there is no\n   *     more data, this object will be `null`.\n   *   @param doneCallback [Function] an optional done callback. If this\n   *     argument is defined in the function declaration, it should be called\n   *     when the next page is ready to be retrieved. This is useful for\n   *     controlling serial pagination across asynchronous operations.\n   *   @return [Boolean] if the callback returns `false`, pagination will\n   *     stop.\n   *\n   * @see AWS.Request.eachItem\n   * @see AWS.Response.nextPage\n   * @since v1.4.0\n   */\n  eachPage: function eachPage(callback) {\n    // Make all callbacks async-ish\n    callback = AWS.util.fn.makeAsync(callback, 3);\n\n    function wrappedCallback(response) {\n      callback.call(response, response.error, response.data, function (result) {\n        if (result === false) return;\n\n        if (response.hasNextPage()) {\n          response.nextPage().on('complete', wrappedCallback).send();\n        } else {\n          callback.call(response, null, null, AWS.util.fn.noop);\n        }\n      });\n    }\n\n    this.on('complete', wrappedCallback).send();\n  },\n\n  /**\n   * Enumerates over individual items of a request, paging the responses if\n   * necessary.\n   *\n   * @api experimental\n   * @since v1.4.0\n   */\n  eachItem: function eachItem(callback) {\n    var self = this;\n    function wrappedCallback(err, data) {\n      if (err) return callback(err, null);\n      if (data === null) return callback(null, null);\n\n      var config = self.service.paginationConfig(self.operation);\n      var resultKey = config.resultKey;\n      if (Array.isArray(resultKey)) resultKey = resultKey[0];\n      var items = jmespath.search(data, resultKey);\n      var continueIteration = true;\n      AWS.util.arrayEach(items, function(item) {\n        continueIteration = callback(null, item);\n        if (continueIteration === false) {\n          return AWS.util.abort;\n        }\n      });\n      return continueIteration;\n    }\n\n    this.eachPage(wrappedCallback);\n  },\n\n  /**\n   * @return [Boolean] whether the operation can return multiple pages of\n   *   response data.\n   * @see AWS.Response.eachPage\n   * @since v1.4.0\n   */\n  isPageable: function isPageable() {\n    return this.service.paginationConfig(this.operation) ? true : false;\n  },\n\n  /**\n   * Sends the request and converts the request object into a readable stream\n   * that can be read from or piped into a writable stream.\n   *\n   * @note The data read from a readable stream contains only\n   *   the raw HTTP body contents.\n   * @example Manually reading from a stream\n   *   request.createReadStream().on('data', function(data) {\n   *     console.log(\"Got data:\", data.toString());\n   *   });\n   * @example Piping a request body into a file\n   *   var out = fs.createWriteStream('/path/to/outfile.jpg');\n   *   s3.service.getObject(params).createReadStream().pipe(out);\n   * @return [Stream] the readable stream object that can be piped\n   *   or read from (by registering 'data' event listeners).\n   * @!macro nobrowser\n   */\n  createReadStream: function createReadStream() {\n    var streams = AWS.util.stream;\n    var req = this;\n    var stream = null;\n\n    if (AWS.HttpClient.streamsApiVersion === 2) {\n      stream = new streams.PassThrough();\n      process.nextTick(function() { req.send(); });\n    } else {\n      stream = new streams.Stream();\n      stream.readable = true;\n\n      stream.sent = false;\n      stream.on('newListener', function(event) {\n        if (!stream.sent && event === 'data') {\n          stream.sent = true;\n          process.nextTick(function() { req.send(); });\n        }\n      });\n    }\n\n    this.on('error', function(err) {\n      stream.emit('error', err);\n    });\n\n    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {\n      if (statusCode < 300) {\n        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);\n        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);\n        req.on('httpError', function streamHttpError(error) {\n          resp.error = error;\n          resp.error.retryable = false;\n        });\n\n        var shouldCheckContentLength = false;\n        var expectedLen;\n        if (req.httpRequest.method !== 'HEAD') {\n          expectedLen = parseInt(headers['content-length'], 10);\n        }\n        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {\n          shouldCheckContentLength = true;\n          var receivedLen = 0;\n        }\n\n        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {\n          if (shouldCheckContentLength && receivedLen !== expectedLen) {\n            stream.emit('error', AWS.util.error(\n              new Error('Stream content length mismatch. Received ' +\n                receivedLen + ' of ' + expectedLen + ' bytes.'),\n              { code: 'StreamContentLengthMismatch' }\n            ));\n          } else if (AWS.HttpClient.streamsApiVersion === 2) {\n            stream.end();\n          } else {\n            stream.emit('end');\n          }\n        };\n\n        var httpStream = resp.httpResponse.createUnbufferedStream();\n\n        if (AWS.HttpClient.streamsApiVersion === 2) {\n          if (shouldCheckContentLength) {\n            var lengthAccumulator = new streams.PassThrough();\n            lengthAccumulator._write = function(chunk) {\n              if (chunk && chunk.length) {\n                receivedLen += chunk.length;\n              }\n              return streams.PassThrough.prototype._write.apply(this, arguments);\n            };\n\n            lengthAccumulator.on('end', checkContentLengthAndEmit);\n            stream.on('error', function(err) {\n              shouldCheckContentLength = false;\n              httpStream.unpipe(lengthAccumulator);\n              lengthAccumulator.emit('end');\n              lengthAccumulator.end();\n            });\n            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });\n          } else {\n            httpStream.pipe(stream);\n          }\n        } else {\n\n          if (shouldCheckContentLength) {\n            httpStream.on('data', function(arg) {\n              if (arg && arg.length) {\n                receivedLen += arg.length;\n              }\n            });\n          }\n\n          httpStream.on('data', function(arg) {\n            stream.emit('data', arg);\n          });\n          httpStream.on('end', checkContentLengthAndEmit);\n        }\n\n        httpStream.on('error', function(err) {\n          shouldCheckContentLength = false;\n          stream.emit('error', err);\n        });\n      }\n    });\n\n    return stream;\n  },\n\n  /**\n   * @param [Array,Response] args This should be the response object,\n   *   or an array of args to send to the event.\n   * @api private\n   */\n  emitEvent: function emit(eventName, args, done) {\n    if (typeof args === 'function') { done = args; args = null; }\n    if (!done) done = function() { };\n    if (!args) args = this.eventParameters(eventName, this.response);\n\n    var origEmit = AWS.SequentialExecutor.prototype.emit;\n    origEmit.call(this, eventName, args, function (err) {\n      if (err) this.response.error = err;\n      done.call(this, err);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  eventParameters: function eventParameters(eventName) {\n    switch (eventName) {\n      case 'restart':\n      case 'validate':\n      case 'sign':\n      case 'build':\n      case 'afterValidate':\n      case 'afterBuild':\n        return [this];\n      case 'error':\n        return [this.response.error, this.response];\n      default:\n        return [this.response];\n    }\n  },\n\n  /**\n   * @api private\n   */\n  presign: function presign(expires, callback) {\n    if (!callback && typeof expires === 'function') {\n      callback = expires;\n      expires = null;\n    }\n    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);\n  },\n\n  /**\n   * @api private\n   */\n  isPresigned: function isPresigned() {\n    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');\n  },\n\n  /**\n   * @api private\n   */\n  toUnauthenticated: function toUnauthenticated() {\n    this._unAuthenticated = true;\n    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);\n    this.removeListener('sign', AWS.EventListeners.Core.SIGN);\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  toGet: function toGet() {\n    if (this.service.api.protocol === 'query' ||\n        this.service.api.protocol === 'ec2') {\n      this.removeListener('build', this.buildAsGet);\n      this.addListener('build', this.buildAsGet);\n    }\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  buildAsGet: function buildAsGet(request) {\n    request.httpRequest.method = 'GET';\n    request.httpRequest.path = request.service.endpoint.path +\n                               '?' + request.httpRequest.body;\n    request.httpRequest.body = '';\n\n    // don't need these headers on a GET request\n    delete request.httpRequest.headers['Content-Length'];\n    delete request.httpRequest.headers['Content-Type'];\n  },\n\n  /**\n   * @api private\n   */\n  haltHandlersOnError: function haltHandlersOnError() {\n    this._haltHandlersOnError = true;\n  }\n});\n\n/**\n * @api private\n */\nAWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = function promise() {\n    var self = this;\n    // append to user agent\n    this.httpRequest.appendToUserAgent('promise');\n    return new PromiseDependency(function(resolve, reject) {\n      self.on('complete', function(resp) {\n        if (resp.error) {\n          reject(resp.error);\n        } else {\n          // define $response property so that it is not enumberable\n          // this prevents circular reference errors when stringifying the JSON object\n          resolve(Object.defineProperty(\n            resp.data || {},\n            '$response',\n            {value: resp}\n          ));\n        }\n      });\n      self.runTo();\n    });\n  };\n};\n\n/**\n * @api private\n */\nAWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.Request);\n\nAWS.util.mixin(AWS.Request, AWS.SequentialExecutor);\n"]},"metadata":{},"sourceType":"script"}