{"ast":null,"code":"var AWS = require('./core');\n\nvar util = require('./util');\n\nvar endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];\n/**\n * Generate key (except resources and operation part) to index the endpoints in the cache\n * If input shape has endpointdiscoveryid trait then use\n *   accessKey + operation + resources + region + service as cache key\n * If input shape doesn't have endpointdiscoveryid trait then use\n *   accessKey + region + service as cache key\n * @return [map<String,String>] object with keys to index endpoints.\n * @api private\n */\n\nfunction getCacheKey(request) {\n  var service = request.service;\n  var api = service.api || {};\n  var operations = api.operations;\n  var identifiers = {};\n\n  if (service.config.region) {\n    identifiers.region = service.config.region;\n  }\n\n  if (api.serviceId) {\n    identifiers.serviceId = api.serviceId;\n  }\n\n  if (service.config.credentials.accessKeyId) {\n    identifiers.accessKeyId = service.config.credentials.accessKeyId;\n  }\n\n  return identifiers;\n}\n/**\n * Recursive helper for marshallCustomIdentifiers().\n * Looks for required string input members that have 'endpointdiscoveryid' trait.\n * @api private\n */\n\n\nfunction marshallCustomIdentifiersHelper(result, params, shape) {\n  if (!shape || params === undefined || params === null) return;\n\n  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {\n    util.arrayEach(shape.required, function (name) {\n      var memberShape = shape.members[name];\n\n      if (memberShape.endpointDiscoveryId === true) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        result[locationName] = String(params[name]);\n      } else {\n        marshallCustomIdentifiersHelper(result, params[name], memberShape);\n      }\n    });\n  }\n}\n/**\n * Get custom identifiers for cache key.\n * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.\n * @param [object] request object\n * @param [object] input shape of the given operation's api\n * @api private\n */\n\n\nfunction marshallCustomIdentifiers(request, shape) {\n  var identifiers = {};\n  marshallCustomIdentifiersHelper(identifiers, request.params, shape);\n  return identifiers;\n}\n/**\n * Call endpoint discovery operation when it's optional.\n * When endpoint is available in cache then use the cached endpoints. If endpoints\n * are unavailable then use regional endpoints and call endpoint discovery operation\n * asynchronously. This is turned off by default.\n * @param [object] request object\n * @api private\n */\n\n\nfunction optionalDiscoverEndpoint(request) {\n  var service = request.service;\n  var api = service.api;\n  var operationModel = api.operations ? api.operations[request.operation] : undefined;\n  var inputShape = operationModel ? operationModel.input : undefined;\n  var identifiers = marshallCustomIdentifiers(request, inputShape);\n  var cacheKey = getCacheKey(request);\n\n  if (Object.keys(identifiers).length > 0) {\n    cacheKey = util.update(cacheKey, identifiers);\n    if (operationModel) cacheKey.operation = operationModel.name;\n  }\n\n  var endpoints = AWS.endpointCache.get(cacheKey);\n\n  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {\n    //endpoint operation is being made but response not yet received\n    //or endpoint operation just failed in 1 minute\n    return;\n  } else if (endpoints && endpoints.length > 0) {\n    //found endpoint record from cache\n    request.httpRequest.updateEndpoint(endpoints[0].Address);\n  } else {\n    //endpoint record not in cache or outdated. make discovery operation\n    var endpointRequest = service.makeRequest(api.endpointOperation, {\n      Operation: operationModel.name,\n      Identifiers: identifiers\n    });\n    addApiVersionHeader(endpointRequest);\n    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK); //put in a placeholder for endpoints already requested, prevent\n    //too much in-flight calls\n\n    AWS.endpointCache.put(cacheKey, [{\n      Address: '',\n      CachePeriodInMinutes: 1\n    }]);\n    endpointRequest.send(function (err, data) {\n      if (data && data.Endpoints) {\n        AWS.endpointCache.put(cacheKey, data.Endpoints);\n      } else if (err) {\n        AWS.endpointCache.put(cacheKey, [{\n          Address: '',\n          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute\n\n        }]);\n      }\n    });\n  }\n}\n\nvar requestQueue = {};\n/**\n * Call endpoint discovery operation when it's required.\n * When endpoint is available in cache then use cached ones. If endpoints are\n * unavailable then SDK should call endpoint operation then use returned new\n * endpoint for the api call. SDK will automatically attempt to do endpoint\n * discovery. This is turned off by default\n * @param [object] request object\n * @api private\n */\n\nfunction requiredDiscoverEndpoint(request, done) {\n  var service = request.service;\n  var api = service.api;\n  var operationModel = api.operations ? api.operations[request.operation] : undefined;\n  var inputShape = operationModel ? operationModel.input : undefined;\n  var identifiers = marshallCustomIdentifiers(request, inputShape);\n  var cacheKey = getCacheKey(request);\n\n  if (Object.keys(identifiers).length > 0) {\n    cacheKey = util.update(cacheKey, identifiers);\n    if (operationModel) cacheKey.operation = operationModel.name;\n  }\n\n  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys\n\n  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {\n    //endpoint operation is being made but response not yet received\n    //push request object to a pending queue\n    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n    requestQueue[cacheKeyStr].push({\n      request: request,\n      callback: done\n    });\n    return;\n  } else if (endpoints && endpoints.length > 0) {\n    request.httpRequest.updateEndpoint(endpoints[0].Address);\n    done();\n  } else {\n    var endpointRequest = service.makeRequest(api.endpointOperation, {\n      Operation: operationModel.name,\n      Identifiers: identifiers\n    });\n    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n    addApiVersionHeader(endpointRequest); //put in a placeholder for endpoints already requested, prevent\n    //too much in-flight calls\n\n    AWS.endpointCache.put(cacheKeyStr, [{\n      Address: '',\n      CachePeriodInMinutes: 60 //long-live cache\n\n    }]);\n    endpointRequest.send(function (err, data) {\n      if (err) {\n        request.response.error = util.error(err, {\n          retryable: false\n        });\n        AWS.endpointCache.remove(cacheKey); //fail all the pending requests in batch\n\n        if (requestQueue[cacheKeyStr]) {\n          var pendingRequests = requestQueue[cacheKeyStr];\n          util.arrayEach(pendingRequests, function (requestContext) {\n            requestContext.request.response.error = util.error(err, {\n              retryable: false\n            });\n            requestContext.callback();\n          });\n          delete requestQueue[cacheKeyStr];\n        }\n      } else if (data) {\n        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n        request.httpRequest.updateEndpoint(data.Endpoints[0].Address); //update the endpoint for all the pending requests in batch\n\n        if (requestQueue[cacheKeyStr]) {\n          var pendingRequests = requestQueue[cacheKeyStr];\n          util.arrayEach(pendingRequests, function (requestContext) {\n            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n            requestContext.callback();\n          });\n          delete requestQueue[cacheKeyStr];\n        }\n      }\n\n      done();\n    });\n  }\n}\n/**\n * add api version header to endpoint operation\n * @api private\n */\n\n\nfunction addApiVersionHeader(endpointRequest) {\n  var api = endpointRequest.service.api;\n  var apiVersion = api.apiVersion;\n\n  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {\n    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;\n  }\n}\n/**\n * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid\n * endpoint from cache.\n * @api private\n */\n\n\nfunction invalidateCachedEndpoints(response) {\n  var error = response.error;\n  var httpResponse = response.httpResponse;\n\n  if (error && (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)) {\n    var request = response.request;\n    var operations = request.service.api.operations || {};\n    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n\n    if (Object.keys(identifiers).length > 0) {\n      cacheKey = util.update(cacheKey, identifiers);\n      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;\n    }\n\n    AWS.endpointCache.remove(cacheKey);\n  }\n}\n/**\n * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.\n * @param [object] client Service client object.\n * @api private\n */\n\n\nfunction hasCustomEndpoint(client) {\n  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.\n  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {\n    throw util.error(new Error(), {\n      code: 'ConfigurationException',\n      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'\n    });\n  }\n\n  ;\n  var svcConfig = AWS.config[client.serviceIdentifier] || {};\n  return Boolean(AWS.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);\n}\n/**\n * @api private\n */\n\n\nfunction isFalsy(value) {\n  return ['false', '0'].indexOf(value) >= 0;\n}\n/**\n * If endpoint discovery should perform for this request when no operation requires endpoint\n * discovery for the given service.\n * SDK performs config resolution in order like below:\n * 1. If set in client configuration.\n * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.\n * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.\n * @param [object] request request object.\n * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this\n *  function returns undefined\n * @api private\n */\n\n\nfunction resolveEndpointDiscoveryConfig(request) {\n  var service = request.service || {};\n\n  if (service.config.endpointDiscoveryEnabled !== undefined) {\n    return service.config.endpointDiscoveryEnabled;\n  } //shared ini file is only available in Node\n  //not to check env in browser\n\n\n  if (util.isBrowser()) return undefined; // If any of recognized endpoint discovery config env is set\n\n  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {\n    var env = endpointDiscoveryEnabledEnvs[i];\n\n    if (Object.prototype.hasOwnProperty.call(process.env, env)) {\n      if (process.env[env] === '' || process.env[env] === undefined) {\n        throw util.error(new Error(), {\n          code: 'ConfigurationException',\n          message: 'environmental variable ' + env + ' cannot be set to nothing'\n        });\n      }\n\n      return !isFalsy(process.env[env]);\n    }\n  }\n\n  var configFile = {};\n\n  try {\n    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({\n      isConfig: true,\n      filename: process.env[AWS.util.sharedConfigFileEnv]\n    }) : {};\n  } catch (e) {}\n\n  var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS.util.defaultProfile] || {};\n\n  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {\n    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {\n      throw util.error(new Error(), {\n        code: 'ConfigurationException',\n        message: 'config file entry \\'endpoint_discovery_enabled\\' cannot be set to nothing'\n      });\n    }\n\n    return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);\n  }\n\n  return undefined;\n}\n/**\n * attach endpoint discovery logic to request object\n * @param [object] request\n * @api private\n */\n\n\nfunction discoverEndpoint(request, done) {\n  var service = request.service || {};\n  if (hasCustomEndpoint(service) || request.isPresigned()) return done();\n  var operations = service.api.operations || {};\n  var operationModel = operations[request.operation];\n  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';\n  var isEnabled = resolveEndpointDiscoveryConfig(request);\n  var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;\n\n  if (isEnabled || hasRequiredEndpointDiscovery) {\n    // Once a customer enables endpoint discovery, the SDK should start appending\n    // the string endpoint-discovery to the user-agent on all requests.\n    request.httpRequest.appendToUserAgent('endpoint-discovery');\n  }\n\n  switch (isEndpointDiscoveryRequired) {\n    case 'OPTIONAL':\n      if (isEnabled || hasRequiredEndpointDiscovery) {\n        // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery\n        // by default for all operations of that service, including operations where endpoint discovery is optional.\n        optionalDiscoverEndpoint(request);\n        request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);\n      }\n\n      done();\n      break;\n\n    case 'REQUIRED':\n      if (isEnabled === false) {\n        // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,\n        // then the SDK must return a clear and actionable exception.\n        request.response.error = util.error(new Error(), {\n          code: 'ConfigurationException',\n          message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation + '() requires it. Please check your configurations.'\n        });\n        done();\n        break;\n      }\n\n      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);\n      requiredDiscoverEndpoint(request, done);\n      break;\n\n    case 'NULL':\n    default:\n      done();\n      break;\n  }\n}\n\nmodule.exports = {\n  discoverEndpoint: discoverEndpoint,\n  requiredDiscoverEndpoint: requiredDiscoverEndpoint,\n  optionalDiscoverEndpoint: optionalDiscoverEndpoint,\n  marshallCustomIdentifiers: marshallCustomIdentifiers,\n  getCacheKey: getCacheKey,\n  invalidateCachedEndpoint: invalidateCachedEndpoints\n};","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/discover_endpoint.js"],"names":["AWS","require","util","endpointDiscoveryEnabledEnvs","getCacheKey","request","service","api","operations","identifiers","config","region","serviceId","credentials","accessKeyId","marshallCustomIdentifiersHelper","result","params","shape","undefined","type","required","length","arrayEach","name","memberShape","members","endpointDiscoveryId","locationName","isLocationName","String","marshallCustomIdentifiers","optionalDiscoverEndpoint","operationModel","operation","inputShape","input","cacheKey","Object","keys","update","endpoints","endpointCache","get","Address","httpRequest","updateEndpoint","endpointRequest","makeRequest","endpointOperation","Operation","Identifiers","addApiVersionHeader","removeListener","EventListeners","Core","VALIDATE_PARAMETERS","RETRY_CHECK","put","CachePeriodInMinutes","send","err","data","Endpoints","requestQueue","requiredDiscoverEndpoint","done","cacheKeyStr","EndpointCache","getKeyString","push","callback","response","error","retryable","remove","pendingRequests","requestContext","apiVersion","headers","invalidateCachedEndpoints","httpResponse","code","statusCode","hasCustomEndpoint","client","_originalConfig","endpoint","endpointDiscoveryEnabled","Error","message","svcConfig","serviceIdentifier","Boolean","isFalsy","value","indexOf","resolveEndpointDiscoveryConfig","isBrowser","i","env","prototype","hasOwnProperty","call","process","configFile","iniLoader","loadFrom","isConfig","filename","sharedConfigFileEnv","e","sharedFileConfig","AWS_PROFILE","defaultProfile","endpoint_discovery_enabled","discoverEndpoint","isPresigned","isEndpointDiscoveryRequired","endpointDiscoveryRequired","isEnabled","hasRequiredEndpointDiscovery","appendToUserAgent","addNamedListener","className","module","exports","invalidateCachedEndpoint"],"mappings":"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","sourcesContent":["var AWS = require('./core');\nvar util = require('./util');\nvar endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];\n\n/**\n * Generate key (except resources and operation part) to index the endpoints in the cache\n * If input shape has endpointdiscoveryid trait then use\n *   accessKey + operation + resources + region + service as cache key\n * If input shape doesn't have endpointdiscoveryid trait then use\n *   accessKey + region + service as cache key\n * @return [map<String,String>] object with keys to index endpoints.\n * @api private\n */\nfunction getCacheKey(request) {\n  var service = request.service;\n  var api = service.api || {};\n  var operations = api.operations;\n  var identifiers = {};\n  if (service.config.region) {\n    identifiers.region = service.config.region;\n  }\n  if (api.serviceId) {\n    identifiers.serviceId = api.serviceId;\n  }\n  if (service.config.credentials.accessKeyId) {\n    identifiers.accessKeyId = service.config.credentials.accessKeyId;\n  }\n  return identifiers;\n}\n\n/**\n * Recursive helper for marshallCustomIdentifiers().\n * Looks for required string input members that have 'endpointdiscoveryid' trait.\n * @api private\n */\nfunction marshallCustomIdentifiersHelper(result, params, shape) {\n  if (!shape || params === undefined || params === null) return;\n  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {\n    util.arrayEach(shape.required, function(name) {\n      var memberShape = shape.members[name];\n      if (memberShape.endpointDiscoveryId === true) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        result[locationName] = String(params[name]);\n      } else {\n        marshallCustomIdentifiersHelper(result, params[name], memberShape);\n      }\n    });\n  }\n}\n\n/**\n * Get custom identifiers for cache key.\n * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.\n * @param [object] request object\n * @param [object] input shape of the given operation's api\n * @api private\n */\nfunction marshallCustomIdentifiers(request, shape) {\n  var identifiers = {};\n  marshallCustomIdentifiersHelper(identifiers, request.params, shape);\n  return identifiers;\n}\n\n/**\n * Call endpoint discovery operation when it's optional.\n * When endpoint is available in cache then use the cached endpoints. If endpoints\n * are unavailable then use regional endpoints and call endpoint discovery operation\n * asynchronously. This is turned off by default.\n * @param [object] request object\n * @api private\n */\nfunction optionalDiscoverEndpoint(request) {\n  var service = request.service;\n  var api = service.api;\n  var operationModel = api.operations ? api.operations[request.operation] : undefined;\n  var inputShape = operationModel ? operationModel.input : undefined;\n\n  var identifiers = marshallCustomIdentifiers(request, inputShape);\n  var cacheKey = getCacheKey(request);\n  if (Object.keys(identifiers).length > 0) {\n    cacheKey = util.update(cacheKey, identifiers);\n    if (operationModel) cacheKey.operation = operationModel.name;\n  }\n  var endpoints = AWS.endpointCache.get(cacheKey);\n  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {\n    //endpoint operation is being made but response not yet received\n    //or endpoint operation just failed in 1 minute\n    return;\n  } else if (endpoints && endpoints.length > 0) {\n    //found endpoint record from cache\n    request.httpRequest.updateEndpoint(endpoints[0].Address);\n  } else {\n    //endpoint record not in cache or outdated. make discovery operation\n    var endpointRequest = service.makeRequest(api.endpointOperation, {\n      Operation: operationModel.name,\n      Identifiers: identifiers,\n    });\n    addApiVersionHeader(endpointRequest);\n    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);\n    //put in a placeholder for endpoints already requested, prevent\n    //too much in-flight calls\n    AWS.endpointCache.put(cacheKey, [{\n      Address: '',\n      CachePeriodInMinutes: 1\n    }]);\n    endpointRequest.send(function(err, data) {\n      if (data && data.Endpoints) {\n        AWS.endpointCache.put(cacheKey, data.Endpoints);\n      } else if (err) {\n        AWS.endpointCache.put(cacheKey, [{\n          Address: '',\n          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute\n        }]);\n      }\n    });\n  }\n}\n\nvar requestQueue = {};\n\n/**\n * Call endpoint discovery operation when it's required.\n * When endpoint is available in cache then use cached ones. If endpoints are\n * unavailable then SDK should call endpoint operation then use returned new\n * endpoint for the api call. SDK will automatically attempt to do endpoint\n * discovery. This is turned off by default\n * @param [object] request object\n * @api private\n */\nfunction requiredDiscoverEndpoint(request, done) {\n  var service = request.service;\n  var api = service.api;\n  var operationModel = api.operations ? api.operations[request.operation] : undefined;\n  var inputShape = operationModel ? operationModel.input : undefined;\n\n  var identifiers = marshallCustomIdentifiers(request, inputShape);\n  var cacheKey = getCacheKey(request);\n  if (Object.keys(identifiers).length > 0) {\n    cacheKey = util.update(cacheKey, identifiers);\n    if (operationModel) cacheKey.operation = operationModel.name;\n  }\n  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys\n  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {\n    //endpoint operation is being made but response not yet received\n    //push request object to a pending queue\n    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n    requestQueue[cacheKeyStr].push({request: request, callback: done});\n    return;\n  } else if (endpoints && endpoints.length > 0) {\n    request.httpRequest.updateEndpoint(endpoints[0].Address);\n    done();\n  } else {\n    var endpointRequest = service.makeRequest(api.endpointOperation, {\n      Operation: operationModel.name,\n      Identifiers: identifiers,\n    });\n    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n    addApiVersionHeader(endpointRequest);\n\n    //put in a placeholder for endpoints already requested, prevent\n    //too much in-flight calls\n    AWS.endpointCache.put(cacheKeyStr, [{\n      Address: '',\n      CachePeriodInMinutes: 60 //long-live cache\n    }]);\n    endpointRequest.send(function(err, data) {\n      if (err) {\n        request.response.error = util.error(err, { retryable: false });\n        AWS.endpointCache.remove(cacheKey);\n\n        //fail all the pending requests in batch\n        if (requestQueue[cacheKeyStr]) {\n          var pendingRequests = requestQueue[cacheKeyStr];\n          util.arrayEach(pendingRequests, function(requestContext) {\n            requestContext.request.response.error = util.error(err, { retryable: false });\n            requestContext.callback();\n          });\n          delete requestQueue[cacheKeyStr];\n        }\n      } else if (data) {\n        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n\n        //update the endpoint for all the pending requests in batch\n        if (requestQueue[cacheKeyStr]) {\n          var pendingRequests = requestQueue[cacheKeyStr];\n          util.arrayEach(pendingRequests, function(requestContext) {\n            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n            requestContext.callback();\n          });\n          delete requestQueue[cacheKeyStr];\n        }\n      }\n      done();\n    });\n  }\n}\n\n/**\n * add api version header to endpoint operation\n * @api private\n */\nfunction addApiVersionHeader(endpointRequest) {\n  var api = endpointRequest.service.api;\n  var apiVersion = api.apiVersion;\n  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {\n    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;\n  }\n}\n\n/**\n * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid\n * endpoint from cache.\n * @api private\n */\nfunction invalidateCachedEndpoints(response) {\n  var error = response.error;\n  var httpResponse = response.httpResponse;\n  if (error &&\n    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)\n  ) {\n    var request = response.request;\n    var operations = request.service.api.operations || {};\n    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n      cacheKey = util.update(cacheKey, identifiers);\n      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;\n    }\n    AWS.endpointCache.remove(cacheKey);\n  }\n}\n\n/**\n * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.\n * @param [object] client Service client object.\n * @api private\n */\nfunction hasCustomEndpoint(client) {\n  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.\n  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {\n    throw util.error(new Error(), {\n      code: 'ConfigurationException',\n      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'\n    });\n  };\n  var svcConfig = AWS.config[client.serviceIdentifier] || {};\n  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));\n}\n\n/**\n * @api private\n */\nfunction isFalsy(value) {\n  return ['false', '0'].indexOf(value) >= 0;\n}\n\n/**\n * If endpoint discovery should perform for this request when no operation requires endpoint\n * discovery for the given service.\n * SDK performs config resolution in order like below:\n * 1. If set in client configuration.\n * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.\n * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.\n * @param [object] request request object.\n * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this\n *  function returns undefined\n * @api private\n */\nfunction resolveEndpointDiscoveryConfig(request) {\n  var service = request.service || {};\n  if (service.config.endpointDiscoveryEnabled !== undefined) {\n    return service.config.endpointDiscoveryEnabled;\n  }\n\n  //shared ini file is only available in Node\n  //not to check env in browser\n  if (util.isBrowser()) return undefined;\n\n  // If any of recognized endpoint discovery config env is set\n  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {\n    var env = endpointDiscoveryEnabledEnvs[i];\n    if (Object.prototype.hasOwnProperty.call(process.env, env)) {\n      if (process.env[env] === '' || process.env[env] === undefined) {\n        throw util.error(new Error(), {\n          code: 'ConfigurationException',\n          message: 'environmental variable ' + env + ' cannot be set to nothing'\n        });\n      }\n      return !isFalsy(process.env[env]);\n    }\n  }\n\n  var configFile = {};\n  try {\n    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({\n      isConfig: true,\n      filename: process.env[AWS.util.sharedConfigFileEnv]\n    }) : {};\n  } catch (e) {}\n  var sharedFileConfig = configFile[\n    process.env.AWS_PROFILE || AWS.util.defaultProfile\n  ] || {};\n  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {\n    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {\n      throw util.error(new Error(), {\n        code: 'ConfigurationException',\n        message: 'config file entry \\'endpoint_discovery_enabled\\' cannot be set to nothing'\n      });\n    }\n    return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);\n  }\n  return undefined;\n}\n\n/**\n * attach endpoint discovery logic to request object\n * @param [object] request\n * @api private\n */\nfunction discoverEndpoint(request, done) {\n  var service = request.service || {};\n  if (hasCustomEndpoint(service) || request.isPresigned()) return done();\n\n  var operations = service.api.operations || {};\n  var operationModel = operations[request.operation];\n  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';\n  var isEnabled = resolveEndpointDiscoveryConfig(request);\n  var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;\n  if (isEnabled || hasRequiredEndpointDiscovery) {\n    // Once a customer enables endpoint discovery, the SDK should start appending\n    // the string endpoint-discovery to the user-agent on all requests.\n    request.httpRequest.appendToUserAgent('endpoint-discovery');\n  }\n  switch (isEndpointDiscoveryRequired) {\n    case 'OPTIONAL':\n      if (isEnabled || hasRequiredEndpointDiscovery) {\n        // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery\n        // by default for all operations of that service, including operations where endpoint discovery is optional.\n        optionalDiscoverEndpoint(request);\n        request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);\n      }\n      done();\n      break;\n    case 'REQUIRED':\n      if (isEnabled === false) {\n        // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,\n        // then the SDK must return a clear and actionable exception.\n        request.response.error = util.error(new Error(), {\n          code: 'ConfigurationException',\n          message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation +\n                    '() requires it. Please check your configurations.'\n        });\n        done();\n        break;\n      }\n      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);\n      requiredDiscoverEndpoint(request, done);\n      break;\n    case 'NULL':\n    default:\n      done();\n      break;\n  }\n}\n\nmodule.exports = {\n  discoverEndpoint: discoverEndpoint,\n  requiredDiscoverEndpoint: requiredDiscoverEndpoint,\n  optionalDiscoverEndpoint: optionalDiscoverEndpoint,\n  marshallCustomIdentifiers: marshallCustomIdentifiers,\n  getCacheKey: getCacheKey,\n  invalidateCachedEndpoint: invalidateCachedEndpoints,\n};\n"]},"metadata":{},"sourceType":"script"}