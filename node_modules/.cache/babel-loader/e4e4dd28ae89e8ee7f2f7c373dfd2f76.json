{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport { Kind } from '../language/kinds';\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from '../type/definition';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\nimport { typeFromAST } from './typeFromAST';\nimport find from '../jsutils/find';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _defineProperty(this, \"_schema\", void 0);\n\n    _defineProperty(this, \"_typeStack\", void 0);\n\n    _defineProperty(this, \"_parentTypeStack\", void 0);\n\n    _defineProperty(this, \"_inputTypeStack\", void 0);\n\n    _defineProperty(this, \"_fieldDefStack\", void 0);\n\n    _defineProperty(this, \"_defaultValueStack\", void 0);\n\n    _defineProperty(this, \"_directive\", void 0);\n\n    _defineProperty(this, \"_argument\", void 0);\n\n    _defineProperty(this, \"_enumValue\", void 0);\n\n    _defineProperty(this, \"_getFieldDef\", void 0);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = getNamedType(this.getType());\n\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n        break;\n\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef;\n        var fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        var type;\n\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n\n        this._typeStack.push(isObjectType(type) ? type : undefined);\n\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = typeFromAST(schema, node.type);\n\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n        break;\n\n      case Kind.ARGUMENT:\n        var argDef;\n        var argType;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = find(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n        break;\n\n      case Kind.LIST:\n        var listType = getNullableType(this.getInputType());\n        var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n        break;\n\n      case Kind.OBJECT_FIELD:\n        var objectType = getNamedType(this.getInputType());\n        var inputFieldType;\n        var inputField;\n\n        if (isInputObjectType(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n        break;\n\n      case Kind.ENUM:\n        var enumType = getNamedType(this.getInputType());\n        var enumValue;\n\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/utilities/TypeInfo.mjs"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","Kind","isObjectType","isInterfaceType","isEnumType","isInputObjectType","isListType","isCompositeType","isInputType","isOutputType","getNullableType","getNamedType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","find","TypeInfo","schema","getFieldDefFn","initialType","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","_proto","prototype","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","OPERATION_DEFINITION","operation","getQueryType","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","argDef","argType","fieldOrDirective","args","arg","defaultValue","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","fieldNode"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { Kind } from '../language/kinds';\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from '../type/definition';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\nimport { typeFromAST } from './typeFromAST';\nimport find from '../jsutils/find';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo =\n/*#__PURE__*/\nfunction () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _defineProperty(this, \"_schema\", void 0);\n\n    _defineProperty(this, \"_typeStack\", void 0);\n\n    _defineProperty(this, \"_parentTypeStack\", void 0);\n\n    _defineProperty(this, \"_inputTypeStack\", void 0);\n\n    _defineProperty(this, \"_fieldDefStack\", void 0);\n\n    _defineProperty(this, \"_defaultValueStack\", void 0);\n\n    _defineProperty(this, \"_directive\", void 0);\n\n    _defineProperty(this, \"_argument\", void 0);\n\n    _defineProperty(this, \"_enumValue\", void 0);\n\n    _defineProperty(this, \"_getFieldDef\", void 0);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        var namedType = getNamedType(this.getType());\n\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n        break;\n\n      case Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef;\n        var fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        var type;\n\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n\n        this._typeStack.push(isObjectType(type) ? type : undefined);\n\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        var inputType = typeFromAST(schema, node.type);\n\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n        break;\n\n      case Kind.ARGUMENT:\n        var argDef;\n        var argType;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = find(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n        break;\n\n      case Kind.LIST:\n        var listType = getNullableType(this.getInputType());\n        var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n        break;\n\n      case Kind.OBJECT_FIELD:\n        var objectType = getNamedType(this.getInputType());\n        var inputFieldType;\n        var inputField;\n\n        if (isInputObjectType(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n        break;\n\n      case Kind.ENUM:\n        var enumType = getNamedType(this.getInputType());\n        var enumValue;\n\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}"]},"metadata":{},"sourceType":"module"}