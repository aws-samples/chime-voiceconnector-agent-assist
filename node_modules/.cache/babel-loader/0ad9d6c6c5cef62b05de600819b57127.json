{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at \") + 'this location.';\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all directives at a given location\n * are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var directive = _step.value;\n            var directiveName = directive.name.value;\n\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));\n            } else {\n              knownDirectives[directiveName] = directive;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.mjs"],"names":["GraphQLError","duplicateDirectiveMessage","directiveName","concat","UniqueDirectivesPerLocation","context","enter","node","directives","knownDirectives","Object","create","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","directive","value","name","reportError","err","return"],"mappings":"AAAA;;;;;;;;AAQA,SAASA,YAAT,QAA6B,0BAA7B;AACA,OAAO,SAASC,yBAAT,CAAmCC,aAAnC,EAAkD;AACvD,SAAO,mBAAmBC,MAAnB,CAA0BD,aAA1B,EAAyC,8BAAzC,IAA2E,gBAAlF;AACD;AACD;;;;;;;AAOA,OAAO,SAASE,2BAAT,CAAqCC,OAArC,EAA8C;AACnD,SAAO;AACL;AACA;AACA;AACAC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,IAAf,EAAqB;AAC1B;AACA,UAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;;AAEA,UAAIA,UAAJ,EAAgB;AACd,YAAIC,eAAe,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAtB;AACA,YAAIC,yBAAyB,GAAG,IAAhC;AACA,YAAIC,iBAAiB,GAAG,KAAxB;AACA,YAAIC,cAAc,GAAGC,SAArB;;AAEA,YAAI;AACF,eAAK,IAAIC,SAAS,GAAGR,UAAU,CAACS,MAAM,CAACC,QAAR,CAAV,EAAhB,EAA+CC,KAApD,EAA2D,EAAEP,yBAAyB,GAAG,CAACO,KAAK,GAAGH,SAAS,CAACI,IAAV,EAAT,EAA2BC,IAAzD,CAA3D,EAA2HT,yBAAyB,GAAG,IAAvJ,EAA6J;AAC3J,gBAAIU,SAAS,GAAGH,KAAK,CAACI,KAAtB;AACA,gBAAIrB,aAAa,GAAGoB,SAAS,CAACE,IAAV,CAAeD,KAAnC;;AAEA,gBAAId,eAAe,CAACP,aAAD,CAAnB,EAAoC;AAClCG,cAAAA,OAAO,CAACoB,WAAR,CAAoB,IAAIzB,YAAJ,CAAiBC,yBAAyB,CAACC,aAAD,CAA1C,EAA2D,CAACO,eAAe,CAACP,aAAD,CAAhB,EAAiCoB,SAAjC,CAA3D,CAApB;AACD,aAFD,MAEO;AACLb,cAAAA,eAAe,CAACP,aAAD,CAAf,GAAiCoB,SAAjC;AACD;AACF;AACF,SAXD,CAWE,OAAOI,GAAP,EAAY;AACZb,UAAAA,iBAAiB,GAAG,IAApB;AACAC,UAAAA,cAAc,GAAGY,GAAjB;AACD,SAdD,SAcU;AACR,cAAI;AACF,gBAAI,CAACd,yBAAD,IAA8BI,SAAS,CAACW,MAAV,IAAoB,IAAtD,EAA4D;AAC1DX,cAAAA,SAAS,CAACW,MAAV;AACD;AACF,WAJD,SAIU;AACR,gBAAId,iBAAJ,EAAuB;AACrB,oBAAMC,cAAN;AACD;AACF;AACF;AACF;AACF;AAxCI,GAAP;AA0CD","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at \") + 'this location.';\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all directives at a given location\n * are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var directive = _step.value;\n            var directiveName = directive.name.value;\n\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));\n            } else {\n              knownDirectives[directiveName] = directive;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}