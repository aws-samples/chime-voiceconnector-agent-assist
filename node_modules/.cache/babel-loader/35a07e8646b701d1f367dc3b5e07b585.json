{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar buffer_1 = require(\"buffer\");\n\nvar is_array_buffer_1 = require(\"@aws-sdk/is-array-buffer\");\n\nfunction fromArrayBuffer(input, offset, length) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (length === void 0) {\n    length = input.byteLength - offset;\n  }\n\n  if (!is_array_buffer_1.isArrayBuffer(input)) {\n    throw new Error('argument passed to fromArrayBuffer was not an ArrayBuffer');\n  }\n\n  if (typeof buffer_1.Buffer.from === 'function' && buffer_1.Buffer.from !== Uint8Array.from) {\n    return buffer_1.Buffer.from(input, offset, length);\n  } // Any version of node that supports the optional offset and length\n  // parameters, which were added in Node 6.0.0, will support Buffer.from and\n  // have already returned. Throw if offset is not 0 or if length differs from\n  // the underlying buffer's length.\n\n\n  if (offset !== 0 || length !== input.byteLength) {\n    throw new Error(\"Unable to convert TypedArray to Buffer in Node \" + process.version);\n  }\n\n  return new buffer_1.Buffer(input);\n}\n\nexports.fromArrayBuffer = fromArrayBuffer;\n\nfunction fromString(input, encoding) {\n  if (typeof input !== 'string') {\n    throw new Error('argument passed to fromString was not a string');\n  }\n\n  if (typeof buffer_1.Buffer.from === 'function' && buffer_1.Buffer.from !== Uint8Array.from) {\n    return buffer_1.Buffer.from(input, encoding);\n  }\n\n  return new buffer_1.Buffer(input, encoding);\n}\n\nexports.fromString = fromString;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAEA,SAAgB,eAAhB,CACI,KADJ,EAEI,MAFJ,EAGI,MAHJ,EAG8C;AAD1C,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAA,CAAA;AAAkB;;AAClB,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAiB,KAAK,CAAC,UAAN,GAAmB,MAApC;AAA0C;;AAE1C,MAAI,CAAC,iBAAA,CAAA,aAAA,CAAc,KAAd,CAAL,EAA2B;AACvB,UAAM,IAAI,KAAJ,CACF,2DADE,CAAN;AAGH;;AAED,MAAI,OAAO,QAAA,CAAA,MAAA,CAAO,IAAd,KAAuB,UAAvB,IAAqC,QAAA,CAAA,MAAA,CAAO,IAAP,KAAgB,UAAU,CAAC,IAApE,EAA0E;AACtE,WAAO,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,KAAZ,EAAmB,MAAnB,EAA2B,MAA3B,CAAP;AACH,GAVyC,CAY1C;AACA;AACA;AACA;;;AACA,MAAI,MAAM,KAAK,CAAX,IAAgB,MAAM,KAAK,KAAK,CAAC,UAArC,EAAiD;AAC7C,UAAM,IAAI,KAAJ,CACF,oDAAkD,OAAO,CAAC,OADxD,CAAN;AAGH;;AACD,SAAO,IAAI,QAAA,CAAA,MAAJ,CAAW,KAAX,CAAP;AACH;;AAzBD,OAAA,CAAA,eAAA,GAAA,eAAA;;AA2BA,SAAgB,UAAhB,CACI,KADJ,EAEI,QAFJ,EAEsF;AAElF,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAM,IAAI,KAAJ,CAAU,gDAAV,CAAN;AACH;;AAED,MAAI,OAAO,QAAA,CAAA,MAAA,CAAO,IAAd,KAAuB,UAAvB,IAAqC,QAAA,CAAA,MAAA,CAAO,IAAP,KAAgB,UAAU,CAAC,IAApE,EAA0E;AACtE,WAAO,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,KAAZ,EAAmB,QAAnB,CAAP;AACH;;AAED,SAAO,IAAI,QAAA,CAAA,MAAJ,CAAW,KAAX,EAAkB,QAAlB,CAAP;AACH;;AAbD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"./src/","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar buffer_1 = require(\"buffer\");\nvar is_array_buffer_1 = require(\"@aws-sdk/is-array-buffer\");\nfunction fromArrayBuffer(input, offset, length) {\n    if (offset === void 0) { offset = 0; }\n    if (length === void 0) { length = input.byteLength - offset; }\n    if (!is_array_buffer_1.isArrayBuffer(input)) {\n        throw new Error('argument passed to fromArrayBuffer was not an ArrayBuffer');\n    }\n    if (typeof buffer_1.Buffer.from === 'function' && buffer_1.Buffer.from !== Uint8Array.from) {\n        return buffer_1.Buffer.from(input, offset, length);\n    }\n    // Any version of node that supports the optional offset and length\n    // parameters, which were added in Node 6.0.0, will support Buffer.from and\n    // have already returned. Throw if offset is not 0 or if length differs from\n    // the underlying buffer's length.\n    if (offset !== 0 || length !== input.byteLength) {\n        throw new Error(\"Unable to convert TypedArray to Buffer in Node \" + process.version);\n    }\n    return new buffer_1.Buffer(input);\n}\nexports.fromArrayBuffer = fromArrayBuffer;\nfunction fromString(input, encoding) {\n    if (typeof input !== 'string') {\n        throw new Error('argument passed to fromString was not a string');\n    }\n    if (typeof buffer_1.Buffer.from === 'function' && buffer_1.Buffer.from !== Uint8Array.from) {\n        return buffer_1.Buffer.from(input, encoding);\n    }\n    return new buffer_1.Buffer(input, encoding);\n}\nexports.fromString = fromString;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}