{"ast":null,"code":"var AWS = require('../core');\n/**\n * @api private\n */\n\n\nvar cachedSecret = {};\n/**\n * @api private\n */\n\nvar cacheQueue = [];\n/**\n * @api private\n */\n\nvar maxCacheEntries = 50;\n/**\n * @api private\n */\n\nvar v4Identifier = 'aws4_request';\n/**\n * @api private\n */\n\nmodule.exports = {\n  /**\n   * @api private\n   *\n   * @param date [String]\n   * @param region [String]\n   * @param serviceName [String]\n   * @return [String]\n   */\n  createScope: function createScope(date, region, serviceName) {\n    return [date.substr(0, 8), region, serviceName, v4Identifier].join('/');\n  },\n\n  /**\n   * @api private\n   *\n   * @param credentials [Credentials]\n   * @param date [String]\n   * @param region [String]\n   * @param service [String]\n   * @param shouldCache [Boolean]\n   * @return [String]\n   */\n  getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {\n    var credsIdentifier = AWS.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');\n    var cacheKey = [credsIdentifier, date, region, service].join('_');\n    shouldCache = shouldCache !== false;\n\n    if (shouldCache && cacheKey in cachedSecret) {\n      return cachedSecret[cacheKey];\n    }\n\n    var kDate = AWS.util.crypto.hmac('AWS4' + credentials.secretAccessKey, date, 'buffer');\n    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');\n    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');\n    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');\n\n    if (shouldCache) {\n      cachedSecret[cacheKey] = signingKey;\n      cacheQueue.push(cacheKey);\n\n      if (cacheQueue.length > maxCacheEntries) {\n        // remove the oldest entry (not the least recently used)\n        delete cachedSecret[cacheQueue.shift()];\n      }\n    }\n\n    return signingKey;\n  },\n\n  /**\n   * @api private\n   *\n   * Empties the derived signing key cache. Made available for testing purposes\n   * only.\n   */\n  emptyCache: function emptyCache() {\n    cachedSecret = {};\n    cacheQueue = [];\n  }\n};","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/signers/v4_credentials.js"],"names":["AWS","require","cachedSecret","cacheQueue","maxCacheEntries","v4Identifier","module","exports","createScope","date","region","serviceName","substr","join","getSigningKey","credentials","service","shouldCache","credsIdentifier","util","crypto","hmac","secretAccessKey","accessKeyId","cacheKey","kDate","kRegion","kService","signingKey","push","length","shift","emptyCache"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAD,CAAjB;AAEA;;;;;AAGA,IAAIC,YAAY,GAAG,EAAnB;AAEA;;;;AAGA,IAAIC,UAAU,GAAG,EAAjB;AAEA;;;;AAGA,IAAIC,eAAe,GAAG,EAAtB;AAEA;;;;AAGA,IAAIC,YAAY,GAAG,cAAnB;AAEA;;;;AAGAC,MAAM,CAACC,OAAP,GAAiB;AACf;;;;;;;;AAQAC,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBC,IAArB,EAA2BC,MAA3B,EAAmCC,WAAnC,EAAgD;AAC3D,WAAO,CACLF,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAe,CAAf,CADK,EAELF,MAFK,EAGLC,WAHK,EAILN,YAJK,EAKLQ,IALK,CAKA,GALA,CAAP;AAMD,GAhBc;;AAkBf;;;;;;;;;;AAUAC,EAAAA,aAAa,EAAE,SAASA,aAAT,CACbC,WADa,EAEbN,IAFa,EAGbC,MAHa,EAIbM,OAJa,EAKbC,WALa,EAMb;AACA,QAAIC,eAAe,GAAGlB,GAAG,CAACmB,IAAJ,CAASC,MAAT,CACnBC,IADmB,CACdN,WAAW,CAACO,eADE,EACeP,WAAW,CAACQ,WAD3B,EACwC,QADxC,CAAtB;AAEA,QAAIC,QAAQ,GAAG,CAACN,eAAD,EAAkBT,IAAlB,EAAwBC,MAAxB,EAAgCM,OAAhC,EAAyCH,IAAzC,CAA8C,GAA9C,CAAf;AACAI,IAAAA,WAAW,GAAGA,WAAW,KAAK,KAA9B;;AACA,QAAIA,WAAW,IAAKO,QAAQ,IAAItB,YAAhC,EAA+C;AAC7C,aAAOA,YAAY,CAACsB,QAAD,CAAnB;AACD;;AAED,QAAIC,KAAK,GAAGzB,GAAG,CAACmB,IAAJ,CAASC,MAAT,CAAgBC,IAAhB,CACV,SAASN,WAAW,CAACO,eADX,EAEVb,IAFU,EAGV,QAHU,CAAZ;AAKA,QAAIiB,OAAO,GAAG1B,GAAG,CAACmB,IAAJ,CAASC,MAAT,CAAgBC,IAAhB,CAAqBI,KAArB,EAA4Bf,MAA5B,EAAoC,QAApC,CAAd;AACA,QAAIiB,QAAQ,GAAG3B,GAAG,CAACmB,IAAJ,CAASC,MAAT,CAAgBC,IAAhB,CAAqBK,OAArB,EAA8BV,OAA9B,EAAuC,QAAvC,CAAf;AAEA,QAAIY,UAAU,GAAG5B,GAAG,CAACmB,IAAJ,CAASC,MAAT,CAAgBC,IAAhB,CAAqBM,QAArB,EAA+BtB,YAA/B,EAA6C,QAA7C,CAAjB;;AACA,QAAIY,WAAJ,EAAiB;AACff,MAAAA,YAAY,CAACsB,QAAD,CAAZ,GAAyBI,UAAzB;AACAzB,MAAAA,UAAU,CAAC0B,IAAX,CAAgBL,QAAhB;;AACA,UAAIrB,UAAU,CAAC2B,MAAX,GAAoB1B,eAAxB,EAAyC;AACvC;AACA,eAAOF,YAAY,CAACC,UAAU,CAAC4B,KAAX,EAAD,CAAnB;AACD;AACF;;AAED,WAAOH,UAAP;AACD,GA9Dc;;AAgEf;;;;;;AAMAI,EAAAA,UAAU,EAAE,SAASA,UAAT,GAAsB;AAChC9B,IAAAA,YAAY,GAAG,EAAf;AACAC,IAAAA,UAAU,GAAG,EAAb;AACD;AAzEc,CAAjB","sourcesContent":["var AWS = require('../core');\n\n/**\n * @api private\n */\nvar cachedSecret = {};\n\n/**\n * @api private\n */\nvar cacheQueue = [];\n\n/**\n * @api private\n */\nvar maxCacheEntries = 50;\n\n/**\n * @api private\n */\nvar v4Identifier = 'aws4_request';\n\n/**\n * @api private\n */\nmodule.exports = {\n  /**\n   * @api private\n   *\n   * @param date [String]\n   * @param region [String]\n   * @param serviceName [String]\n   * @return [String]\n   */\n  createScope: function createScope(date, region, serviceName) {\n    return [\n      date.substr(0, 8),\n      region,\n      serviceName,\n      v4Identifier\n    ].join('/');\n  },\n\n  /**\n   * @api private\n   *\n   * @param credentials [Credentials]\n   * @param date [String]\n   * @param region [String]\n   * @param service [String]\n   * @param shouldCache [Boolean]\n   * @return [String]\n   */\n  getSigningKey: function getSigningKey(\n    credentials,\n    date,\n    region,\n    service,\n    shouldCache\n  ) {\n    var credsIdentifier = AWS.util.crypto\n      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');\n    var cacheKey = [credsIdentifier, date, region, service].join('_');\n    shouldCache = shouldCache !== false;\n    if (shouldCache && (cacheKey in cachedSecret)) {\n      return cachedSecret[cacheKey];\n    }\n\n    var kDate = AWS.util.crypto.hmac(\n      'AWS4' + credentials.secretAccessKey,\n      date,\n      'buffer'\n    );\n    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');\n    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');\n\n    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');\n    if (shouldCache) {\n      cachedSecret[cacheKey] = signingKey;\n      cacheQueue.push(cacheKey);\n      if (cacheQueue.length > maxCacheEntries) {\n        // remove the oldest entry (not the least recently used)\n        delete cachedSecret[cacheQueue.shift()];\n      }\n    }\n\n    return signingKey;\n  },\n\n  /**\n   * @api private\n   *\n   * Empties the derived signing key cache. Made available for testing purposes\n   * only.\n   */\n  emptyCache: function emptyCache() {\n    cachedSecret = {};\n    cacheQueue = [];\n  }\n};\n"]},"metadata":{},"sourceType":"script"}