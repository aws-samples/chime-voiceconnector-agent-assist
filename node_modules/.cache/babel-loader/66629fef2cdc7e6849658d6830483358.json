{"ast":null,"code":"var util = require('../util');\n\nvar Shape = require('../model/shape');\n\nfunction DomXmlParser() {}\n\nDomXmlParser.prototype.parse = function (xml, shape) {\n  if (xml.replace(/^\\s+/, '') === '') return {};\n  var result, error;\n\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, 'text/xml');\n      } catch (syntaxError) {\n        throw util.error(new Error('Parse error in document'), {\n          originalError: syntaxError,\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n\n      if (result.documentElement === null) {\n        throw util.error(new Error('Cannot parse empty document.'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n\n      var isError = result.getElementsByTagName('parsererror')[0];\n\n      if (isError && (isError.parentNode === result || isError.parentNode.nodeName === 'body' || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === 'body')) {\n        var errorElement = isError.getElementsByTagName('div')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || 'Parser error in document'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject('Microsoft.XMLDOM');\n      result.async = false;\n\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error('Parse error in document'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n    } else {\n      throw new Error('Cannot load XML parser');\n    }\n  } catch (e) {\n    error = e;\n  }\n\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');\n\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {\n      code: 'XMLParserError',\n      retryable: true\n    });\n  } else {\n    // empty xml document\n    return {};\n  }\n};\n\nfunction getElementByTagName(xml, tag) {\n  var elements = xml.getElementsByTagName(tag);\n\n  for (var i = 0, iLen = elements.length; i < iLen; i++) {\n    if (elements[i].parentNode === xml) {\n      return elements[i];\n    }\n  }\n}\n\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n\n  switch (shape.type) {\n    case 'structure':\n      return parseStructure(xml, shape);\n\n    case 'map':\n      return parseMap(xml, shape);\n\n    case 'list':\n      return parseList(xml, shape);\n\n    case undefined:\n    case null:\n      return parseUnknown(xml);\n\n    default:\n      return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n  util.each(shape.members, function (memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({\n          textContent: value\n        }, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);\n\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (!memberShape.flattened && memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var tagName = shape.flattened ? shape.name : 'entry';\n  var child = xml.firstElementChild;\n\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = getElementByTagName(child, xmlKey).textContent;\n      var value = getElementByTagName(child, xmlValue);\n      data[key] = parseXml(value, shape.value);\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : shape.member.name || 'member';\n  var child = xml.firstElementChild;\n\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return data;\n}\n\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute('encoding');\n\n    if (encoding === 'base64') {\n      shape = new Shape.create({\n        type: encoding\n      });\n    }\n  }\n\n  var text = xml.textContent;\n  if (text === '') text = null;\n\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return ''; // empty object\n\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return '';else return xml.textContent;\n  } // object, parse as structure\n\n\n  var shape = {\n    type: 'structure',\n    members: {}\n  };\n  var child = xml.firstElementChild;\n\n  while (child) {\n    var tag = child.nodeName;\n\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      // multiple tags of the same name makes it a list\n      shape.members[tag].type = 'list';\n    } else {\n      shape.members[tag] = {\n        name: tag\n      };\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return parseStructure(xml, shape);\n}\n/**\n * @api private\n */\n\n\nmodule.exports = DomXmlParser;","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/xml/browser_parser.js"],"names":["util","require","Shape","DomXmlParser","prototype","parse","xml","shape","replace","result","error","window","DOMParser","parser","parseFromString","syntaxError","Error","originalError","code","retryable","documentElement","isError","getElementsByTagName","parentNode","nodeName","errorElement","textContent","ActiveXObject","async","loadXML","e","data","parseXml","metadata","getElementByTagName","ResponseMetadata","tag","elements","i","iLen","length","type","parseStructure","parseMap","parseList","undefined","parseUnknown","parseScalar","each","members","memberName","memberShape","isXmlAttribute","Object","hasOwnProperty","call","attributes","name","value","xmlChild","flattened","api","xmlNoDefaultLists","defaultValue","xmlKey","key","xmlValue","tagName","child","firstElementChild","nextElementSibling","member","push","getAttribute","encoding","create","text","toType","childNodes","module","exports"],"mappings":"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","sourcesContent":["var util = require('../util');\nvar Shape = require('../model/shape');\n\nfunction DomXmlParser() { }\n\nDomXmlParser.prototype.parse = function(xml, shape) {\n  if (xml.replace(/^\\s+/, '') === '') return {};\n\n  var result, error;\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, 'text/xml');\n      } catch (syntaxError) {\n        throw util.error(new Error('Parse error in document'),\n          {\n            originalError: syntaxError,\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n\n      if (result.documentElement === null) {\n        throw util.error(new Error('Cannot parse empty document.'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n\n      var isError = result.getElementsByTagName('parsererror')[0];\n      if (isError && (isError.parentNode === result ||\n          isError.parentNode.nodeName === 'body' ||\n          isError.parentNode.parentNode === result ||\n          isError.parentNode.parentNode.nodeName === 'body')) {\n        var errorElement = isError.getElementsByTagName('div')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject('Microsoft.XMLDOM');\n      result.async = false;\n\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error('Parse error in document'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n    } else {\n      throw new Error('Cannot load XML parser');\n    }\n  } catch (e) {\n    error = e;\n  }\n\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});\n  } else { // empty xml document\n    return {};\n  }\n};\n\nfunction getElementByTagName(xml, tag) {\n  var elements = xml.getElementsByTagName(tag);\n  for (var i = 0, iLen = elements.length; i < iLen; i++) {\n    if (elements[i].parentNode === xml) {\n      return elements[i];\n    }\n  }\n}\n\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n  switch (shape.type) {\n    case 'structure': return parseStructure(xml, shape);\n    case 'map': return parseMap(xml, shape);\n    case 'list': return parseList(xml, shape);\n    case undefined: case null: return parseUnknown(xml);\n    default: return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  util.each(shape.members, function(memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({textContent: value}, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml :\n        getElementByTagName(xml, memberShape.name);\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (\n        !memberShape.flattened &&\n        memberShape.type === 'list' &&\n        !shape.api.xmlNoDefaultLists) {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var tagName = shape.flattened ? shape.name : 'entry';\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = getElementByTagName(child, xmlKey).textContent;\n      var value = getElementByTagName(child, xmlValue);\n      data[key] = parseXml(value, shape.value);\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute('encoding');\n    if (encoding === 'base64') {\n      shape = new Shape.create({type: encoding});\n    }\n  }\n\n  var text = xml.textContent;\n  if (text === '') text = null;\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n\n  // empty object\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return '';\n    else return xml.textContent;\n  }\n\n  // object, parse as structure\n  var shape = {type: 'structure', members: {}};\n  var child = xml.firstElementChild;\n  while (child) {\n    var tag = child.nodeName;\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      // multiple tags of the same name makes it a list\n      shape.members[tag].type = 'list';\n    } else {\n      shape.members[tag] = {name: tag};\n    }\n    child = child.nextElementSibling;\n  }\n  return parseStructure(xml, shape);\n}\n\n/**\n * @api private\n */\nmodule.exports = DomXmlParser;\n"]},"metadata":{},"sourceType":"script"}