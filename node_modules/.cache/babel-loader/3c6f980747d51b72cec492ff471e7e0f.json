{"ast":null,"code":"var Int64 = require('./int64').Int64;\n\nvar splitMessage = require('./split-message').splitMessage;\n\nvar BOOLEAN_TAG = 'boolean';\nvar BYTE_TAG = 'byte';\nvar SHORT_TAG = 'short';\nvar INT_TAG = 'integer';\nvar LONG_TAG = 'long';\nvar BINARY_TAG = 'binary';\nvar STRING_TAG = 'string';\nvar TIMESTAMP_TAG = 'timestamp';\nvar UUID_TAG = 'uuid';\n/**\n * @api private\n *\n * @param {Buffer} headers\n */\n\nfunction parseHeaders(headers) {\n  var out = {};\n  var position = 0;\n\n  while (position < headers.length) {\n    var nameLength = headers.readUInt8(position++);\n    var name = headers.slice(position, position + nameLength).toString();\n    position += nameLength;\n\n    switch (headers.readUInt8(position++)) {\n      case 0\n      /* boolTrue */\n      :\n        out[name] = {\n          type: BOOLEAN_TAG,\n          value: true\n        };\n        break;\n\n      case 1\n      /* boolFalse */\n      :\n        out[name] = {\n          type: BOOLEAN_TAG,\n          value: false\n        };\n        break;\n\n      case 2\n      /* byte */\n      :\n        out[name] = {\n          type: BYTE_TAG,\n          value: headers.readInt8(position++)\n        };\n        break;\n\n      case 3\n      /* short */\n      :\n        out[name] = {\n          type: SHORT_TAG,\n          value: headers.readInt16BE(position)\n        };\n        position += 2;\n        break;\n\n      case 4\n      /* integer */\n      :\n        out[name] = {\n          type: INT_TAG,\n          value: headers.readInt32BE(position)\n        };\n        position += 4;\n        break;\n\n      case 5\n      /* long */\n      :\n        out[name] = {\n          type: LONG_TAG,\n          value: new Int64(headers.slice(position, position + 8))\n        };\n        position += 8;\n        break;\n\n      case 6\n      /* byteArray */\n      :\n        var binaryLength = headers.readUInt16BE(position);\n        position += 2;\n        out[name] = {\n          type: BINARY_TAG,\n          value: headers.slice(position, position + binaryLength)\n        };\n        position += binaryLength;\n        break;\n\n      case 7\n      /* string */\n      :\n        var stringLength = headers.readUInt16BE(position);\n        position += 2;\n        out[name] = {\n          type: STRING_TAG,\n          value: headers.slice(position, position + stringLength).toString()\n        };\n        position += stringLength;\n        break;\n\n      case 8\n      /* timestamp */\n      :\n        out[name] = {\n          type: TIMESTAMP_TAG,\n          value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())\n        };\n        position += 8;\n        break;\n\n      case 9\n      /* uuid */\n      :\n        var uuidChars = headers.slice(position, position + 16).toString('hex');\n        position += 16;\n        out[name] = {\n          type: UUID_TAG,\n          value: uuidChars.substr(0, 8) + '-' + uuidChars.substr(8, 4) + '-' + uuidChars.substr(12, 4) + '-' + uuidChars.substr(16, 4) + '-' + uuidChars.substr(20)\n        };\n        break;\n\n      default:\n        throw new Error('Unrecognized header type tag');\n    }\n  }\n\n  return out;\n}\n\nfunction parseMessage(message) {\n  var parsed = splitMessage(message);\n  return {\n    headers: parseHeaders(parsed.headers),\n    body: parsed.body\n  };\n}\n/**\n * @api private\n */\n\n\nmodule.exports = {\n  parseMessage: parseMessage\n};","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/event-stream/parse-message.js"],"names":["Int64","require","splitMessage","BOOLEAN_TAG","BYTE_TAG","SHORT_TAG","INT_TAG","LONG_TAG","BINARY_TAG","STRING_TAG","TIMESTAMP_TAG","UUID_TAG","parseHeaders","headers","out","position","length","nameLength","readUInt8","name","slice","toString","type","value","readInt8","readInt16BE","readInt32BE","binaryLength","readUInt16BE","stringLength","Date","valueOf","uuidChars","substr","Error","parseMessage","message","parsed","body","module","exports"],"mappings":"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","sourcesContent":["var Int64 = require('./int64').Int64;\n\nvar splitMessage = require('./split-message').splitMessage;\n\nvar BOOLEAN_TAG = 'boolean';\nvar BYTE_TAG = 'byte';\nvar SHORT_TAG = 'short';\nvar INT_TAG = 'integer';\nvar LONG_TAG = 'long';\nvar BINARY_TAG = 'binary';\nvar STRING_TAG = 'string';\nvar TIMESTAMP_TAG = 'timestamp';\nvar UUID_TAG = 'uuid';\n\n/**\n * @api private\n *\n * @param {Buffer} headers\n */\nfunction parseHeaders(headers) {\n    var out = {};\n    var position = 0;\n    while (position < headers.length) {\n        var nameLength = headers.readUInt8(position++);\n        var name = headers.slice(position, position + nameLength).toString();\n        position += nameLength;\n        switch (headers.readUInt8(position++)) {\n            case 0 /* boolTrue */:\n                out[name] = {\n                    type: BOOLEAN_TAG,\n                    value: true\n                };\n                break;\n            case 1 /* boolFalse */:\n                out[name] = {\n                    type: BOOLEAN_TAG,\n                    value: false\n                };\n                break;\n            case 2 /* byte */:\n                out[name] = {\n                    type: BYTE_TAG,\n                    value: headers.readInt8(position++)\n                };\n                break;\n            case 3 /* short */:\n                out[name] = {\n                    type: SHORT_TAG,\n                    value: headers.readInt16BE(position)\n                };\n                position += 2;\n                break;\n            case 4 /* integer */:\n                out[name] = {\n                    type: INT_TAG,\n                    value: headers.readInt32BE(position)\n                };\n                position += 4;\n                break;\n            case 5 /* long */:\n                out[name] = {\n                    type: LONG_TAG,\n                    value: new Int64(headers.slice(position, position + 8))\n                };\n                position += 8;\n                break;\n            case 6 /* byteArray */:\n                var binaryLength = headers.readUInt16BE(position);\n                position += 2;\n                out[name] = {\n                    type: BINARY_TAG,\n                    value: headers.slice(position, position + binaryLength)\n                };\n                position += binaryLength;\n                break;\n            case 7 /* string */:\n                var stringLength = headers.readUInt16BE(position);\n                position += 2;\n                out[name] = {\n                    type: STRING_TAG,\n                    value: headers.slice(\n                        position,\n                        position + stringLength\n                    ).toString()\n                };\n                position += stringLength;\n                break;\n            case 8 /* timestamp */:\n                out[name] = {\n                    type: TIMESTAMP_TAG,\n                    value: new Date(\n                        new Int64(headers.slice(position, position + 8))\n                            .valueOf()\n                    )\n                };\n                position += 8;\n                break;\n            case 9 /* uuid */:\n                var uuidChars = headers.slice(position, position + 16)\n                    .toString('hex');\n                position += 16;\n                out[name] = {\n                    type: UUID_TAG,\n                    value: uuidChars.substr(0, 8) + '-' +\n                        uuidChars.substr(8, 4) + '-' +\n                        uuidChars.substr(12, 4) + '-' +\n                        uuidChars.substr(16, 4) + '-' +\n                        uuidChars.substr(20)\n                };\n                break;\n            default:\n                throw new Error('Unrecognized header type tag');\n        }\n    }\n    return out;\n}\n\nfunction parseMessage(message) {\n    var parsed = splitMessage(message);\n    return { headers: parseHeaders(parsed.headers), body: parsed.body };\n}\n\n/**\n * @api private\n */\nmodule.exports = {\n    parseMessage: parseMessage\n};\n"]},"metadata":{},"sourceType":"script"}