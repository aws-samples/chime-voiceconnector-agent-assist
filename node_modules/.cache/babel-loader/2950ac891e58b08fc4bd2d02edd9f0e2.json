{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isInputType, isOutputType, isRequiredArgument } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport inspect from '../jsutils/inspect';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, \"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value; // Ensure all directives are in fact GraphQL directives.\n\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value; // Ensure all provided types are in fact GraphQL type.\n\n      if (!isNamedType(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n\n      if (!isIntrospectionType(type)) {\n        validateName(context, type);\n      }\n\n      if (isObjectType(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if (isInterfaceType(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if (isUnionType(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if (isEnumType(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if (isInputObjectType(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value; // Ensure they are named correctly.\n\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n\n      if (!isOutputType(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = find(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!isEqualType(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n\n      };\n\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = find(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && isRequiredArgument(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n\n      validateName(context, enumValue);\n\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value; // Ensure they are named correctly.\n\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!isInputType(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n\n      if (astNode) {\n        var subNodes = getter(astNode);\n\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/type/validate.mjs"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isInputType","isOutputType","isRequiredArgument","isDirective","isIntrospectionType","isSchema","inspect","find","invariant","objectValues","GraphQLError","isValidNameError","isEqualType","isTypeSubTypeOf","validateSchema","schema","concat","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","getOperationTypeNode","mutationType","getMutationType","subscriptionType","getSubscriptionType","type","operation","operationNodes","getAllSubNodes","node","operationTypes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getDirectives","_step2","directive","validateName","argNames","create","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","args","_step3","arg","argName","name","getAllDirectiveArgNodes","getDirectiveArgTypeNode","__allowedLegacyNames","indexOf","typeMap","getTypeMap","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","validateFields","validateObjectInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","field","fieldNodes","getAllFieldNodes","getFieldTypeNode","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","getAllFieldArgNodes","getFieldArgTypeNode","object","implementedTypeNames","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","getInterfaces","_step7","iface","getImplementsInterfaceNode","getAllImplementsInterfaceNodes","validateObjectImplementsInterface","objectFieldMap","ifaceFieldMap","_arr","keys","_i","fieldName","objectField","ifaceField","getFieldNode","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_loop","ifaceArg","_step8","objectArg","getFieldArgNode","_iterator8","_ret","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_loop2","_step9","_iterator9","union","memberTypes","getTypes","includedTypeNames","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_iterator11","_step11","enumValue","valueName","allNodes","getEnumValueNodes","inputObj","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","extensionASTNodes","getter","result","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","_step13","subNodes","typeNode","interfaces","ifaceNode","fieldNode","argNodes","arguments","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","fieldArgNode","directiveNode","argNode","typeName","unionNode","types","enumNode","values","valueNode"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isInputType, isOutputType, isRequiredArgument } from './definition';\nimport { isDirective } from './directives';\nimport { isIntrospectionType } from './introspection';\nimport { isSchema } from './schema';\nimport inspect from '../jsutils/inspect';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { isValidNameError } from '../utilities/assertValidName';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !isSchema(schema) ? invariant(0, \"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext =\n/*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value;\n\n      // Ensure all directives are in fact GraphQL directives.\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = isValidNameError(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value;\n\n      // Ensure all provided types are in fact GraphQL type.\n      if (!isNamedType(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n\n      if (!isIntrospectionType(type)) {\n        validateName(context, type);\n      }\n\n      if (isObjectType(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if (isInterfaceType(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if (isUnionType(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if (isEnumType(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if (isInputObjectType(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n\n      if (!isOutputType(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(object), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = find(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!isEqualType(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n\n      };\n\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = find(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && isRequiredArgument(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n\n      validateName(context, enumValue);\n\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!isInputType(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n\n      if (astNode) {\n        var subNodes = getter(astNode);\n\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}"]},"metadata":{},"sourceType":"module"}