{"ast":null,"code":"(function (exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    } // Check if they are the same type.\n\n\n    var firstType = Object.prototype.toString.call(first);\n\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    } // We know that first and second have the same type so we can just check the\n    // first type from now on.\n\n\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n\n          keysSeen[key] = true;\n        }\n      } // Now check that there aren't any keys in second that weren't\n      // in first.\n\n\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n      return true;\n    } else if (isArray(obj) && obj.length === 0) {\n      // Check for an empty array.\n      return true;\n    } else if (isObject(obj)) {\n      // Check for an empty object.\n      for (var key in obj) {\n        // If there are any keys, then\n        // the object is not empty so the object\n        // is not false.\n        if (obj.hasOwnProperty(key)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n\n    return values;\n  }\n\n  function merge(a, b) {\n    var merged = {};\n\n    for (var key in a) {\n      merged[key] = a[key];\n    }\n\n    for (var key2 in b) {\n      merged[key2] = b[key2];\n    }\n\n    return merged;\n  }\n\n  var trimLeft;\n\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function trimLeft(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function trimLeft(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  } // Type constants used to define functions.\n\n\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN = \"Lparen\";\n  var TOK_LITERAL = \"Literal\"; // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n  var operatorStartToken = {\n    \"<\": true,\n    \">\": true,\n    \"=\": true,\n    \"!\": true\n  };\n  var skipChars = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\n\": true\n  };\n\n  function isAlpha(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch === \"_\";\n  }\n\n  function isNum(ch) {\n    return ch >= \"0\" && ch <= \"9\" || ch === \"-\";\n  }\n\n  function isAlphaNum(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch >= \"0\" && ch <= \"9\" || ch === \"_\";\n  }\n\n  function Lexer() {}\n\n  Lexer.prototype = {\n    tokenize: function tokenize(stream) {\n      var tokens = [];\n      this._current = 0;\n      var start;\n      var identifier;\n      var token;\n\n      while (this._current < stream.length) {\n        if (isAlpha(stream[this._current])) {\n          start = this._current;\n          identifier = this._consumeUnquotedIdentifier(stream);\n          tokens.push({\n            type: TOK_UNQUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (basicTokens[stream[this._current]] !== undefined) {\n          tokens.push({\n            type: basicTokens[stream[this._current]],\n            value: stream[this._current],\n            start: this._current\n          });\n          this._current++;\n        } else if (isNum(stream[this._current])) {\n          token = this._consumeNumber(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"[\") {\n          // No need to increment this._current.  This happens\n          // in _consumeLBracket\n          token = this._consumeLBracket(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"\\\"\") {\n          start = this._current;\n          identifier = this._consumeQuotedIdentifier(stream);\n          tokens.push({\n            type: TOK_QUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"'\") {\n          start = this._current;\n          identifier = this._consumeRawStringLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"`\") {\n          start = this._current;\n\n          var literal = this._consumeLiteral(stream);\n\n          tokens.push({\n            type: TOK_LITERAL,\n            value: literal,\n            start: start\n          });\n        } else if (operatorStartToken[stream[this._current]] !== undefined) {\n          tokens.push(this._consumeOperator(stream));\n        } else if (skipChars[stream[this._current]] !== undefined) {\n          // Ignore whitespace.\n          this._current++;\n        } else if (stream[this._current] === \"&\") {\n          start = this._current;\n          this._current++;\n\n          if (stream[this._current] === \"&\") {\n            this._current++;\n            tokens.push({\n              type: TOK_AND,\n              value: \"&&\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_EXPREF,\n              value: \"&\",\n              start: start\n            });\n          }\n        } else if (stream[this._current] === \"|\") {\n          start = this._current;\n          this._current++;\n\n          if (stream[this._current] === \"|\") {\n            this._current++;\n            tokens.push({\n              type: TOK_OR,\n              value: \"||\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_PIPE,\n              value: \"|\",\n              start: start\n            });\n          }\n        } else {\n          var error = new Error(\"Unknown character:\" + stream[this._current]);\n          error.name = \"LexerError\";\n          throw error;\n        }\n      }\n\n      return tokens;\n    },\n    _consumeUnquotedIdentifier: function _consumeUnquotedIdentifier(stream) {\n      var start = this._current;\n      this._current++;\n\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n        this._current++;\n      }\n\n      return stream.slice(start, this._current);\n    },\n    _consumeQuotedIdentifier: function _consumeQuotedIdentifier(stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n\n      while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n        // You can escape a double quote and you can escape an escape.\n        var current = this._current;\n\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"\\\"\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n\n        this._current = current;\n      }\n\n      this._current++;\n      return JSON.parse(stream.slice(start, this._current));\n    },\n    _consumeRawStringLiteral: function _consumeRawStringLiteral(stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n\n      while (stream[this._current] !== \"'\" && this._current < maxLength) {\n        // You can escape a single quote and you can escape an escape.\n        var current = this._current;\n\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"'\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n\n        this._current = current;\n      }\n\n      this._current++;\n      var literal = stream.slice(start + 1, this._current - 1);\n      return literal.replace(\"\\\\'\", \"'\");\n    },\n    _consumeNumber: function _consumeNumber(stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n\n      while (isNum(stream[this._current]) && this._current < maxLength) {\n        this._current++;\n      }\n\n      var value = parseInt(stream.slice(start, this._current));\n      return {\n        type: TOK_NUMBER,\n        value: value,\n        start: start\n      };\n    },\n    _consumeLBracket: function _consumeLBracket(stream) {\n      var start = this._current;\n      this._current++;\n\n      if (stream[this._current] === \"?\") {\n        this._current++;\n        return {\n          type: TOK_FILTER,\n          value: \"[?\",\n          start: start\n        };\n      } else if (stream[this._current] === \"]\") {\n        this._current++;\n        return {\n          type: TOK_FLATTEN,\n          value: \"[]\",\n          start: start\n        };\n      } else {\n        return {\n          type: TOK_LBRACKET,\n          value: \"[\",\n          start: start\n        };\n      }\n    },\n    _consumeOperator: function _consumeOperator(stream) {\n      var start = this._current;\n      var startingChar = stream[start];\n      this._current++;\n\n      if (startingChar === \"!\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_NE,\n            value: \"!=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_NOT,\n            value: \"!\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"<\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_LTE,\n            value: \"<=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_LT,\n            value: \"<\",\n            start: start\n          };\n        }\n      } else if (startingChar === \">\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_GTE,\n            value: \">=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_GT,\n            value: \">\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"=\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_EQ,\n            value: \"==\",\n            start: start\n          };\n        }\n      }\n    },\n    _consumeLiteral: function _consumeLiteral(stream) {\n      this._current++;\n      var start = this._current;\n      var maxLength = stream.length;\n      var literal;\n\n      while (stream[this._current] !== \"`\" && this._current < maxLength) {\n        // You can escape a literal char or you can escape the escape.\n        var current = this._current;\n\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"`\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n\n        this._current = current;\n      }\n\n      var literalString = trimLeft(stream.slice(start, this._current));\n      literalString = literalString.replace(\"\\\\`\", \"`\");\n\n      if (this._looksLikeJSON(literalString)) {\n        literal = JSON.parse(literalString);\n      } else {\n        // Try to JSON parse it as \"<literal>\"\n        literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n      } // +1 gets us to the ending \"`\", +1 to move on to the next char.\n\n\n      this._current++;\n      return literal;\n    },\n    _looksLikeJSON: function _looksLikeJSON(literalString) {\n      var startingChars = \"[{\\\"\";\n      var jsonLiterals = [\"true\", \"false\", \"null\"];\n      var numberLooking = \"-0123456789\";\n\n      if (literalString === \"\") {\n        return false;\n      } else if (startingChars.indexOf(literalString[0]) >= 0) {\n        return true;\n      } else if (jsonLiterals.indexOf(literalString) >= 0) {\n        return true;\n      } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n        try {\n          JSON.parse(literalString);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  };\n  var bindingPower = {};\n  bindingPower[TOK_EOF] = 0;\n  bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_RBRACKET] = 0;\n  bindingPower[TOK_RPAREN] = 0;\n  bindingPower[TOK_COMMA] = 0;\n  bindingPower[TOK_RBRACE] = 0;\n  bindingPower[TOK_NUMBER] = 0;\n  bindingPower[TOK_CURRENT] = 0;\n  bindingPower[TOK_EXPREF] = 0;\n  bindingPower[TOK_PIPE] = 1;\n  bindingPower[TOK_OR] = 2;\n  bindingPower[TOK_AND] = 3;\n  bindingPower[TOK_EQ] = 5;\n  bindingPower[TOK_GT] = 5;\n  bindingPower[TOK_LT] = 5;\n  bindingPower[TOK_GTE] = 5;\n  bindingPower[TOK_LTE] = 5;\n  bindingPower[TOK_NE] = 5;\n  bindingPower[TOK_FLATTEN] = 9;\n  bindingPower[TOK_STAR] = 20;\n  bindingPower[TOK_FILTER] = 21;\n  bindingPower[TOK_DOT] = 40;\n  bindingPower[TOK_NOT] = 45;\n  bindingPower[TOK_LBRACE] = 50;\n  bindingPower[TOK_LBRACKET] = 55;\n  bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {}\n\n  Parser.prototype = {\n    parse: function parse(expression) {\n      this._loadTokens(expression);\n\n      this.index = 0;\n      var ast = this.expression(0);\n\n      if (this._lookahead(0) !== TOK_EOF) {\n        var t = this._lookaheadToken(0);\n\n        var error = new Error(\"Unexpected token type: \" + t.type + \", value: \" + t.value);\n        error.name = \"ParserError\";\n        throw error;\n      }\n\n      return ast;\n    },\n    _loadTokens: function _loadTokens(expression) {\n      var lexer = new Lexer();\n      var tokens = lexer.tokenize(expression);\n      tokens.push({\n        type: TOK_EOF,\n        value: \"\",\n        start: expression.length\n      });\n      this.tokens = tokens;\n    },\n    expression: function expression(rbp) {\n      var leftToken = this._lookaheadToken(0);\n\n      this._advance();\n\n      var left = this.nud(leftToken);\n\n      var currentToken = this._lookahead(0);\n\n      while (rbp < bindingPower[currentToken]) {\n        this._advance();\n\n        left = this.led(currentToken, left);\n        currentToken = this._lookahead(0);\n      }\n\n      return left;\n    },\n    _lookahead: function _lookahead(number) {\n      return this.tokens[this.index + number].type;\n    },\n    _lookaheadToken: function _lookaheadToken(number) {\n      return this.tokens[this.index + number];\n    },\n    _advance: function _advance() {\n      this.index++;\n    },\n    nud: function nud(token) {\n      var left;\n      var right;\n      var expression;\n\n      switch (token.type) {\n        case TOK_LITERAL:\n          return {\n            type: \"Literal\",\n            value: token.value\n          };\n\n        case TOK_UNQUOTEDIDENTIFIER:\n          return {\n            type: \"Field\",\n            name: token.value\n          };\n\n        case TOK_QUOTEDIDENTIFIER:\n          var node = {\n            type: \"Field\",\n            name: token.value\n          };\n\n          if (this._lookahead(0) === TOK_LPAREN) {\n            throw new Error(\"Quoted identifier not allowed for function names.\");\n          } else {\n            return node;\n          }\n\n          break;\n\n        case TOK_NOT:\n          right = this.expression(bindingPower.Not);\n          return {\n            type: \"NotExpression\",\n            children: [right]\n          };\n\n        case TOK_STAR:\n          left = {\n            type: \"Identity\"\n          };\n          right = null;\n\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            // This can happen in a multiselect,\n            // [a, b, *]\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Star);\n          }\n\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n\n        case TOK_FILTER:\n          return this.led(token.type, {\n            type: \"Identity\"\n          });\n\n        case TOK_LBRACE:\n          return this._parseMultiselectHash();\n\n        case TOK_FLATTEN:\n          left = {\n            type: TOK_FLATTEN,\n            children: [{\n              type: \"Identity\"\n            }]\n          };\n          right = this._parseProjectionRHS(bindingPower.Flatten);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n\n        case TOK_LBRACKET:\n          if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice({\n              type: \"Identity\"\n            }, right);\n          } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n            this._advance();\n\n            this._advance();\n\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: \"Projection\",\n              children: [{\n                type: \"Identity\"\n              }, right]\n            };\n          } else {\n            return this._parseMultiselectList();\n          }\n\n          break;\n\n        case TOK_CURRENT:\n          return {\n            type: TOK_CURRENT\n          };\n\n        case TOK_EXPREF:\n          expression = this.expression(bindingPower.Expref);\n          return {\n            type: \"ExpressionReference\",\n            children: [expression]\n          };\n\n        case TOK_LPAREN:\n          var args = [];\n\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n\n            args.push(expression);\n          }\n\n          this._match(TOK_RPAREN);\n\n          return args[0];\n\n        default:\n          this._errorToken(token);\n\n      }\n    },\n    led: function led(tokenName, left) {\n      var right;\n\n      switch (tokenName) {\n        case TOK_DOT:\n          var rbp = bindingPower.Dot;\n\n          if (this._lookahead(0) !== TOK_STAR) {\n            right = this._parseDotRHS(rbp);\n            return {\n              type: \"Subexpression\",\n              children: [left, right]\n            };\n          } else {\n            // Creating a projection.\n            this._advance();\n\n            right = this._parseProjectionRHS(rbp);\n            return {\n              type: \"ValueProjection\",\n              children: [left, right]\n            };\n          }\n\n          break;\n\n        case TOK_PIPE:\n          right = this.expression(bindingPower.Pipe);\n          return {\n            type: TOK_PIPE,\n            children: [left, right]\n          };\n\n        case TOK_OR:\n          right = this.expression(bindingPower.Or);\n          return {\n            type: \"OrExpression\",\n            children: [left, right]\n          };\n\n        case TOK_AND:\n          right = this.expression(bindingPower.And);\n          return {\n            type: \"AndExpression\",\n            children: [left, right]\n          };\n\n        case TOK_LPAREN:\n          var name = left.name;\n          var args = [];\n          var expression, node;\n\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            }\n\n            args.push(expression);\n          }\n\n          this._match(TOK_RPAREN);\n\n          node = {\n            type: \"Function\",\n            name: name,\n            children: args\n          };\n          return node;\n\n        case TOK_FILTER:\n          var condition = this.expression(0);\n\n          this._match(TOK_RBRACKET);\n\n          if (this._lookahead(0) === TOK_FLATTEN) {\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Filter);\n          }\n\n          return {\n            type: \"FilterProjection\",\n            children: [left, right, condition]\n          };\n\n        case TOK_FLATTEN:\n          var leftNode = {\n            type: TOK_FLATTEN,\n            children: [left]\n          };\n\n          var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n\n          return {\n            type: \"Projection\",\n            children: [leftNode, rightNode]\n          };\n\n        case TOK_EQ:\n        case TOK_NE:\n        case TOK_GT:\n        case TOK_GTE:\n        case TOK_LT:\n        case TOK_LTE:\n          return this._parseComparator(left, tokenName);\n\n        case TOK_LBRACKET:\n          var token = this._lookaheadToken(0);\n\n          if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice(left, right);\n          } else {\n            this._match(TOK_STAR);\n\n            this._match(TOK_RBRACKET);\n\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: \"Projection\",\n              children: [left, right]\n            };\n          }\n\n          break;\n\n        default:\n          this._errorToken(this._lookaheadToken(0));\n\n      }\n    },\n    _match: function _match(tokenType) {\n      if (this._lookahead(0) === tokenType) {\n        this._advance();\n      } else {\n        var t = this._lookaheadToken(0);\n\n        var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n        error.name = \"ParserError\";\n        throw error;\n      }\n    },\n    _errorToken: function _errorToken(token) {\n      var error = new Error(\"Invalid token (\" + token.type + \"): \\\"\" + token.value + \"\\\"\");\n      error.name = \"ParserError\";\n      throw error;\n    },\n    _parseIndexExpression: function _parseIndexExpression() {\n      if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n        return this._parseSliceExpression();\n      } else {\n        var node = {\n          type: \"Index\",\n          value: this._lookaheadToken(0).value\n        };\n\n        this._advance();\n\n        this._match(TOK_RBRACKET);\n\n        return node;\n      }\n    },\n    _projectIfSlice: function _projectIfSlice(left, right) {\n      var indexExpr = {\n        type: \"IndexExpression\",\n        children: [left, right]\n      };\n\n      if (right.type === \"Slice\") {\n        return {\n          type: \"Projection\",\n          children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n        };\n      } else {\n        return indexExpr;\n      }\n    },\n    _parseSliceExpression: function _parseSliceExpression() {\n      // [start:end:step] where each part is optional, as well as the last\n      // colon.\n      var parts = [null, null, null];\n      var index = 0;\n\n      var currentToken = this._lookahead(0);\n\n      while (currentToken !== TOK_RBRACKET && index < 3) {\n        if (currentToken === TOK_COLON) {\n          index++;\n\n          this._advance();\n        } else if (currentToken === TOK_NUMBER) {\n          parts[index] = this._lookaheadToken(0).value;\n\n          this._advance();\n        } else {\n          var t = this._lookahead(0);\n\n          var error = new Error(\"Syntax error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n          error.name = \"Parsererror\";\n          throw error;\n        }\n\n        currentToken = this._lookahead(0);\n      }\n\n      this._match(TOK_RBRACKET);\n\n      return {\n        type: \"Slice\",\n        children: parts\n      };\n    },\n    _parseComparator: function _parseComparator(left, comparator) {\n      var right = this.expression(bindingPower[comparator]);\n      return {\n        type: \"Comparator\",\n        name: comparator,\n        children: [left, right]\n      };\n    },\n    _parseDotRHS: function _parseDotRHS(rbp) {\n      var lookahead = this._lookahead(0);\n\n      var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n\n      if (exprTokens.indexOf(lookahead) >= 0) {\n        return this.expression(rbp);\n      } else if (lookahead === TOK_LBRACKET) {\n        this._match(TOK_LBRACKET);\n\n        return this._parseMultiselectList();\n      } else if (lookahead === TOK_LBRACE) {\n        this._match(TOK_LBRACE);\n\n        return this._parseMultiselectHash();\n      }\n    },\n    _parseProjectionRHS: function _parseProjectionRHS(rbp) {\n      var right;\n\n      if (bindingPower[this._lookahead(0)] < 10) {\n        right = {\n          type: \"Identity\"\n        };\n      } else if (this._lookahead(0) === TOK_LBRACKET) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_FILTER) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_DOT) {\n        this._match(TOK_DOT);\n\n        right = this._parseDotRHS(rbp);\n      } else {\n        var t = this._lookaheadToken(0);\n\n        var error = new Error(\"Sytanx error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n        error.name = \"ParserError\";\n        throw error;\n      }\n\n      return right;\n    },\n    _parseMultiselectList: function _parseMultiselectList() {\n      var expressions = [];\n\n      while (this._lookahead(0) !== TOK_RBRACKET) {\n        var expression = this.expression(0);\n        expressions.push(expression);\n\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            throw new Error(\"Unexpected token Rbracket\");\n          }\n        }\n      }\n\n      this._match(TOK_RBRACKET);\n\n      return {\n        type: \"MultiSelectList\",\n        children: expressions\n      };\n    },\n    _parseMultiselectHash: function _parseMultiselectHash() {\n      var pairs = [];\n      var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n      var keyToken, keyName, value, node;\n\n      for (;;) {\n        keyToken = this._lookaheadToken(0);\n\n        if (identifierTypes.indexOf(keyToken.type) < 0) {\n          throw new Error(\"Expecting an identifier token, got: \" + keyToken.type);\n        }\n\n        keyName = keyToken.value;\n\n        this._advance();\n\n        this._match(TOK_COLON);\n\n        value = this.expression(0);\n        node = {\n          type: \"KeyValuePair\",\n          name: keyName,\n          value: value\n        };\n        pairs.push(node);\n\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n        } else if (this._lookahead(0) === TOK_RBRACE) {\n          this._match(TOK_RBRACE);\n\n          break;\n        }\n      }\n\n      return {\n        type: \"MultiSelectHash\",\n        children: pairs\n      };\n    }\n  };\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n    search: function search(node, value) {\n      return this.visit(node, value);\n    },\n    visit: function visit(node, value) {\n      var matched, current, result, first, second, field, left, right, collected, i;\n\n      switch (node.type) {\n        case \"Field\":\n          if (value === null) {\n            return null;\n          } else if (isObject(value)) {\n            field = value[node.name];\n\n            if (field === undefined) {\n              return null;\n            } else {\n              return field;\n            }\n          } else {\n            return null;\n          }\n\n          break;\n\n        case \"Subexpression\":\n          result = this.visit(node.children[0], value);\n\n          for (i = 1; i < node.children.length; i++) {\n            result = this.visit(node.children[1], result);\n\n            if (result === null) {\n              return null;\n            }\n          }\n\n          return result;\n\n        case \"IndexExpression\":\n          left = this.visit(node.children[0], value);\n          right = this.visit(node.children[1], left);\n          return right;\n\n        case \"Index\":\n          if (!isArray(value)) {\n            return null;\n          }\n\n          var index = node.value;\n\n          if (index < 0) {\n            index = value.length + index;\n          }\n\n          result = value[index];\n\n          if (result === undefined) {\n            result = null;\n          }\n\n          return result;\n\n        case \"Slice\":\n          if (!isArray(value)) {\n            return null;\n          }\n\n          var sliceParams = node.children.slice(0);\n          var computed = this.computeSliceParams(value.length, sliceParams);\n          var start = computed[0];\n          var stop = computed[1];\n          var step = computed[2];\n          result = [];\n\n          if (step > 0) {\n            for (i = start; i < stop; i += step) {\n              result.push(value[i]);\n            }\n          } else {\n            for (i = start; i > stop; i += step) {\n              result.push(value[i]);\n            }\n          }\n\n          return result;\n\n        case \"Projection\":\n          // Evaluate left child.\n          var base = this.visit(node.children[0], value);\n\n          if (!isArray(base)) {\n            return null;\n          }\n\n          collected = [];\n\n          for (i = 0; i < base.length; i++) {\n            current = this.visit(node.children[1], base[i]);\n\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n\n          return collected;\n\n        case \"ValueProjection\":\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n\n          if (!isObject(base)) {\n            return null;\n          }\n\n          collected = [];\n          var values = objValues(base);\n\n          for (i = 0; i < values.length; i++) {\n            current = this.visit(node.children[1], values[i]);\n\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n\n          return collected;\n\n        case \"FilterProjection\":\n          base = this.visit(node.children[0], value);\n\n          if (!isArray(base)) {\n            return null;\n          }\n\n          var filtered = [];\n          var finalResults = [];\n\n          for (i = 0; i < base.length; i++) {\n            matched = this.visit(node.children[2], base[i]);\n\n            if (!isFalse(matched)) {\n              filtered.push(base[i]);\n            }\n          }\n\n          for (var j = 0; j < filtered.length; j++) {\n            current = this.visit(node.children[1], filtered[j]);\n\n            if (current !== null) {\n              finalResults.push(current);\n            }\n          }\n\n          return finalResults;\n\n        case \"Comparator\":\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n\n          switch (node.name) {\n            case TOK_EQ:\n              result = strictDeepEqual(first, second);\n              break;\n\n            case TOK_NE:\n              result = !strictDeepEqual(first, second);\n              break;\n\n            case TOK_GT:\n              result = first > second;\n              break;\n\n            case TOK_GTE:\n              result = first >= second;\n              break;\n\n            case TOK_LT:\n              result = first < second;\n              break;\n\n            case TOK_LTE:\n              result = first <= second;\n              break;\n\n            default:\n              throw new Error(\"Unknown comparator: \" + node.name);\n          }\n\n          return result;\n\n        case TOK_FLATTEN:\n          var original = this.visit(node.children[0], value);\n\n          if (!isArray(original)) {\n            return null;\n          }\n\n          var merged = [];\n\n          for (i = 0; i < original.length; i++) {\n            current = original[i];\n\n            if (isArray(current)) {\n              merged.push.apply(merged, current);\n            } else {\n              merged.push(current);\n            }\n          }\n\n          return merged;\n\n        case \"Identity\":\n          return value;\n\n        case \"MultiSelectList\":\n          if (value === null) {\n            return null;\n          }\n\n          collected = [];\n\n          for (i = 0; i < node.children.length; i++) {\n            collected.push(this.visit(node.children[i], value));\n          }\n\n          return collected;\n\n        case \"MultiSelectHash\":\n          if (value === null) {\n            return null;\n          }\n\n          collected = {};\n          var child;\n\n          for (i = 0; i < node.children.length; i++) {\n            child = node.children[i];\n            collected[child.name] = this.visit(child.value, value);\n          }\n\n          return collected;\n\n        case \"OrExpression\":\n          matched = this.visit(node.children[0], value);\n\n          if (isFalse(matched)) {\n            matched = this.visit(node.children[1], value);\n          }\n\n          return matched;\n\n        case \"AndExpression\":\n          first = this.visit(node.children[0], value);\n\n          if (isFalse(first) === true) {\n            return first;\n          }\n\n          return this.visit(node.children[1], value);\n\n        case \"NotExpression\":\n          first = this.visit(node.children[0], value);\n          return isFalse(first);\n\n        case \"Literal\":\n          return node.value;\n\n        case TOK_PIPE:\n          left = this.visit(node.children[0], value);\n          return this.visit(node.children[1], left);\n\n        case TOK_CURRENT:\n          return value;\n\n        case \"Function\":\n          var resolvedArgs = [];\n\n          for (i = 0; i < node.children.length; i++) {\n            resolvedArgs.push(this.visit(node.children[i], value));\n          }\n\n          return this.runtime.callFunction(node.name, resolvedArgs);\n\n        case \"ExpressionReference\":\n          var refNode = node.children[0]; // Tag the node with a specific attribute so the type\n          // checker verify the type.\n\n          refNode.jmespathType = TOK_EXPREF;\n          return refNode;\n\n        default:\n          throw new Error(\"Unknown node type: \" + node.type);\n      }\n    },\n    computeSliceParams: function computeSliceParams(arrayLength, sliceParams) {\n      var start = sliceParams[0];\n      var stop = sliceParams[1];\n      var step = sliceParams[2];\n      var computed = [null, null, null];\n\n      if (step === null) {\n        step = 1;\n      } else if (step === 0) {\n        var error = new Error(\"Invalid slice, step cannot be 0\");\n        error.name = \"RuntimeError\";\n        throw error;\n      }\n\n      var stepValueNegative = step < 0 ? true : false;\n\n      if (start === null) {\n        start = stepValueNegative ? arrayLength - 1 : 0;\n      } else {\n        start = this.capSliceRange(arrayLength, start, step);\n      }\n\n      if (stop === null) {\n        stop = stepValueNegative ? -1 : arrayLength;\n      } else {\n        stop = this.capSliceRange(arrayLength, stop, step);\n      }\n\n      computed[0] = start;\n      computed[1] = stop;\n      computed[2] = step;\n      return computed;\n    },\n    capSliceRange: function capSliceRange(arrayLength, actualValue, step) {\n      if (actualValue < 0) {\n        actualValue += arrayLength;\n\n        if (actualValue < 0) {\n          actualValue = step < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLength) {\n        actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n      }\n\n      return actualValue;\n    }\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n      // name: [function, <signature>]\n      // The <signature> can be:\n      //\n      // {\n      //   args: [[type1, type2], [type1, type2]],\n      //   variadic: true|false\n      // }\n      //\n      // Each arg in the arg list is a list of valid types\n      // (if the function is overloaded and supports multiple\n      // types.  If the type is \"any\" then no type checking\n      // occurs on the argument.  Variadic is optional\n      // and if not provided is assumed to be false.\n      abs: {\n        _func: this._functionAbs,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      avg: {\n        _func: this._functionAvg,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      ceil: {\n        _func: this._functionCeil,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      contains: {\n        _func: this._functionContains,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }, {\n          types: [TYPE_ANY]\n        }]\n      },\n      \"ends_with\": {\n        _func: this._functionEndsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      floor: {\n        _func: this._functionFloor,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      length: {\n        _func: this._functionLength,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]\n        }]\n      },\n      map: {\n        _func: this._functionMap,\n        _signature: [{\n          types: [TYPE_EXPREF]\n        }, {\n          types: [TYPE_ARRAY]\n        }]\n      },\n      max: {\n        _func: this._functionMax,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"merge\": {\n        _func: this._functionMerge,\n        _signature: [{\n          types: [TYPE_OBJECT],\n          variadic: true\n        }]\n      },\n      \"max_by\": {\n        _func: this._functionMaxBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      sum: {\n        _func: this._functionSum,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"starts_with\": {\n        _func: this._functionStartsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      min: {\n        _func: this._functionMin,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"min_by\": {\n        _func: this._functionMinBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      type: {\n        _func: this._functionType,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      keys: {\n        _func: this._functionKeys,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      values: {\n        _func: this._functionValues,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      sort: {\n        _func: this._functionSort,\n        _signature: [{\n          types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"sort_by\": {\n        _func: this._functionSortBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      join: {\n        _func: this._functionJoin,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_ARRAY_STRING]\n        }]\n      },\n      reverse: {\n        _func: this._functionReverse,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }]\n      },\n      \"to_array\": {\n        _func: this._functionToArray,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_string\": {\n        _func: this._functionToString,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_number\": {\n        _func: this._functionToNumber,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"not_null\": {\n        _func: this._functionNotNull,\n        _signature: [{\n          types: [TYPE_ANY],\n          variadic: true\n        }]\n      }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function callFunction(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n\n      if (functionEntry === undefined) {\n        throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n    _validateArgs: function _validateArgs(name, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      var pluralized;\n\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n          throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes at least\" + signature.length + pluralized + \" but received \" + args.length);\n        }\n      } else if (args.length !== signature.length) {\n        pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n        throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes \" + signature.length + pluralized + \" but received \" + args.length);\n      }\n\n      var currentSpec;\n      var actualType;\n      var typeMatched;\n\n      for (var i = 0; i < signature.length; i++) {\n        typeMatched = false;\n        currentSpec = signature[i].types;\n        actualType = this._getTypeName(args[i]);\n\n        for (var j = 0; j < currentSpec.length; j++) {\n          if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n            typeMatched = true;\n            break;\n          }\n        }\n\n        if (!typeMatched) {\n          throw new Error(\"TypeError: \" + name + \"() \" + \"expected argument \" + (i + 1) + \" to be type \" + currentSpec + \" but received type \" + actualType + \" instead.\");\n        }\n      }\n    },\n    _typeMatches: function _typeMatches(actual, expected, argValue) {\n      if (expected === TYPE_ANY) {\n        return true;\n      }\n\n      if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {\n        // The expected type can either just be array,\n        // or it can require a specific subtype (array of numbers).\n        //\n        // The simplest case is if \"array\" with no subtype is specified.\n        if (expected === TYPE_ARRAY) {\n          return actual === TYPE_ARRAY;\n        } else if (actual === TYPE_ARRAY) {\n          // Otherwise we need to check subtypes.\n          // I think this has potential to be improved.\n          var subtype;\n\n          if (expected === TYPE_ARRAY_NUMBER) {\n            subtype = TYPE_NUMBER;\n          } else if (expected === TYPE_ARRAY_STRING) {\n            subtype = TYPE_STRING;\n          }\n\n          for (var i = 0; i < argValue.length; i++) {\n            if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n      } else {\n        return actual === expected;\n      }\n    },\n    _getTypeName: function _getTypeName(obj) {\n      switch (Object.prototype.toString.call(obj)) {\n        case \"[object String]\":\n          return TYPE_STRING;\n\n        case \"[object Number]\":\n          return TYPE_NUMBER;\n\n        case \"[object Array]\":\n          return TYPE_ARRAY;\n\n        case \"[object Boolean]\":\n          return TYPE_BOOLEAN;\n\n        case \"[object Null]\":\n          return TYPE_NULL;\n\n        case \"[object Object]\":\n          // Check if it's an expref.  If it has, it's been\n          // tagged with a jmespathType attr of 'Expref';\n          if (obj.jmespathType === TOK_EXPREF) {\n            return TYPE_EXPREF;\n          } else {\n            return TYPE_OBJECT;\n          }\n\n      }\n    },\n    _functionStartsWith: function _functionStartsWith(resolvedArgs) {\n      return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n    _functionEndsWith: function _functionEndsWith(resolvedArgs) {\n      var searchStr = resolvedArgs[0];\n      var suffix = resolvedArgs[1];\n      return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n    _functionReverse: function _functionReverse(resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n\n      if (typeName === TYPE_STRING) {\n        var originalStr = resolvedArgs[0];\n        var reversedStr = \"\";\n\n        for (var i = originalStr.length - 1; i >= 0; i--) {\n          reversedStr += originalStr[i];\n        }\n\n        return reversedStr;\n      } else {\n        var reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      }\n    },\n    _functionAbs: function _functionAbs(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n    _functionCeil: function _functionCeil(resolvedArgs) {\n      return Math.ceil(resolvedArgs[0]);\n    },\n    _functionAvg: function _functionAvg(resolvedArgs) {\n      var sum = 0;\n      var inputArray = resolvedArgs[0];\n\n      for (var i = 0; i < inputArray.length; i++) {\n        sum += inputArray[i];\n      }\n\n      return sum / inputArray.length;\n    },\n    _functionContains: function _functionContains(resolvedArgs) {\n      return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n    _functionFloor: function _functionFloor(resolvedArgs) {\n      return Math.floor(resolvedArgs[0]);\n    },\n    _functionLength: function _functionLength(resolvedArgs) {\n      if (!isObject(resolvedArgs[0])) {\n        return resolvedArgs[0].length;\n      } else {\n        // As far as I can tell, there's no way to get the length\n        // of an object without O(n) iteration through the object.\n        return Object.keys(resolvedArgs[0]).length;\n      }\n    },\n    _functionMap: function _functionMap(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n\n      for (var i = 0; i < elements.length; i++) {\n        mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n\n      return mapped;\n    },\n    _functionMerge: function _functionMerge(resolvedArgs) {\n      var merged = {};\n\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n\n      return merged;\n    },\n    _functionMax: function _functionMax(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n\n          for (var i = 1; i < elements.length; i++) {\n            if (maxElement.localeCompare(elements[i]) < 0) {\n              maxElement = elements[i];\n            }\n          }\n\n          return maxElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionMin: function _functionMin(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n\n          for (var i = 1; i < elements.length; i++) {\n            if (elements[i].localeCompare(minElement) < 0) {\n              minElement = elements[i];\n            }\n          }\n\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionSum: function _functionSum(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n\n      return sum;\n    },\n    _functionType: function _functionType(resolvedArgs) {\n      switch (this._getTypeName(resolvedArgs[0])) {\n        case TYPE_NUMBER:\n          return \"number\";\n\n        case TYPE_STRING:\n          return \"string\";\n\n        case TYPE_ARRAY:\n          return \"array\";\n\n        case TYPE_OBJECT:\n          return \"object\";\n\n        case TYPE_BOOLEAN:\n          return \"boolean\";\n\n        case TYPE_EXPREF:\n          return \"expref\";\n\n        case TYPE_NULL:\n          return \"null\";\n      }\n    },\n    _functionKeys: function _functionKeys(resolvedArgs) {\n      return Object.keys(resolvedArgs[0]);\n    },\n    _functionValues: function _functionValues(resolvedArgs) {\n      var obj = resolvedArgs[0];\n      var keys = Object.keys(obj);\n      var values = [];\n\n      for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n      }\n\n      return values;\n    },\n    _functionJoin: function _functionJoin(resolvedArgs) {\n      var joinChar = resolvedArgs[0];\n      var listJoin = resolvedArgs[1];\n      return listJoin.join(joinChar);\n    },\n    _functionToArray: function _functionToArray(resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n        return resolvedArgs[0];\n      } else {\n        return [resolvedArgs[0]];\n      }\n    },\n    _functionToString: function _functionToString(resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n        return resolvedArgs[0];\n      } else {\n        return JSON.stringify(resolvedArgs[0]);\n      }\n    },\n    _functionToNumber: function _functionToNumber(resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n\n      var convertedValue;\n\n      if (typeName === TYPE_NUMBER) {\n        return resolvedArgs[0];\n      } else if (typeName === TYPE_STRING) {\n        convertedValue = +resolvedArgs[0];\n\n        if (!isNaN(convertedValue)) {\n          return convertedValue;\n        }\n      }\n\n      return null;\n    },\n    _functionNotNull: function _functionNotNull(resolvedArgs) {\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n          return resolvedArgs[i];\n        }\n      }\n\n      return null;\n    },\n    _functionSort: function _functionSort(resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n      sortedArray.sort();\n      return sortedArray;\n    },\n    _functionSortBy: function _functionSortBy(resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n\n      if (sortedArray.length === 0) {\n        return sortedArray;\n      }\n\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[1];\n\n      var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));\n\n      if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n        throw new Error(\"TypeError\");\n      }\n\n      var that = this; // In order to get a stable sort out of an unstable\n      // sort algorithm, we decorate/sort/undecorate (DSU)\n      // by creating a new list of [index, element] pairs.\n      // In the cmp function, if the evaluated elements are\n      // equal, then the index will be used as the tiebreaker.\n      // After the decorated list has been sorted, it will be\n      // undecorated to extract the original elements.\n\n      var decorated = [];\n\n      for (var i = 0; i < sortedArray.length; i++) {\n        decorated.push([i, sortedArray[i]]);\n      }\n\n      decorated.sort(function (a, b) {\n        var exprA = interpreter.visit(exprefNode, a[1]);\n        var exprB = interpreter.visit(exprefNode, b[1]);\n\n        if (that._getTypeName(exprA) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprA));\n        } else if (that._getTypeName(exprB) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprB));\n        }\n\n        if (exprA > exprB) {\n          return 1;\n        } else if (exprA < exprB) {\n          return -1;\n        } else {\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        }\n      }); // Undecorate: extract out the original list elements.\n\n      for (var j = 0; j < decorated.length; j++) {\n        sortedArray[j] = decorated[j][1];\n      }\n\n      return sortedArray;\n    },\n    _functionMaxBy: function _functionMaxBy(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n\n      return maxRecord;\n    },\n    _functionMinBy: function _functionMinBy(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n\n      return minRecord;\n    },\n    createKeyFunction: function createKeyFunction(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n\n      var keyFunc = function keyFunc(x) {\n        var current = interpreter.visit(exprefNode, x);\n\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes + \", received \" + that._getTypeName(current);\n\n          throw new Error(msg);\n        }\n\n        return current;\n      };\n\n      return keyFunc;\n    }\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n    var lexer = new Lexer();\n    return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n    var parser = new Parser(); // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/jmespath/jmespath.js"],"names":["exports","isArray","obj","Object","prototype","toString","call","isObject","strictDeepEqual","first","second","firstType","length","i","keysSeen","key","hasOwnProperty","key2","isFalse","objValues","keys","values","push","merge","a","b","merged","trimLeft","String","str","match","TYPE_NUMBER","TYPE_ANY","TYPE_STRING","TYPE_ARRAY","TYPE_OBJECT","TYPE_BOOLEAN","TYPE_EXPREF","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","TOK_EOF","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_RBRACE","TOK_NUMBER","TOK_CURRENT","TOK_EXPREF","TOK_PIPE","TOK_OR","TOK_AND","TOK_EQ","TOK_GT","TOK_LT","TOK_GTE","TOK_LTE","TOK_NE","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_DOT","TOK_NOT","TOK_LBRACE","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","basicTokens","operatorStartToken","skipChars","isAlpha","ch","isNum","isAlphaNum","Lexer","tokenize","stream","tokens","_current","start","identifier","token","_consumeUnquotedIdentifier","type","value","undefined","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","error","Error","name","slice","maxLength","current","JSON","parse","replace","parseInt","startingChar","literalString","_looksLikeJSON","startingChars","jsonLiterals","numberLooking","indexOf","ex","bindingPower","Parser","expression","_loadTokens","index","ast","_lookahead","t","_lookaheadToken","lexer","rbp","leftToken","_advance","left","nud","currentToken","led","number","right","node","Not","children","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseIndexExpression","_projectIfSlice","_parseMultiselectList","Expref","args","_match","_errorToken","tokenName","Dot","_parseDotRHS","Pipe","Or","And","condition","Filter","leftNode","rightNode","_parseComparator","tokenType","_parseSliceExpression","indexExpr","parts","comparator","lookahead","exprTokens","expressions","pairs","identifierTypes","keyToken","keyName","TreeInterpreter","runtime","search","visit","matched","result","field","collected","sliceParams","computed","computeSliceParams","stop","step","base","filtered","finalResults","j","original","apply","child","resolvedArgs","callFunction","refNode","jmespathType","arrayLength","stepValueNegative","capSliceRange","actualValue","Runtime","interpreter","_interpreter","functionTable","abs","_func","_functionAbs","_signature","types","avg","_functionAvg","ceil","_functionCeil","contains","_functionContains","_functionEndsWith","floor","_functionFloor","_functionLength","map","_functionMap","max","_functionMax","_functionMerge","variadic","_functionMaxBy","sum","_functionSum","_functionStartsWith","min","_functionMin","_functionMinBy","_functionType","_functionKeys","_functionValues","sort","_functionSort","_functionSortBy","join","_functionJoin","reverse","_functionReverse","_functionToArray","_functionToString","_functionToNumber","_functionNotNull","functionEntry","_validateArgs","signature","pluralized","currentSpec","actualType","typeMatched","_getTypeName","_typeMatches","actual","expected","argValue","subtype","lastIndexOf","searchStr","suffix","typeName","originalStr","reversedStr","reversedArray","Math","inputArray","mapped","exprefNode","elements","maxElement","localeCompare","minElement","listToSum","joinChar","listJoin","stringify","convertedValue","isNaN","sortedArray","requiredType","that","decorated","exprA","exprB","resolvedArray","keyFunction","createKeyFunction","maxNumber","Infinity","maxRecord","minNumber","minRecord","allowedTypes","keyFunc","x","msg","compile","parser","data","jmespath"],"mappings":"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","sourcesContent":["(function(exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n        return true;\n    } else if (isArray(obj) && obj.length === 0) {\n        // Check for an empty array.\n        return true;\n    } else if (isObject(obj)) {\n        // Check for an empty object.\n        for (var key in obj) {\n            // If there are any keys, then\n            // the object is not empty so the object\n            // is not false.\n            if (obj.hasOwnProperty(key)) {\n              return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function merge(a, b) {\n      var merged = {};\n      for (var key in a) {\n          merged[key] = a[key];\n      }\n      for (var key2 in b) {\n          merged[key2] = b[key2];\n      }\n      return merged;\n  }\n\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  // Type constants used to define functions.\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN= \"Lparen\";\n  var TOK_LITERAL= \"Literal\";\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n\n  var operatorStartToken = {\n      \"<\": true,\n      \">\": true,\n      \"=\": true,\n      \"!\": true\n  };\n\n  var skipChars = {\n      \" \": true,\n      \"\\t\": true,\n      \"\\n\": true\n  };\n\n\n  function isAlpha(ch) {\n      return (ch >= \"a\" && ch <= \"z\") ||\n             (ch >= \"A\" && ch <= \"Z\") ||\n             ch === \"_\";\n  }\n\n  function isNum(ch) {\n      return (ch >= \"0\" && ch <= \"9\") ||\n             ch === \"-\";\n  }\n  function isAlphaNum(ch) {\n      return (ch >= \"a\" && ch <= \"z\") ||\n             (ch >= \"A\" && ch <= \"Z\") ||\n             (ch >= \"0\" && ch <= \"9\") ||\n             ch === \"_\";\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n      tokenize: function(stream) {\n          var tokens = [];\n          this._current = 0;\n          var start;\n          var identifier;\n          var token;\n          while (this._current < stream.length) {\n              if (isAlpha(stream[this._current])) {\n                  start = this._current;\n                  identifier = this._consumeUnquotedIdentifier(stream);\n                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (basicTokens[stream[this._current]] !== undefined) {\n                  tokens.push({type: basicTokens[stream[this._current]],\n                              value: stream[this._current],\n                              start: this._current});\n                  this._current++;\n              } else if (isNum(stream[this._current])) {\n                  token = this._consumeNumber(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === \"[\") {\n                  // No need to increment this._current.  This happens\n                  // in _consumeLBracket\n                  token = this._consumeLBracket(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === \"\\\"\") {\n                  start = this._current;\n                  identifier = this._consumeQuotedIdentifier(stream);\n                  tokens.push({type: TOK_QUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === \"'\") {\n                  start = this._current;\n                  identifier = this._consumeRawStringLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === \"`\") {\n                  start = this._current;\n                  var literal = this._consumeLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: literal,\n                               start: start});\n              } else if (operatorStartToken[stream[this._current]] !== undefined) {\n                  tokens.push(this._consumeOperator(stream));\n              } else if (skipChars[stream[this._current]] !== undefined) {\n                  // Ignore whitespace.\n                  this._current++;\n              } else if (stream[this._current] === \"&\") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === \"&\") {\n                      this._current++;\n                      tokens.push({type: TOK_AND, value: \"&&\", start: start});\n                  } else {\n                      tokens.push({type: TOK_EXPREF, value: \"&\", start: start});\n                  }\n              } else if (stream[this._current] === \"|\") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === \"|\") {\n                      this._current++;\n                      tokens.push({type: TOK_OR, value: \"||\", start: start});\n                  } else {\n                      tokens.push({type: TOK_PIPE, value: \"|\", start: start});\n                  }\n              } else {\n                  var error = new Error(\"Unknown character:\" + stream[this._current]);\n                  error.name = \"LexerError\";\n                  throw error;\n              }\n          }\n          return tokens;\n      },\n\n      _consumeUnquotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n              this._current++;\n          }\n          return stream.slice(start, this._current);\n      },\n\n      _consumeQuotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n              // You can escape a double quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"\\\"\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          return JSON.parse(stream.slice(start, this._current));\n      },\n\n      _consumeRawStringLiteral: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== \"'\" && this._current < maxLength) {\n              // You can escape a single quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"'\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          var literal = stream.slice(start + 1, this._current - 1);\n          return literal.replace(\"\\\\'\", \"'\");\n      },\n\n      _consumeNumber: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (isNum(stream[this._current]) && this._current < maxLength) {\n              this._current++;\n          }\n          var value = parseInt(stream.slice(start, this._current));\n          return {type: TOK_NUMBER, value: value, start: start};\n      },\n\n      _consumeLBracket: function(stream) {\n          var start = this._current;\n          this._current++;\n          if (stream[this._current] === \"?\") {\n              this._current++;\n              return {type: TOK_FILTER, value: \"[?\", start: start};\n          } else if (stream[this._current] === \"]\") {\n              this._current++;\n              return {type: TOK_FLATTEN, value: \"[]\", start: start};\n          } else {\n              return {type: TOK_LBRACKET, value: \"[\", start: start};\n          }\n      },\n\n      _consumeOperator: function(stream) {\n          var start = this._current;\n          var startingChar = stream[start];\n          this._current++;\n          if (startingChar === \"!\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_NE, value: \"!=\", start: start};\n              } else {\n                return {type: TOK_NOT, value: \"!\", start: start};\n              }\n          } else if (startingChar === \"<\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_LTE, value: \"<=\", start: start};\n              } else {\n                  return {type: TOK_LT, value: \"<\", start: start};\n              }\n          } else if (startingChar === \">\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_GTE, value: \">=\", start: start};\n              } else {\n                  return {type: TOK_GT, value: \">\", start: start};\n              }\n          } else if (startingChar === \"=\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_EQ, value: \"==\", start: start};\n              }\n          }\n      },\n\n      _consumeLiteral: function(stream) {\n          this._current++;\n          var start = this._current;\n          var maxLength = stream.length;\n          var literal;\n          while(stream[this._current] !== \"`\" && this._current < maxLength) {\n              // You can escape a literal char or you can escape the escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"`\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          var literalString = trimLeft(stream.slice(start, this._current));\n          literalString = literalString.replace(\"\\\\`\", \"`\");\n          if (this._looksLikeJSON(literalString)) {\n              literal = JSON.parse(literalString);\n          } else {\n              // Try to JSON parse it as \"<literal>\"\n              literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n          }\n          // +1 gets us to the ending \"`\", +1 to move on to the next char.\n          this._current++;\n          return literal;\n      },\n\n      _looksLikeJSON: function(literalString) {\n          var startingChars = \"[{\\\"\";\n          var jsonLiterals = [\"true\", \"false\", \"null\"];\n          var numberLooking = \"-0123456789\";\n\n          if (literalString === \"\") {\n              return false;\n          } else if (startingChars.indexOf(literalString[0]) >= 0) {\n              return true;\n          } else if (jsonLiterals.indexOf(literalString) >= 0) {\n              return true;\n          } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n              try {\n                  JSON.parse(literalString);\n                  return true;\n              } catch (ex) {\n                  return false;\n              }\n          } else {\n              return false;\n          }\n      }\n  };\n\n      var bindingPower = {};\n      bindingPower[TOK_EOF] = 0;\n      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_RBRACKET] = 0;\n      bindingPower[TOK_RPAREN] = 0;\n      bindingPower[TOK_COMMA] = 0;\n      bindingPower[TOK_RBRACE] = 0;\n      bindingPower[TOK_NUMBER] = 0;\n      bindingPower[TOK_CURRENT] = 0;\n      bindingPower[TOK_EXPREF] = 0;\n      bindingPower[TOK_PIPE] = 1;\n      bindingPower[TOK_OR] = 2;\n      bindingPower[TOK_AND] = 3;\n      bindingPower[TOK_EQ] = 5;\n      bindingPower[TOK_GT] = 5;\n      bindingPower[TOK_LT] = 5;\n      bindingPower[TOK_GTE] = 5;\n      bindingPower[TOK_LTE] = 5;\n      bindingPower[TOK_NE] = 5;\n      bindingPower[TOK_FLATTEN] = 9;\n      bindingPower[TOK_STAR] = 20;\n      bindingPower[TOK_FILTER] = 21;\n      bindingPower[TOK_DOT] = 40;\n      bindingPower[TOK_NOT] = 45;\n      bindingPower[TOK_LBRACE] = 50;\n      bindingPower[TOK_LBRACKET] = 55;\n      bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n      parse: function(expression) {\n          this._loadTokens(expression);\n          this.index = 0;\n          var ast = this.expression(0);\n          if (this._lookahead(0) !== TOK_EOF) {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\n                  \"Unexpected token type: \" + t.type + \", value: \" + t.value);\n              error.name = \"ParserError\";\n              throw error;\n          }\n          return ast;\n      },\n\n      _loadTokens: function(expression) {\n          var lexer = new Lexer();\n          var tokens = lexer.tokenize(expression);\n          tokens.push({type: TOK_EOF, value: \"\", start: expression.length});\n          this.tokens = tokens;\n      },\n\n      expression: function(rbp) {\n          var leftToken = this._lookaheadToken(0);\n          this._advance();\n          var left = this.nud(leftToken);\n          var currentToken = this._lookahead(0);\n          while (rbp < bindingPower[currentToken]) {\n              this._advance();\n              left = this.led(currentToken, left);\n              currentToken = this._lookahead(0);\n          }\n          return left;\n      },\n\n      _lookahead: function(number) {\n          return this.tokens[this.index + number].type;\n      },\n\n      _lookaheadToken: function(number) {\n          return this.tokens[this.index + number];\n      },\n\n      _advance: function() {\n          this.index++;\n      },\n\n      nud: function(token) {\n        var left;\n        var right;\n        var expression;\n        switch (token.type) {\n          case TOK_LITERAL:\n            return {type: \"Literal\", value: token.value};\n          case TOK_UNQUOTEDIDENTIFIER:\n            return {type: \"Field\", name: token.value};\n          case TOK_QUOTEDIDENTIFIER:\n            var node = {type: \"Field\", name: token.value};\n            if (this._lookahead(0) === TOK_LPAREN) {\n                throw new Error(\"Quoted identifier not allowed for function names.\");\n            } else {\n                return node;\n            }\n            break;\n          case TOK_NOT:\n            right = this.expression(bindingPower.Not);\n            return {type: \"NotExpression\", children: [right]};\n          case TOK_STAR:\n            left = {type: \"Identity\"};\n            right = null;\n            if (this._lookahead(0) === TOK_RBRACKET) {\n                // This can happen in a multiselect,\n                // [a, b, *]\n                right = {type: \"Identity\"};\n            } else {\n                right = this._parseProjectionRHS(bindingPower.Star);\n            }\n            return {type: \"ValueProjection\", children: [left, right]};\n          case TOK_FILTER:\n            return this.led(token.type, {type: \"Identity\"});\n          case TOK_LBRACE:\n            return this._parseMultiselectHash();\n          case TOK_FLATTEN:\n            left = {type: TOK_FLATTEN, children: [{type: \"Identity\"}]};\n            right = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: \"Projection\", children: [left, right]};\n          case TOK_LBRACKET:\n            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice({type: \"Identity\"}, right);\n            } else if (this._lookahead(0) === TOK_STAR &&\n                       this._lookahead(1) === TOK_RBRACKET) {\n                this._advance();\n                this._advance();\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: \"Projection\",\n                        children: [{type: \"Identity\"}, right]};\n            } else {\n                return this._parseMultiselectList();\n            }\n            break;\n          case TOK_CURRENT:\n            return {type: TOK_CURRENT};\n          case TOK_EXPREF:\n            expression = this.expression(bindingPower.Expref);\n            return {type: \"ExpressionReference\", children: [expression]};\n          case TOK_LPAREN:\n            var args = [];\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            return args[0];\n          default:\n            this._errorToken(token);\n        }\n      },\n\n      led: function(tokenName, left) {\n        var right;\n        switch(tokenName) {\n          case TOK_DOT:\n            var rbp = bindingPower.Dot;\n            if (this._lookahead(0) !== TOK_STAR) {\n                right = this._parseDotRHS(rbp);\n                return {type: \"Subexpression\", children: [left, right]};\n            } else {\n                // Creating a projection.\n                this._advance();\n                right = this._parseProjectionRHS(rbp);\n                return {type: \"ValueProjection\", children: [left, right]};\n            }\n            break;\n          case TOK_PIPE:\n            right = this.expression(bindingPower.Pipe);\n            return {type: TOK_PIPE, children: [left, right]};\n          case TOK_OR:\n            right = this.expression(bindingPower.Or);\n            return {type: \"OrExpression\", children: [left, right]};\n          case TOK_AND:\n            right = this.expression(bindingPower.And);\n            return {type: \"AndExpression\", children: [left, right]};\n          case TOK_LPAREN:\n            var name = left.name;\n            var args = [];\n            var expression, node;\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              if (this._lookahead(0) === TOK_COMMA) {\n                this._match(TOK_COMMA);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            node = {type: \"Function\", name: name, children: args};\n            return node;\n          case TOK_FILTER:\n            var condition = this.expression(0);\n            this._match(TOK_RBRACKET);\n            if (this._lookahead(0) === TOK_FLATTEN) {\n              right = {type: \"Identity\"};\n            } else {\n              right = this._parseProjectionRHS(bindingPower.Filter);\n            }\n            return {type: \"FilterProjection\", children: [left, right, condition]};\n          case TOK_FLATTEN:\n            var leftNode = {type: TOK_FLATTEN, children: [left]};\n            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: \"Projection\", children: [leftNode, rightNode]};\n          case TOK_EQ:\n          case TOK_NE:\n          case TOK_GT:\n          case TOK_GTE:\n          case TOK_LT:\n          case TOK_LTE:\n            return this._parseComparator(left, tokenName);\n          case TOK_LBRACKET:\n            var token = this._lookaheadToken(0);\n            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice(left, right);\n            } else {\n                this._match(TOK_STAR);\n                this._match(TOK_RBRACKET);\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: \"Projection\", children: [left, right]};\n            }\n            break;\n          default:\n            this._errorToken(this._lookaheadToken(0));\n        }\n      },\n\n      _match: function(tokenType) {\n          if (this._lookahead(0) === tokenType) {\n              this._advance();\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n              error.name = \"ParserError\";\n              throw error;\n          }\n      },\n\n      _errorToken: function(token) {\n          var error = new Error(\"Invalid token (\" +\n                                token.type + \"): \\\"\" +\n                                token.value + \"\\\"\");\n          error.name = \"ParserError\";\n          throw error;\n      },\n\n\n      _parseIndexExpression: function() {\n          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n              return this._parseSliceExpression();\n          } else {\n              var node = {\n                  type: \"Index\",\n                  value: this._lookaheadToken(0).value};\n              this._advance();\n              this._match(TOK_RBRACKET);\n              return node;\n          }\n      },\n\n      _projectIfSlice: function(left, right) {\n          var indexExpr = {type: \"IndexExpression\", children: [left, right]};\n          if (right.type === \"Slice\") {\n              return {\n                  type: \"Projection\",\n                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n              };\n          } else {\n              return indexExpr;\n          }\n      },\n\n      _parseSliceExpression: function() {\n          // [start:end:step] where each part is optional, as well as the last\n          // colon.\n          var parts = [null, null, null];\n          var index = 0;\n          var currentToken = this._lookahead(0);\n          while (currentToken !== TOK_RBRACKET && index < 3) {\n              if (currentToken === TOK_COLON) {\n                  index++;\n                  this._advance();\n              } else if (currentToken === TOK_NUMBER) {\n                  parts[index] = this._lookaheadToken(0).value;\n                  this._advance();\n              } else {\n                  var t = this._lookahead(0);\n                  var error = new Error(\"Syntax error, unexpected token: \" +\n                                        t.value + \"(\" + t.type + \")\");\n                  error.name = \"Parsererror\";\n                  throw error;\n              }\n              currentToken = this._lookahead(0);\n          }\n          this._match(TOK_RBRACKET);\n          return {\n              type: \"Slice\",\n              children: parts\n          };\n      },\n\n      _parseComparator: function(left, comparator) {\n        var right = this.expression(bindingPower[comparator]);\n        return {type: \"Comparator\", name: comparator, children: [left, right]};\n      },\n\n      _parseDotRHS: function(rbp) {\n          var lookahead = this._lookahead(0);\n          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n          if (exprTokens.indexOf(lookahead) >= 0) {\n              return this.expression(rbp);\n          } else if (lookahead === TOK_LBRACKET) {\n              this._match(TOK_LBRACKET);\n              return this._parseMultiselectList();\n          } else if (lookahead === TOK_LBRACE) {\n              this._match(TOK_LBRACE);\n              return this._parseMultiselectHash();\n          }\n      },\n\n      _parseProjectionRHS: function(rbp) {\n          var right;\n          if (bindingPower[this._lookahead(0)] < 10) {\n              right = {type: \"Identity\"};\n          } else if (this._lookahead(0) === TOK_LBRACKET) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_FILTER) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_DOT) {\n              this._match(TOK_DOT);\n              right = this._parseDotRHS(rbp);\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\"Sytanx error, unexpected token: \" +\n                                    t.value + \"(\" + t.type + \")\");\n              error.name = \"ParserError\";\n              throw error;\n          }\n          return right;\n      },\n\n      _parseMultiselectList: function() {\n          var expressions = [];\n          while (this._lookahead(0) !== TOK_RBRACKET) {\n              var expression = this.expression(0);\n              expressions.push(expression);\n              if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    throw new Error(\"Unexpected token Rbracket\");\n                  }\n              }\n          }\n          this._match(TOK_RBRACKET);\n          return {type: \"MultiSelectList\", children: expressions};\n      },\n\n      _parseMultiselectHash: function() {\n        var pairs = [];\n        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n        var keyToken, keyName, value, node;\n        for (;;) {\n          keyToken = this._lookaheadToken(0);\n          if (identifierTypes.indexOf(keyToken.type) < 0) {\n            throw new Error(\"Expecting an identifier token, got: \" +\n                            keyToken.type);\n          }\n          keyName = keyToken.value;\n          this._advance();\n          this._match(TOK_COLON);\n          value = this.expression(0);\n          node = {type: \"KeyValuePair\", name: keyName, value: value};\n          pairs.push(node);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          } else if (this._lookahead(0) === TOK_RBRACE) {\n            this._match(TOK_RBRACE);\n            break;\n          }\n        }\n        return {type: \"MultiSelectHash\", children: pairs};\n      }\n  };\n\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n      search: function(node, value) {\n          return this.visit(node, value);\n      },\n\n      visit: function(node, value) {\n          var matched, current, result, first, second, field, left, right, collected, i;\n          switch (node.type) {\n            case \"Field\":\n              if (value === null ) {\n                  return null;\n              } else if (isObject(value)) {\n                  field = value[node.name];\n                  if (field === undefined) {\n                      return null;\n                  } else {\n                      return field;\n                  }\n              } else {\n                return null;\n              }\n              break;\n            case \"Subexpression\":\n              result = this.visit(node.children[0], value);\n              for (i = 1; i < node.children.length; i++) {\n                  result = this.visit(node.children[1], result);\n                  if (result === null) {\n                      return null;\n                  }\n              }\n              return result;\n            case \"IndexExpression\":\n              left = this.visit(node.children[0], value);\n              right = this.visit(node.children[1], left);\n              return right;\n            case \"Index\":\n              if (!isArray(value)) {\n                return null;\n              }\n              var index = node.value;\n              if (index < 0) {\n                index = value.length + index;\n              }\n              result = value[index];\n              if (result === undefined) {\n                result = null;\n              }\n              return result;\n            case \"Slice\":\n              if (!isArray(value)) {\n                return null;\n              }\n              var sliceParams = node.children.slice(0);\n              var computed = this.computeSliceParams(value.length, sliceParams);\n              var start = computed[0];\n              var stop = computed[1];\n              var step = computed[2];\n              result = [];\n              if (step > 0) {\n                  for (i = start; i < stop; i += step) {\n                      result.push(value[i]);\n                  }\n              } else {\n                  for (i = start; i > stop; i += step) {\n                      result.push(value[i]);\n                  }\n              }\n              return result;\n            case \"Projection\":\n              // Evaluate left child.\n              var base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < base.length; i++) {\n                current = this.visit(node.children[1], base[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case \"ValueProjection\":\n              // Evaluate left child.\n              base = this.visit(node.children[0], value);\n              if (!isObject(base)) {\n                return null;\n              }\n              collected = [];\n              var values = objValues(base);\n              for (i = 0; i < values.length; i++) {\n                current = this.visit(node.children[1], values[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case \"FilterProjection\":\n              base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              var filtered = [];\n              var finalResults = [];\n              for (i = 0; i < base.length; i++) {\n                matched = this.visit(node.children[2], base[i]);\n                if (!isFalse(matched)) {\n                  filtered.push(base[i]);\n                }\n              }\n              for (var j = 0; j < filtered.length; j++) {\n                current = this.visit(node.children[1], filtered[j]);\n                if (current !== null) {\n                  finalResults.push(current);\n                }\n              }\n              return finalResults;\n            case \"Comparator\":\n              first = this.visit(node.children[0], value);\n              second = this.visit(node.children[1], value);\n              switch(node.name) {\n                case TOK_EQ:\n                  result = strictDeepEqual(first, second);\n                  break;\n                case TOK_NE:\n                  result = !strictDeepEqual(first, second);\n                  break;\n                case TOK_GT:\n                  result = first > second;\n                  break;\n                case TOK_GTE:\n                  result = first >= second;\n                  break;\n                case TOK_LT:\n                  result = first < second;\n                  break;\n                case TOK_LTE:\n                  result = first <= second;\n                  break;\n                default:\n                  throw new Error(\"Unknown comparator: \" + node.name);\n              }\n              return result;\n            case TOK_FLATTEN:\n              var original = this.visit(node.children[0], value);\n              if (!isArray(original)) {\n                return null;\n              }\n              var merged = [];\n              for (i = 0; i < original.length; i++) {\n                current = original[i];\n                if (isArray(current)) {\n                  merged.push.apply(merged, current);\n                } else {\n                  merged.push(current);\n                }\n              }\n              return merged;\n            case \"Identity\":\n              return value;\n            case \"MultiSelectList\":\n              if (value === null) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < node.children.length; i++) {\n                  collected.push(this.visit(node.children[i], value));\n              }\n              return collected;\n            case \"MultiSelectHash\":\n              if (value === null) {\n                return null;\n              }\n              collected = {};\n              var child;\n              for (i = 0; i < node.children.length; i++) {\n                child = node.children[i];\n                collected[child.name] = this.visit(child.value, value);\n              }\n              return collected;\n            case \"OrExpression\":\n              matched = this.visit(node.children[0], value);\n              if (isFalse(matched)) {\n                  matched = this.visit(node.children[1], value);\n              }\n              return matched;\n            case \"AndExpression\":\n              first = this.visit(node.children[0], value);\n\n              if (isFalse(first) === true) {\n                return first;\n              }\n              return this.visit(node.children[1], value);\n            case \"NotExpression\":\n              first = this.visit(node.children[0], value);\n              return isFalse(first);\n            case \"Literal\":\n              return node.value;\n            case TOK_PIPE:\n              left = this.visit(node.children[0], value);\n              return this.visit(node.children[1], left);\n            case TOK_CURRENT:\n              return value;\n            case \"Function\":\n              var resolvedArgs = [];\n              for (i = 0; i < node.children.length; i++) {\n                  resolvedArgs.push(this.visit(node.children[i], value));\n              }\n              return this.runtime.callFunction(node.name, resolvedArgs);\n            case \"ExpressionReference\":\n              var refNode = node.children[0];\n              // Tag the node with a specific attribute so the type\n              // checker verify the type.\n              refNode.jmespathType = TOK_EXPREF;\n              return refNode;\n            default:\n              throw new Error(\"Unknown node type: \" + node.type);\n          }\n      },\n\n      computeSliceParams: function(arrayLength, sliceParams) {\n        var start = sliceParams[0];\n        var stop = sliceParams[1];\n        var step = sliceParams[2];\n        var computed = [null, null, null];\n        if (step === null) {\n          step = 1;\n        } else if (step === 0) {\n          var error = new Error(\"Invalid slice, step cannot be 0\");\n          error.name = \"RuntimeError\";\n          throw error;\n        }\n        var stepValueNegative = step < 0 ? true : false;\n\n        if (start === null) {\n            start = stepValueNegative ? arrayLength - 1 : 0;\n        } else {\n            start = this.capSliceRange(arrayLength, start, step);\n        }\n\n        if (stop === null) {\n            stop = stepValueNegative ? -1 : arrayLength;\n        } else {\n            stop = this.capSliceRange(arrayLength, stop, step);\n        }\n        computed[0] = start;\n        computed[1] = stop;\n        computed[2] = step;\n        return computed;\n      },\n\n      capSliceRange: function(arrayLength, actualValue, step) {\n          if (actualValue < 0) {\n              actualValue += arrayLength;\n              if (actualValue < 0) {\n                  actualValue = step < 0 ? -1 : 0;\n              }\n          } else if (actualValue >= arrayLength) {\n              actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n          }\n          return actualValue;\n      }\n\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n        // name: [function, <signature>]\n        // The <signature> can be:\n        //\n        // {\n        //   args: [[type1, type2], [type1, type2]],\n        //   variadic: true|false\n        // }\n        //\n        // Each arg in the arg list is a list of valid types\n        // (if the function is overloaded and supports multiple\n        // types.  If the type is \"any\" then no type checking\n        // occurs on the argument.  Variadic is optional\n        // and if not provided is assumed to be false.\n        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},\n        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},\n        contains: {\n            _func: this._functionContains,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},\n                        {types: [TYPE_ANY]}]},\n        \"ends_with\": {\n            _func: this._functionEndsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},\n        length: {\n            _func: this._functionLength,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},\n        map: {\n            _func: this._functionMap,\n            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},\n        max: {\n            _func: this._functionMax,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        \"merge\": {\n            _func: this._functionMerge,\n            _signature: [{types: [TYPE_OBJECT], variadic: true}]\n        },\n        \"max_by\": {\n          _func: this._functionMaxBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        \"starts_with\": {\n            _func: this._functionStartsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        min: {\n            _func: this._functionMin,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        \"min_by\": {\n          _func: this._functionMinBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},\n        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},\n        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},\n        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},\n        \"sort_by\": {\n          _func: this._functionSortBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        join: {\n            _func: this._functionJoin,\n            _signature: [\n                {types: [TYPE_STRING]},\n                {types: [TYPE_ARRAY_STRING]}\n            ]\n        },\n        reverse: {\n            _func: this._functionReverse,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},\n        \"to_array\": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},\n        \"to_string\": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},\n        \"to_number\": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},\n        \"not_null\": {\n            _func: this._functionNotNull,\n            _signature: [{types: [TYPE_ANY], variadic: true}]\n        }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n          throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n\n    _validateArgs: function(name, args, signature) {\n        // Validating the args requires validating\n        // the correct arity and the correct type of each arg.\n        // If the last argument is declared as variadic, then we need\n        // a minimum number of args to be required.  Otherwise it has to\n        // be an exact amount.\n        var pluralized;\n        if (signature[signature.length - 1].variadic) {\n            if (args.length < signature.length) {\n                pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n                throw new Error(\"ArgumentError: \" + name + \"() \" +\n                                \"takes at least\" + signature.length + pluralized +\n                                \" but received \" + args.length);\n            }\n        } else if (args.length !== signature.length) {\n            pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n            throw new Error(\"ArgumentError: \" + name + \"() \" +\n                            \"takes \" + signature.length + pluralized +\n                            \" but received \" + args.length);\n        }\n        var currentSpec;\n        var actualType;\n        var typeMatched;\n        for (var i = 0; i < signature.length; i++) {\n            typeMatched = false;\n            currentSpec = signature[i].types;\n            actualType = this._getTypeName(args[i]);\n            for (var j = 0; j < currentSpec.length; j++) {\n                if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                    typeMatched = true;\n                    break;\n                }\n            }\n            if (!typeMatched) {\n                throw new Error(\"TypeError: \" + name + \"() \" +\n                                \"expected argument \" + (i + 1) +\n                                \" to be type \" + currentSpec +\n                                \" but received type \" + actualType +\n                                \" instead.\");\n            }\n        }\n    },\n\n    _typeMatches: function(actual, expected, argValue) {\n        if (expected === TYPE_ANY) {\n            return true;\n        }\n        if (expected === TYPE_ARRAY_STRING ||\n            expected === TYPE_ARRAY_NUMBER ||\n            expected === TYPE_ARRAY) {\n            // The expected type can either just be array,\n            // or it can require a specific subtype (array of numbers).\n            //\n            // The simplest case is if \"array\" with no subtype is specified.\n            if (expected === TYPE_ARRAY) {\n                return actual === TYPE_ARRAY;\n            } else if (actual === TYPE_ARRAY) {\n                // Otherwise we need to check subtypes.\n                // I think this has potential to be improved.\n                var subtype;\n                if (expected === TYPE_ARRAY_NUMBER) {\n                  subtype = TYPE_NUMBER;\n                } else if (expected === TYPE_ARRAY_STRING) {\n                  subtype = TYPE_STRING;\n                }\n                for (var i = 0; i < argValue.length; i++) {\n                    if (!this._typeMatches(\n                            this._getTypeName(argValue[i]), subtype,\n                                             argValue[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } else {\n            return actual === expected;\n        }\n    },\n    _getTypeName: function(obj) {\n        switch (Object.prototype.toString.call(obj)) {\n            case \"[object String]\":\n              return TYPE_STRING;\n            case \"[object Number]\":\n              return TYPE_NUMBER;\n            case \"[object Array]\":\n              return TYPE_ARRAY;\n            case \"[object Boolean]\":\n              return TYPE_BOOLEAN;\n            case \"[object Null]\":\n              return TYPE_NULL;\n            case \"[object Object]\":\n              // Check if it's an expref.  If it has, it's been\n              // tagged with a jmespathType attr of 'Expref';\n              if (obj.jmespathType === TOK_EXPREF) {\n                return TYPE_EXPREF;\n              } else {\n                return TYPE_OBJECT;\n              }\n        }\n    },\n\n    _functionStartsWith: function(resolvedArgs) {\n        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n\n    _functionEndsWith: function(resolvedArgs) {\n        var searchStr = resolvedArgs[0];\n        var suffix = resolvedArgs[1];\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n\n    _functionReverse: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_STRING) {\n          var originalStr = resolvedArgs[0];\n          var reversedStr = \"\";\n          for (var i = originalStr.length - 1; i >= 0; i--) {\n              reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        } else {\n          var reversedArray = resolvedArgs[0].slice(0);\n          reversedArray.reverse();\n          return reversedArray;\n        }\n    },\n\n    _functionAbs: function(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n\n    _functionCeil: function(resolvedArgs) {\n        return Math.ceil(resolvedArgs[0]);\n    },\n\n    _functionAvg: function(resolvedArgs) {\n        var sum = 0;\n        var inputArray = resolvedArgs[0];\n        for (var i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n        }\n        return sum / inputArray.length;\n    },\n\n    _functionContains: function(resolvedArgs) {\n        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n\n    _functionFloor: function(resolvedArgs) {\n        return Math.floor(resolvedArgs[0]);\n    },\n\n    _functionLength: function(resolvedArgs) {\n       if (!isObject(resolvedArgs[0])) {\n         return resolvedArgs[0].length;\n       } else {\n         // As far as I can tell, there's no way to get the length\n         // of an object without O(n) iteration through the object.\n         return Object.keys(resolvedArgs[0]).length;\n       }\n    },\n\n    _functionMap: function(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n          mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n\n    _functionMerge: function(resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n\n    _functionMax: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (maxElement.localeCompare(elements[i]) < 0) {\n                  maxElement = elements[i];\n              }\n          }\n          return maxElement;\n        }\n      } else {\n          return null;\n      }\n    },\n\n    _functionMin: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (elements[i].localeCompare(minElement) < 0) {\n                  minElement = elements[i];\n              }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n\n    _functionSum: function(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n\n    _functionType: function(resolvedArgs) {\n        switch (this._getTypeName(resolvedArgs[0])) {\n          case TYPE_NUMBER:\n            return \"number\";\n          case TYPE_STRING:\n            return \"string\";\n          case TYPE_ARRAY:\n            return \"array\";\n          case TYPE_OBJECT:\n            return \"object\";\n          case TYPE_BOOLEAN:\n            return \"boolean\";\n          case TYPE_EXPREF:\n            return \"expref\";\n          case TYPE_NULL:\n            return \"null\";\n        }\n    },\n\n    _functionKeys: function(resolvedArgs) {\n        return Object.keys(resolvedArgs[0]);\n    },\n\n    _functionValues: function(resolvedArgs) {\n        var obj = resolvedArgs[0];\n        var keys = Object.keys(obj);\n        var values = [];\n        for (var i = 0; i < keys.length; i++) {\n            values.push(obj[keys[i]]);\n        }\n        return values;\n    },\n\n    _functionJoin: function(resolvedArgs) {\n        var joinChar = resolvedArgs[0];\n        var listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n    },\n\n    _functionToArray: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n            return resolvedArgs[0];\n        } else {\n            return [resolvedArgs[0]];\n        }\n    },\n\n    _functionToString: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n            return resolvedArgs[0];\n        } else {\n            return JSON.stringify(resolvedArgs[0]);\n        }\n    },\n\n    _functionToNumber: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        var convertedValue;\n        if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0];\n        } else if (typeName === TYPE_STRING) {\n            convertedValue = +resolvedArgs[0];\n            if (!isNaN(convertedValue)) {\n                return convertedValue;\n            }\n        }\n        return null;\n    },\n\n    _functionNotNull: function(resolvedArgs) {\n        for (var i = 0; i < resolvedArgs.length; i++) {\n            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n                return resolvedArgs[i];\n            }\n        }\n        return null;\n    },\n\n    _functionSort: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        sortedArray.sort();\n        return sortedArray;\n    },\n\n    _functionSortBy: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n            return sortedArray;\n        }\n        var interpreter = this._interpreter;\n        var exprefNode = resolvedArgs[1];\n        var requiredType = this._getTypeName(\n            interpreter.visit(exprefNode, sortedArray[0]));\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n            throw new Error(\"TypeError\");\n        }\n        var that = this;\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        var decorated = [];\n        for (var i = 0; i < sortedArray.length; i++) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort(function(a, b) {\n          var exprA = interpreter.visit(exprefNode, a[1]);\n          var exprB = interpreter.visit(exprefNode, b[1]);\n          if (that._getTypeName(exprA) !== requiredType) {\n              throw new Error(\n                  \"TypeError: expected \" + requiredType + \", received \" +\n                  that._getTypeName(exprA));\n          } else if (that._getTypeName(exprB) !== requiredType) {\n              throw new Error(\n                  \"TypeError: expected \" + requiredType + \", received \" +\n                  that._getTypeName(exprB));\n          }\n          if (exprA > exprB) {\n            return 1;\n          } else if (exprA < exprB) {\n            return -1;\n          } else {\n            // If they're equal compare the items by their\n            // order to maintain relative order of equal keys\n            // (i.e. to get a stable sort).\n            return a[0] - b[0];\n          }\n        });\n        // Undecorate: extract out the original list elements.\n        for (var j = 0; j < decorated.length; j++) {\n          sortedArray[j] = decorated[j][1];\n        }\n        return sortedArray;\n    },\n\n    _functionMaxBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n\n    _functionMinBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n\n    createKeyFunction: function(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function(x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes +\n                    \", received \" + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n      var lexer = new Lexer();\n      return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n      var parser = new Parser();\n      // This needs to be improved.  Both the interpreter and runtime depend on\n      // each other.  The runtime needs the interpreter to support exprefs.\n      // There's likely a clean way to avoid the cyclic dependency.\n      var runtime = new Runtime();\n      var interpreter = new TreeInterpreter(runtime);\n      runtime._interpreter = interpreter;\n      var node = parser.parse(expression);\n      return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);\n"]},"metadata":{},"sourceType":"script"}