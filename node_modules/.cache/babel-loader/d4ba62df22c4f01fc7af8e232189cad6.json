{"ast":null,"code":"var AWS = require('../core');\n/**\n * @api private\n */\n\n\nvar service = null;\n/**\n * @api private\n */\n\nvar api = {\n  signatureVersion: 'v4',\n  signingName: 'rds-db',\n  operations: {}\n};\n/**\n * @api private\n */\n\nvar requiredAuthTokenOptions = {\n  region: 'string',\n  hostname: 'string',\n  port: 'number',\n  username: 'string'\n};\n/**\n * A signer object can be used to generate an auth token to a database.\n */\n\nAWS.RDS.Signer = AWS.util.inherit({\n  /**\n   * Creates a signer object can be used to generate an auth token.\n   *\n   * @option options credentials [AWS.Credentials] the AWS credentials\n   *   to sign requests with. Uses the default credential provider chain\n   *   if not specified.\n   * @option options hostname [String] the hostname of the database to connect to.\n   * @option options port [Number] the port number the database is listening on.\n   * @option options region [String] the region the database is located in.\n   * @option options username [String] the username to login as.\n   * @example Passing in options to constructor\n   *   var signer = new AWS.RDS.Signer({\n   *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\n   *     region: 'us-east-1',\n   *     hostname: 'db.us-east-1.rds.amazonaws.com',\n   *     port: 8000,\n   *     username: 'name'\n   *   });\n   */\n  constructor: function Signer(options) {\n    this.options = options || {};\n  },\n\n  /**\n   * @api private\n   * Strips the protocol from a url.\n   */\n  convertUrlToAuthToken: function convertUrlToAuthToken(url) {\n    // we are always using https as the protocol\n    var protocol = 'https://';\n\n    if (url.indexOf(protocol) === 0) {\n      return url.substring(protocol.length);\n    }\n  },\n\n  /**\n   * @overload getAuthToken(options = {}, [callback])\n   *   Generate an auth token to a database.\n   *   @note You must ensure that you have static or previously resolved\n   *     credentials if you call this method synchronously (with no callback),\n   *     otherwise it may not properly sign the request. If you cannot guarantee\n   *     this (you are using an asynchronous credential provider, i.e., EC2\n   *     IAM roles), you should always call this method with an asynchronous\n   *     callback.\n   *\n   *   @param options [map] The fields to use when generating an auth token.\n   *     Any options specified here will be merged on top of any options passed\n   *     to AWS.RDS.Signer:\n   *\n   *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\n   *         to sign requests with. Uses the default credential provider chain\n   *         if not specified.\n   *     * **hostname** (String) &mdash; the hostname of the database to connect to.\n   *     * **port** (Number) &mdash; the port number the database is listening on.\n   *     * **region** (String) &mdash; the region the database is located in.\n   *     * **username** (String) &mdash; the username to login as.\n   *   @return [String] if called synchronously (with no callback), returns the\n   *     auth token.\n   *   @return [null] nothing is returned if a callback is provided.\n   *   @callback callback function (err, token)\n   *     If a callback is supplied, it is called when an auth token has been generated.\n   *     @param err [Error] the error object returned from the signer.\n   *     @param token [String] the auth token.\n   *\n   *   @example Generating an auth token synchronously\n   *     var signer = new AWS.RDS.Signer({\n   *       // configure options\n   *       region: 'us-east-1',\n   *       username: 'default',\n   *       hostname: 'db.us-east-1.amazonaws.com',\n   *       port: 8000\n   *     });\n   *     var token = signer.getAuthToken({\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\n   *       username: 'test' // overriding username\n   *     });\n   *   @example Generating an auth token asynchronously\n   *     var signer = new AWS.RDS.Signer({\n   *       // configure options\n   *       region: 'us-east-1',\n   *       username: 'default',\n   *       hostname: 'db.us-east-1.amazonaws.com',\n   *       port: 8000\n   *     });\n   *     signer.getAuthToken({\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\n   *       username: 'test' // overriding username\n   *     }, function(err, token) {\n   *       if (err) {\n   *         // handle error\n   *       } else {\n   *         // use token\n   *       }\n   *     });\n   *\n   */\n  getAuthToken: function getAuthToken(options, callback) {\n    if (typeof options === 'function' && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n\n    var self = this;\n    var hasCallback = typeof callback === 'function'; // merge options with existing options\n\n    options = AWS.util.merge(this.options, options); // validate options\n\n    var optionsValidation = this.validateAuthTokenOptions(options);\n\n    if (optionsValidation !== true) {\n      if (hasCallback) {\n        return callback(optionsValidation, null);\n      }\n\n      throw optionsValidation;\n    } // 15 minutes\n\n\n    var expires = 900; // create service to generate a request from\n\n    var serviceOptions = {\n      region: options.region,\n      endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\n      paramValidation: false,\n      signatureVersion: 'v4'\n    };\n\n    if (options.credentials) {\n      serviceOptions.credentials = options.credentials;\n    }\n\n    service = new AWS.Service(serviceOptions); // ensure the SDK is using sigv4 signing (config is not enough)\n\n    service.api = api;\n    var request = service.makeRequest(); // add listeners to request to properly build auth token\n\n    this.modifyRequestForAuthToken(request, options);\n\n    if (hasCallback) {\n      request.presign(expires, function (err, url) {\n        if (url) {\n          url = self.convertUrlToAuthToken(url);\n        }\n\n        callback(err, url);\n      });\n    } else {\n      var url = request.presign(expires);\n      return this.convertUrlToAuthToken(url);\n    }\n  },\n\n  /**\n   * @api private\n   * Modifies a request to allow the presigner to generate an auth token.\n   */\n  modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\n    request.on('build', request.buildAsGet);\n    var httpRequest = request.httpRequest;\n    httpRequest.body = AWS.util.queryParamsToString({\n      Action: 'connect',\n      DBUser: options.username\n    });\n  },\n\n  /**\n   * @api private\n   * Validates that the options passed in contain all the keys with values of the correct type that\n   *   are needed to generate an auth token.\n   */\n  validateAuthTokenOptions: function validateAuthTokenOptions(options) {\n    // iterate over all keys in options\n    var message = '';\n    options = options || {};\n\n    for (var key in requiredAuthTokenOptions) {\n      if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\n        continue;\n      }\n\n      if (typeof options[key] !== requiredAuthTokenOptions[key]) {\n        message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\n      }\n    }\n\n    if (message.length) {\n      return AWS.util.error(new Error(), {\n        code: 'InvalidParameter',\n        message: message\n      });\n    }\n\n    return true;\n  }\n});","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/aws-sdk/lib/rds/signer.js"],"names":["AWS","require","service","api","signatureVersion","signingName","operations","requiredAuthTokenOptions","region","hostname","port","username","RDS","Signer","util","inherit","constructor","options","convertUrlToAuthToken","url","protocol","indexOf","substring","length","getAuthToken","callback","undefined","self","hasCallback","merge","optionsValidation","validateAuthTokenOptions","expires","serviceOptions","endpoint","Endpoint","paramValidation","credentials","Service","request","makeRequest","modifyRequestForAuthToken","presign","err","on","buildAsGet","httpRequest","body","queryParamsToString","Action","DBUser","message","key","Object","prototype","hasOwnProperty","call","error","Error","code"],"mappings":"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","sourcesContent":["var AWS = require('../core');\n\n/**\n * @api private\n */\nvar service = null;\n\n/**\n * @api private\n */\nvar api = {\n    signatureVersion: 'v4',\n    signingName: 'rds-db',\n    operations: {}\n};\n\n/**\n * @api private\n */\nvar requiredAuthTokenOptions = {\n    region: 'string',\n    hostname: 'string',\n    port: 'number',\n    username: 'string'\n};\n\n/**\n * A signer object can be used to generate an auth token to a database.\n */\nAWS.RDS.Signer = AWS.util.inherit({\n    /**\n     * Creates a signer object can be used to generate an auth token.\n     *\n     * @option options credentials [AWS.Credentials] the AWS credentials\n     *   to sign requests with. Uses the default credential provider chain\n     *   if not specified.\n     * @option options hostname [String] the hostname of the database to connect to.\n     * @option options port [Number] the port number the database is listening on.\n     * @option options region [String] the region the database is located in.\n     * @option options username [String] the username to login as.\n     * @example Passing in options to constructor\n     *   var signer = new AWS.RDS.Signer({\n     *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\n     *     region: 'us-east-1',\n     *     hostname: 'db.us-east-1.rds.amazonaws.com',\n     *     port: 8000,\n     *     username: 'name'\n     *   });\n     */\n    constructor: function Signer(options) {\n        this.options = options || {};\n    },\n\n    /**\n     * @api private\n     * Strips the protocol from a url.\n     */\n    convertUrlToAuthToken: function convertUrlToAuthToken(url) {\n        // we are always using https as the protocol\n        var protocol = 'https://';\n        if (url.indexOf(protocol) === 0) {\n            return url.substring(protocol.length);\n        }\n    },\n\n    /**\n     * @overload getAuthToken(options = {}, [callback])\n     *   Generate an auth token to a database.\n     *   @note You must ensure that you have static or previously resolved\n     *     credentials if you call this method synchronously (with no callback),\n     *     otherwise it may not properly sign the request. If you cannot guarantee\n     *     this (you are using an asynchronous credential provider, i.e., EC2\n     *     IAM roles), you should always call this method with an asynchronous\n     *     callback.\n     *\n     *   @param options [map] The fields to use when generating an auth token.\n     *     Any options specified here will be merged on top of any options passed\n     *     to AWS.RDS.Signer:\n     *\n     *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\n     *         to sign requests with. Uses the default credential provider chain\n     *         if not specified.\n     *     * **hostname** (String) &mdash; the hostname of the database to connect to.\n     *     * **port** (Number) &mdash; the port number the database is listening on.\n     *     * **region** (String) &mdash; the region the database is located in.\n     *     * **username** (String) &mdash; the username to login as.\n     *   @return [String] if called synchronously (with no callback), returns the\n     *     auth token.\n     *   @return [null] nothing is returned if a callback is provided.\n     *   @callback callback function (err, token)\n     *     If a callback is supplied, it is called when an auth token has been generated.\n     *     @param err [Error] the error object returned from the signer.\n     *     @param token [String] the auth token.\n     *\n     *   @example Generating an auth token synchronously\n     *     var signer = new AWS.RDS.Signer({\n     *       // configure options\n     *       region: 'us-east-1',\n     *       username: 'default',\n     *       hostname: 'db.us-east-1.amazonaws.com',\n     *       port: 8000\n     *     });\n     *     var token = signer.getAuthToken({\n     *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\n     *       // credentials are not specified here or when creating the signer, so default credential provider will be used\n     *       username: 'test' // overriding username\n     *     });\n     *   @example Generating an auth token asynchronously\n     *     var signer = new AWS.RDS.Signer({\n     *       // configure options\n     *       region: 'us-east-1',\n     *       username: 'default',\n     *       hostname: 'db.us-east-1.amazonaws.com',\n     *       port: 8000\n     *     });\n     *     signer.getAuthToken({\n     *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\n     *       // credentials are not specified here or when creating the signer, so default credential provider will be used\n     *       username: 'test' // overriding username\n     *     }, function(err, token) {\n     *       if (err) {\n     *         // handle error\n     *       } else {\n     *         // use token\n     *       }\n     *     });\n     *\n     */\n    getAuthToken: function getAuthToken(options, callback) {\n        if (typeof options === 'function' && callback === undefined) {\n            callback = options;\n            options = {};\n        }\n        var self = this;\n        var hasCallback = typeof callback === 'function';\n        // merge options with existing options\n        options = AWS.util.merge(this.options, options);\n        // validate options\n        var optionsValidation = this.validateAuthTokenOptions(options);\n        if (optionsValidation !== true) {\n            if (hasCallback) {\n                return callback(optionsValidation, null);\n            }\n            throw optionsValidation;\n        }\n\n        // 15 minutes\n        var expires = 900;\n        // create service to generate a request from\n        var serviceOptions = {\n            region: options.region,\n            endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\n            paramValidation: false,\n            signatureVersion: 'v4'\n        };\n        if (options.credentials) {\n            serviceOptions.credentials = options.credentials;\n        }\n        service = new AWS.Service(serviceOptions);\n        // ensure the SDK is using sigv4 signing (config is not enough)\n        service.api = api;\n\n        var request = service.makeRequest();\n        // add listeners to request to properly build auth token\n        this.modifyRequestForAuthToken(request, options);\n\n        if (hasCallback) {\n            request.presign(expires, function(err, url) {\n                if (url) {\n                    url = self.convertUrlToAuthToken(url);\n                }\n                callback(err, url);\n            });\n        } else {\n            var url = request.presign(expires);\n            return this.convertUrlToAuthToken(url);\n        }\n    },\n\n    /**\n     * @api private\n     * Modifies a request to allow the presigner to generate an auth token.\n     */\n    modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\n        request.on('build', request.buildAsGet);\n        var httpRequest = request.httpRequest;\n        httpRequest.body = AWS.util.queryParamsToString({\n            Action: 'connect',\n            DBUser: options.username\n        });\n    },\n\n    /**\n     * @api private\n     * Validates that the options passed in contain all the keys with values of the correct type that\n     *   are needed to generate an auth token.\n     */\n    validateAuthTokenOptions: function validateAuthTokenOptions(options) {\n        // iterate over all keys in options\n        var message = '';\n        options = options || {};\n        for (var key in requiredAuthTokenOptions) {\n            if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\n                continue;\n            }\n            if (typeof options[key] !== requiredAuthTokenOptions[key]) {\n                message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\n            }\n        }\n        if (message.length) {\n            return AWS.util.error(new Error(), {\n                code: 'InvalidParameter',\n                message: message\n            });\n        }\n        return true;\n    }\n});\n"]},"metadata":{},"sourceType":"script"}