{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\");\n\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = quotedOrList(suggestedTypeNames);\n    message += \" Did you mean to use an inline fragment on \".concat(suggestions, \"?\");\n  } else if (suggestedFieldNames.length !== 0) {\n    message += \" Did you mean \".concat(quotedOrList(suggestedFieldNames), \"?\");\n  }\n\n  return message;\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var possibleType = _step.value;\n\n        if (!possibleType.getFields()[fieldName]) {\n          continue;\n        } // This object type defines this field.\n\n\n        suggestedObjectTypes.push(possibleType.name);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var possibleInterface = _step2.value;\n\n            if (!possibleInterface.getFields()[fieldName]) {\n              continue;\n            } // This interface type defines this field.\n\n\n            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // Suggest interface types based on how common they are.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/validation/rules/FieldsOnCorrectType.mjs"],"names":["GraphQLError","suggestionList","quotedOrList","isObjectType","isInterfaceType","isAbstractType","undefinedFieldMessage","fieldName","type","suggestedTypeNames","suggestedFieldNames","message","concat","length","suggestions","FieldsOnCorrectType","context","Field","node","getParentType","fieldDef","getFieldDef","schema","getSchema","name","value","getSuggestedTypeNames","getSuggestedFieldNames","reportError","suggestedObjectTypes","interfaceUsageCount","Object","create","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","getPossibleTypes","Symbol","iterator","_step","next","done","possibleType","getFields","push","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getInterfaces","_step2","possibleInterface","err","return","suggestedInterfaceTypes","keys","sort","a","b","possibleFieldNames"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { GraphQLError } from '../../error/GraphQLError';\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\");\n\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = quotedOrList(suggestedTypeNames);\n    message += \" Did you mean to use an inline fragment on \".concat(suggestions, \"?\");\n  } else if (suggestedFieldNames.length !== 0) {\n    message += \" Did you mean \".concat(quotedOrList(suggestedFieldNames), \"?\");\n  }\n\n  return message;\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var possibleType = _step.value;\n\n        if (!possibleType.getFields()[fieldName]) {\n          continue;\n        } // This object type defines this field.\n\n\n        suggestedObjectTypes.push(possibleType.name);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var possibleInterface = _step2.value;\n\n            if (!possibleInterface.getFields()[fieldName]) {\n              continue;\n            } // This interface type defines this field.\n\n\n            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // Suggest interface types based on how common they are.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}"]},"metadata":{},"sourceType":"module"}