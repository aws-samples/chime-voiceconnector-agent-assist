{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar HeaderMarshaller_1 = require(\"./HeaderMarshaller\");\n\nvar splitMessage_1 = require(\"./splitMessage\");\n\nvar crc32_1 = require(\"@aws-crypto/crc32\");\n/**\n * A marshaller that can convert binary-packed event stream messages into\n * JavaScript objects and back again into their binary format.\n */\n\n\nvar EventStreamMarshaller =\n/** @class */\nfunction () {\n  function EventStreamMarshaller(toUtf8, fromUtf8) {\n    this.headerMarshaller = new HeaderMarshaller_1.HeaderMarshaller(toUtf8, fromUtf8);\n  }\n  /**\n   * Convert a structured JavaScript object with tagged headers into a binary\n   * event stream message.\n   */\n\n\n  EventStreamMarshaller.prototype.marshall = function (_a) {\n    var rawHeaders = _a.headers,\n        body = _a.body;\n    var headers = this.headerMarshaller.format(rawHeaders);\n    var length = headers.byteLength + body.byteLength + 16;\n    var out = new Uint8Array(length);\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    var checksum = new crc32_1.Crc32(); // Format message\n\n    view.setUint32(0, length, false);\n    view.setUint32(4, headers.byteLength, false);\n    view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);\n    out.set(headers, 12);\n    out.set(body, headers.byteLength + 12); // Write trailing message checksum\n\n    view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);\n    return out;\n  };\n  /**\n   * Convert a binary event stream message into a JavaScript object with an\n   * opaque, binary body and tagged, parsed headers.\n   */\n\n\n  EventStreamMarshaller.prototype.unmarshall = function (message) {\n    var _a = splitMessage_1.splitMessage(message),\n        headers = _a.headers,\n        body = _a.body;\n\n    return {\n      headers: this.headerMarshaller.parse(headers),\n      body: body\n    };\n  };\n\n  return EventStreamMarshaller;\n}();\n\nexports.EventStreamMarshaller = EventStreamMarshaller;","map":{"version":3,"sources":["../src/EventStreamMarshaller.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAEA,IAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAIA;;;;;;AAIA,IAAA,qBAAA;AAAA;AAAA,YAAA;AAGI,WAAA,qBAAA,CAAY,MAAZ,EAA6B,QAA7B,EAA8C;AAC1C,SAAK,gBAAL,GAAwB,IAAI,kBAAA,CAAA,gBAAJ,CAAqB,MAArB,EAA6B,QAA7B,CAAxB;AACH;AAED;;;;;;AAIA,EAAA,qBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,EAAT,EAA+C;QAApC,UAAA,GAAA,EAAA,CAAA,O;QAAqB,IAAA,GAAA,EAAA,CAAA,I;AAC5B,QAAM,OAAO,GAAG,KAAK,gBAAL,CAAsB,MAAtB,CAA6B,UAA7B,CAAhB;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,UAAR,GAAqB,IAAI,CAAC,UAA1B,GAAuC,EAAtD;AAEA,QAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAZ;AACA,QAAM,IAAI,GAAG,IAAI,QAAJ,CAAa,GAAG,CAAC,MAAjB,EAAyB,GAAG,CAAC,UAA7B,EAAyC,GAAG,CAAC,UAA7C,CAAb;AACA,QAAM,QAAQ,GAAG,IAAI,OAAA,CAAA,KAAJ,EAAjB,CAN2C,CAQ3C;;AACA,IAAA,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,MAAlB,EAA0B,KAA1B;AACA,IAAA,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,OAAO,CAAC,UAA1B,EAAsC,KAAtC;AACA,IAAA,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,QAAQ,CAAC,MAAT,CAAgB,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAhB,EAAoC,MAApC,EAAlB,EAAgE,KAAhE;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,OAAR,EAAiB,EAAjB;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,IAAR,EAAc,OAAO,CAAC,UAAR,GAAqB,EAAnC,EAb2C,CAe3C;;AACA,IAAA,IAAI,CAAC,SAAL,CACI,MAAM,GAAG,CADb,EAEI,QAAQ,CAAC,MAAT,CAAgB,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,MAAM,GAAG,CAAzB,CAAhB,EAA6C,MAA7C,EAFJ,EAGI,KAHJ;AAMA,WAAO,GAAP;AACH,GAvBD;AAyBA;;;;;;AAIA,EAAA,qBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,OAAX,EAAmC;AACzB,QAAA,EAAA,GAAA,cAAA,CAAA,YAAA,CAAA,OAAA,CAAA;AAAA,QAAE,OAAA,GAAA,EAAA,CAAA,OAAF;AAAA,QAAW,IAAA,GAAA,EAAA,CAAA,IAAX;;AAEN,WAAO;AAAE,MAAA,OAAO,EAAE,KAAK,gBAAL,CAAsB,KAAtB,CAA4B,OAA5B,CAAX;AAAiD,MAAA,IAAI,EAAA;AAArD,KAAP;AACH,GAJD;;AAKJ,SAAA,qBAAA;AAAC,CA7CD,EAAA;;AAAa,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HeaderMarshaller_1 = require(\"./HeaderMarshaller\");\nvar splitMessage_1 = require(\"./splitMessage\");\nvar crc32_1 = require(\"@aws-crypto/crc32\");\n/**\n * A marshaller that can convert binary-packed event stream messages into\n * JavaScript objects and back again into their binary format.\n */\nvar EventStreamMarshaller = /** @class */ (function () {\n    function EventStreamMarshaller(toUtf8, fromUtf8) {\n        this.headerMarshaller = new HeaderMarshaller_1.HeaderMarshaller(toUtf8, fromUtf8);\n    }\n    /**\n     * Convert a structured JavaScript object with tagged headers into a binary\n     * event stream message.\n     */\n    EventStreamMarshaller.prototype.marshall = function (_a) {\n        var rawHeaders = _a.headers, body = _a.body;\n        var headers = this.headerMarshaller.format(rawHeaders);\n        var length = headers.byteLength + body.byteLength + 16;\n        var out = new Uint8Array(length);\n        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n        var checksum = new crc32_1.Crc32;\n        // Format message\n        view.setUint32(0, length, false);\n        view.setUint32(4, headers.byteLength, false);\n        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);\n        out.set(headers, 12);\n        out.set(body, headers.byteLength + 12);\n        // Write trailing message checksum\n        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);\n        return out;\n    };\n    /**\n     * Convert a binary event stream message into a JavaScript object with an\n     * opaque, binary body and tagged, parsed headers.\n     */\n    EventStreamMarshaller.prototype.unmarshall = function (message) {\n        var _a = splitMessage_1.splitMessage(message), headers = _a.headers, body = _a.body;\n        return { headers: this.headerMarshaller.parse(headers), body: body };\n    };\n    return EventStreamMarshaller;\n}());\nexports.EventStreamMarshaller = EventStreamMarshaller;\n//# sourceMappingURL=EventStreamMarshaller.js.map"]},"metadata":{},"sourceType":"script"}