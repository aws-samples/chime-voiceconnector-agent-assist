{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport { isAbstractType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport inspect from '../jsutils/inspect';\nimport { __Schema } from './introspection';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues'; // eslint-disable-next-line no-redeclare\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/function () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_queryType\", void 0);\n\n    _defineProperty(this, \"_mutationType\", void 0);\n\n    _defineProperty(this, \"_subscriptionType\", void 0);\n\n    _defineProperty(this, \"_directives\", void 0);\n\n    _defineProperty(this, \"_typeMap\", void 0);\n\n    _defineProperty(this, \"_implementations\", void 0);\n\n    _defineProperty(this, \"_possibleTypeMap\", void 0);\n\n    _defineProperty(this, \"__validationErrors\", void 0);\n\n    _defineProperty(this, \"__allowedLegacyNames\", void 0); // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !(_typeof(config) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\")) : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\")) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\")) : void 0;\n    }\n\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    var _arr = Object.keys(this._typeMap);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var typeName = _arr[_i];\n      var type = this._typeMap[typeName];\n\n      if (isObjectType(type)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var iface = _step.value;\n\n            if (isInterfaceType(iface)) {\n              var impls = this._implementations[iface.name];\n\n              if (impls) {\n                impls.push(type);\n              } else {\n                this._implementations[iface.name] = [type];\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if (isAbstractType(type) && !this._implementations[type.name]) {\n        this._implementations[type.name] = [];\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + \"types named \\\"\".concat(type.name, \"\\\".\")) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = objectValues(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var field = _step2.value;\n\n        if (field.args) {\n          var fieldArgTypes = field.args.map(function (arg) {\n            return arg.type;\n          });\n          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n        }\n\n        reducedMap = typeMapReducer(reducedMap, field.type);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  if (isInputObjectType(type)) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = objectValues(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _field = _step3.value;\n        reducedMap = typeMapReducer(reducedMap, _field.type);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/type/schema.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","isAbstractType","isObjectType","isInterfaceType","isUnionType","isInputObjectType","isWrappingType","GraphQLDirective","isDirective","specifiedDirectives","inspect","__Schema","defineToStringTag","find","instanceOf","invariant","objectValues","isSchema","schema","GraphQLSchema","config","assumeValid","__validationErrors","types","Array","isArray","concat","directives","allowedLegacyNames","__allowedLegacyNames","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","astNode","extensionASTNodes","initialTypes","getQueryType","getMutationType","getSubscriptionType","typeMap","create","reduce","typeMapReducer","typeMapDirectiveReducer","_typeMap","_implementations","_arr","keys","_i","length","typeName","type","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","getInterfaces","_step","next","done","iface","impls","name","push","err","return","_proto","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","isPossibleType","possibleType","possibleTypeMap","_possibleTypeMap","possibleTypes","map","Boolean","getDirectives","getDirective","directive","ofType","reducedMap","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","getFields","_step2","field","args","fieldArgTypes","arg","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_field","_map"],"mappings":"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","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isAbstractType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isWrappingType } from './definition';\nimport { GraphQLDirective, isDirective, specifiedDirectives } from './directives';\nimport inspect from '../jsutils/inspect';\nimport { __Schema } from './introspection';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport find from '../jsutils/find';\nimport instanceOf from '../jsutils/instanceOf';\nimport invariant from '../jsutils/invariant';\nimport objectValues from '../jsutils/objectValues';\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema =\n/*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_queryType\", void 0);\n\n    _defineProperty(this, \"_mutationType\", void 0);\n\n    _defineProperty(this, \"_subscriptionType\", void 0);\n\n    _defineProperty(this, \"_directives\", void 0);\n\n    _defineProperty(this, \"_typeMap\", void 0);\n\n    _defineProperty(this, \"_implementations\", void 0);\n\n    _defineProperty(this, \"_possibleTypeMap\", void 0);\n\n    _defineProperty(this, \"__validationErrors\", void 0);\n\n    _defineProperty(this, \"__allowedLegacyNames\", void 0);\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !(_typeof(config) === 'object') ? invariant(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? invariant(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\")) : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? invariant(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\")) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? invariant(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat(inspect(config.allowedLegacyNames), \".\")) : void 0;\n    }\n\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || specifiedDirectives;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), __Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    var _arr = Object.keys(this._typeMap);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var typeName = _arr[_i];\n      var type = this._typeMap[typeName];\n\n      if (isObjectType(type)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var iface = _step.value;\n\n            if (isInterfaceType(iface)) {\n              var impls = this._implementations[iface.name];\n\n              if (impls) {\n                impls.push(type);\n              } else {\n                this._implementations[iface.name] = [type];\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if (isAbstractType(type) && !this._implementations[type.name]) {\n        this._implementations[type.name] = [];\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if (isUnionType(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if (isWrappingType(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? invariant(0, 'Schema must contain unique named types but contains multiple ' + \"types named \\\"\".concat(type.name, \"\\\".\")) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if (isUnionType(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = objectValues(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var field = _step2.value;\n\n        if (field.args) {\n          var fieldArgTypes = field.args.map(function (arg) {\n            return arg.type;\n          });\n          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n        }\n\n        reducedMap = typeMapReducer(reducedMap, field.type);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  if (isInputObjectType(type)) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = objectValues(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _field = _step3.value;\n        reducedMap = typeMapReducer(reducedMap, _field.type);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!isDirective(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}"]},"metadata":{},"sourceType":"module"}