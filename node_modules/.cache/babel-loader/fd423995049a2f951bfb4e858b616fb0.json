{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n\nimport defineToJSON from '../jsutils/defineToJSON';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport instanceOf from '../jsutils/instanceOf';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  !isType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL type.\")) : void 0;\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  !isScalarType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  !isObjectType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  !isInterfaceType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  !isUnionType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  !isEnumType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  !isInputObjectType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  !isListType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL List type.\")) : void 0;\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  !isNonNullType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\")) : void 0;\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  !isInputType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL input type.\")) : void 0;\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  !isOutputType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL output type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  !isLeafType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  !isCompositeType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  !isAbstractType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\")) : void 0;\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n// eslint-disable-next-line no-redeclare\n\nexport function GraphQLList(ofType) {\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n};\n\ndefineToJSON(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function GraphQLNonNull(ofType) {\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n};\n\ndefineToJSON(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  !isWrappingType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\")) : void 0;\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  !isNullableType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\")) : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  !isNamedType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL named type.\")) : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType = /*#__PURE__*/function () {\n  function GraphQLScalarType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"serialize\", void 0);\n\n    _defineProperty(this, \"parseValue\", void 0);\n\n    _defineProperty(this, \"parseLiteral\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.serialize = config.serialize;\n\n    this.parseValue = config.parseValue || function (value) {\n      return value;\n    };\n\n    this.parseLiteral = config.parseLiteral || valueFromASTUntyped;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(typeof config.serialize === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar \") + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? invariant(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" \") + 'functions.') : void 0;\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLScalarType);\ndefineToJSON(GraphQLScalarType);\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\n\nexport var GraphQLObjectType = /*#__PURE__*/function () {\n  function GraphQLObjectType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"isTypeOf\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    _defineProperty(this, \"_interfaces\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.isTypeOf = config.isTypeOf;\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(config.isTypeOf == null || typeof config.isTypeOf === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\")) : void 0;\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLObjectType);\ndefineToJSON(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var interfaces = resolveThunk(config.interfaces) || [];\n  !Array.isArray(interfaces) ? invariant(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns \") + 'an Array.') : void 0;\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  !isPlainObj(fieldMap) ? invariant(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a \") + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n\n  var _arr = Object.keys(fieldMap);\n\n  var _loop = function _loop() {\n    var fieldName = _arr[_i];\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object\")) : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" \") + 'instead of \"isDeprecated\".') : void 0;\n\n    var field = _objectSpread({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n\n    !(field.resolve == null || typeof field.resolve === 'function') ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(field.resolve), \".\")) : void 0;\n    var argsConfig = fieldConfig.args;\n\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument \") + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        var arg = argsConfig[argName];\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n\n    resultFieldMap[fieldName] = field;\n  };\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    _loop();\n  }\n\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n}\n\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\n\nexport var GraphQLInterfaceType = /*#__PURE__*/function () {\n  function GraphQLInterfaceType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"resolveType\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._fields = defineFieldMap.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(config.resolveType == null || typeof config.resolveType === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\")) : void 0;\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInterfaceType);\ndefineToJSON(GraphQLInterfaceType);\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\n\nexport var GraphQLUnionType = /*#__PURE__*/function () {\n  function GraphQLUnionType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"resolveType\", void 0);\n\n    _defineProperty(this, \"_types\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._types = defineTypes.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(config.resolveType == null || typeof config.resolveType === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\")) : void 0;\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLUnionType);\ndefineToJSON(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types) || [];\n  !Array.isArray(types) ? invariant(0, 'Must provide Array of types or a function which returns ' + \"such an array for Union \".concat(config.name, \".\")) : void 0;\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nexport var GraphQLEnumType\n/* <T> */\n=\n/*#__PURE__*/\nfunction () {\n  function GraphQLEnumType(config\n  /* <T> */\n  ) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    _defineProperty(this, \"_valueLookup\", void 0);\n\n    _defineProperty(this, \"_nameLookup\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._values = defineEnumValues(this, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(value\n  /* T */\n  ) {\n    var enumValue = this._valueLookup.get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  _proto5.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this.getValue(value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this.getValue(valueNode.value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLEnumType);\ndefineToJSON(GraphQLEnumType);\n\nfunction defineEnumValues(type, valueMap\n/* <T> */\n) {\n  !isPlainObj(valueMap) ? invariant(0, \"\".concat(type.name, \" values must be an object with value names as keys.\")) : void 0;\n  return Object.keys(valueMap).map(function (valueName) {\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? invariant(0, \"\".concat(type.name, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(value), \".\")) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? invariant(0, \"\".concat(type.name, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead \") + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n}\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLInputObjectType = /*#__PURE__*/function () {\n  function GraphQLInputObjectType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInputObjectType);\ndefineToJSON(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  !isPlainObj(fieldMap) ? invariant(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a \") + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n\n  var _arr2 = Object.keys(fieldMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var fieldName = _arr2[_i2];\n\n    var field = _objectSpread({}, fieldMap[fieldName], {\n      name: fieldName\n    });\n\n    !!field.hasOwnProperty('resolve') ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but \") + 'Input Types cannot define resolvers.') : void 0;\n    resultFieldMap[fieldName] = field;\n  }\n\n  return resultFieldMap;\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/type/definition.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","value","defineProperty","configurable","writable","defineToJSON","defineToStringTag","instanceOf","inspect","invariant","keyMap","Kind","valueFromASTUntyped","isType","type","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isListType","isNonNullType","assertType","GraphQLScalarType","assertScalarType","GraphQLObjectType","assertObjectType","GraphQLInterfaceType","assertInterfaceType","GraphQLUnionType","assertUnionType","GraphQLEnumType","assertEnumType","GraphQLInputObjectType","assertInputObjectType","GraphQLList","assertListType","GraphQLNonNull","assertNonNullType","isInputType","isWrappingType","ofType","assertInputType","isOutputType","assertOutputType","isLeafType","assertLeafType","isCompositeType","assertCompositeType","isAbstractType","assertAbstractType","toString","String","assertNullableType","assertWrappingType","isNullableType","getNullableType","isNamedType","assertNamedType","getNamedType","unwrappedType","resolveThunk","thunk","config","name","description","serialize","parseValue","parseLiteral","astNode","extensionASTNodes","_proto","isTypeOf","_fields","defineFieldMap","bind","undefined","_interfaces","defineInterfaces","_proto2","getFields","getInterfaces","interfaces","Array","isArray","fieldMap","fields","isPlainObj","resultFieldMap","create","_arr","_loop","fieldName","_i","fieldConfig","hasOwnProperty","field","isDeprecated","Boolean","deprecationReason","resolve","argsConfig","args","map","argName","arg","defaultValue","isRequiredArgument","resolveType","_proto3","_types","defineTypes","_proto4","getTypes","types","_values","defineEnumValues","values","_valueLookup","Map","enumValue","_nameLookup","_proto5","getValues","getValue","get","valueNode","_variables","kind","ENUM","valueMap","valueName","defineInputFieldMap","_proto6","_arr2","_i2","isRequiredInputField"],"mappings":"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","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport defineToJSON from '../jsutils/defineToJSON';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport instanceOf from '../jsutils/instanceOf';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  !isType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL type.\")) : void 0;\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  !isScalarType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  !isObjectType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  !isInterfaceType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  !isUnionType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  !isEnumType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  !isInputObjectType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  !isListType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL List type.\")) : void 0;\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  !isNonNullType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\")) : void 0;\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  !isInputType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL input type.\")) : void 0;\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  !isOutputType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL output type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  !isLeafType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  !isCompositeType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  !isAbstractType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\")) : void 0;\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n\n// eslint-disable-next-line no-redeclare\nexport function GraphQLList(ofType) {\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n};\n\ndefineToJSON(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function GraphQLNonNull(ofType) {\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n};\n\ndefineToJSON(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  !isWrappingType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\")) : void 0;\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  !isNullableType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\")) : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  !isNamedType(type) ? invariant(0, \"Expected \".concat(inspect(type), \" to be a GraphQL named type.\")) : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLScalarType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"serialize\", void 0);\n\n    _defineProperty(this, \"parseValue\", void 0);\n\n    _defineProperty(this, \"parseLiteral\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.serialize = config.serialize;\n\n    this.parseValue = config.parseValue || function (value) {\n      return value;\n    };\n\n    this.parseLiteral = config.parseLiteral || valueFromASTUntyped;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(typeof config.serialize === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar \") + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? invariant(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" \") + 'functions.') : void 0;\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLScalarType);\ndefineToJSON(GraphQLScalarType);\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport var GraphQLObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLObjectType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"isTypeOf\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    _defineProperty(this, \"_interfaces\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.isTypeOf = config.isTypeOf;\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(config.isTypeOf == null || typeof config.isTypeOf === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\")) : void 0;\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLObjectType);\ndefineToJSON(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var interfaces = resolveThunk(config.interfaces) || [];\n  !Array.isArray(interfaces) ? invariant(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns \") + 'an Array.') : void 0;\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  !isPlainObj(fieldMap) ? invariant(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a \") + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n\n  var _arr = Object.keys(fieldMap);\n\n  var _loop = function _loop() {\n    var fieldName = _arr[_i];\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object\")) : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" \") + 'instead of \"isDeprecated\".') : void 0;\n\n    var field = _objectSpread({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n\n    !(field.resolve == null || typeof field.resolve === 'function') ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(field.resolve), \".\")) : void 0;\n    var argsConfig = fieldConfig.args;\n\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument \") + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        var arg = argsConfig[argName];\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n\n    resultFieldMap[fieldName] = field;\n  };\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    _loop();\n  }\n\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n}\n\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport var GraphQLInterfaceType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInterfaceType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"resolveType\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._fields = defineFieldMap.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(config.resolveType == null || typeof config.resolveType === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\")) : void 0;\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInterfaceType);\ndefineToJSON(GraphQLInterfaceType);\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport var GraphQLUnionType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLUnionType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"resolveType\", void 0);\n\n    _defineProperty(this, \"_types\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._types = defineTypes.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n    !(config.resolveType == null || typeof config.resolveType === 'function') ? invariant(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\")) : void 0;\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLUnionType);\ndefineToJSON(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types) || [];\n  !Array.isArray(types) ? invariant(0, 'Must provide Array of types or a function which returns ' + \"such an array for Union \".concat(config.name, \".\")) : void 0;\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport var GraphQLEnumType\n/* <T> */\n=\n/*#__PURE__*/\nfunction () {\n  function GraphQLEnumType(config\n  /* <T> */\n  ) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    _defineProperty(this, \"_valueLookup\", void 0);\n\n    _defineProperty(this, \"_nameLookup\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._values = defineEnumValues(this, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(value\n  /* T */\n  ) {\n    var enumValue = this._valueLookup.get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  _proto5.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this.getValue(value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this.getValue(valueNode.value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLEnumType);\ndefineToJSON(GraphQLEnumType);\n\nfunction defineEnumValues(type, valueMap\n/* <T> */\n) {\n  !isPlainObj(valueMap) ? invariant(0, \"\".concat(type.name, \" values must be an object with value names as keys.\")) : void 0;\n  return Object.keys(valueMap).map(function (valueName) {\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? invariant(0, \"\".concat(type.name, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(value), \".\")) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? invariant(0, \"\".concat(type.name, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead \") + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport var GraphQLInputObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInputObjectType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInputObjectType);\ndefineToJSON(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  !isPlainObj(fieldMap) ? invariant(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a \") + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n\n  var _arr2 = Object.keys(fieldMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var fieldName = _arr2[_i2];\n\n    var field = _objectSpread({}, fieldMap[fieldName], {\n      name: fieldName\n    });\n\n    !!field.hasOwnProperty('resolve') ? invariant(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but \") + 'Input Types cannot define resolvers.') : void 0;\n    resultFieldMap[fieldName] = field;\n  }\n\n  return resultFieldMap;\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}"]},"metadata":{},"sourceType":"module"}