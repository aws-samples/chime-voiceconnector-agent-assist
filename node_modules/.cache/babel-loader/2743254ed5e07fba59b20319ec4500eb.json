{"ast":null,"code":"'use strict';\n\n(function (fn, name) {\n  if (typeof exports !== \"undefined\") {\n    fn(exports, module);\n  } else if (typeof self !== \"undefined\") {\n    var e = name === \"*\" ? self : name ? self[name] = {} : {};\n    fn(e, {\n      exports: e\n    });\n  }\n})(function (exports, module) {\n  // === Symbol Support ===\n  function hasSymbol(name) {\n    return typeof Symbol === \"function\" && Boolean(Symbol[name]);\n  }\n\n  function getSymbol(name) {\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n  } // Ponyfill Symbol.observable for interoperability with other libraries\n\n\n  if (typeof Symbol === \"function\" && !Symbol.observable) {\n    Symbol.observable = Symbol(\"observable\");\n  } // === Abstract Operations ===\n\n\n  function hostReportError(e) {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n\n  function getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) return undefined;\n    if (typeof value !== \"function\") throw new TypeError(value + \" is not a function\");\n    return value;\n  }\n\n  function getSpecies(obj) {\n    var ctor = obj.constructor;\n\n    if (ctor !== undefined) {\n      ctor = ctor[getSymbol(\"species\")];\n\n      if (ctor === null) {\n        ctor = undefined;\n      }\n    }\n\n    return ctor !== undefined ? ctor : Observable;\n  }\n\n  function addMethods(target, methods) {\n    Object.keys(methods).forEach(function (k) {\n      var desc = Object.getOwnPropertyDescriptor(methods, k);\n      desc.enumerable = false;\n      Object.defineProperty(target, k, desc);\n    });\n  }\n\n  function cleanupSubscription(subscription) {\n    // Assert:  observer._observer is undefined\n    var cleanup = subscription._cleanup;\n    if (!cleanup) return; // Drop the reference to the cleanup function so that we won't call it\n    // more than once\n\n    subscription._cleanup = undefined; // Call the cleanup function\n\n    try {\n      cleanup();\n    } catch (e) {\n      hostReportError(e);\n    }\n  }\n\n  function subscriptionClosed(subscription) {\n    return subscription._observer === undefined;\n  }\n\n  function closeSubscription(subscription) {\n    if (subscriptionClosed(subscription)) return;\n    subscription._observer = undefined;\n    cleanupSubscription(subscription);\n  }\n\n  function cleanupFromSubscription(subscription) {\n    return function () {\n      subscription.unsubscribe();\n    };\n  }\n\n  function Subscription(observer, subscriber) {\n    // Assert: subscriber is callable\n    // The observer must be an object\n    if (Object(observer) !== observer) throw new TypeError(\"Observer must be an object\");\n    this._cleanup = undefined;\n    this._observer = observer;\n\n    try {\n      var start$0 = getMethod(observer, \"start\");\n      if (start$0) start$0.call(observer, this);\n    } catch (e) {\n      hostReportError(e);\n    }\n\n    if (subscriptionClosed(this)) return;\n    observer = new SubscriptionObserver(this);\n\n    try {\n      // Call the subscriber function\n      var cleanup$0 = subscriber.call(undefined, observer); // The return value must be undefined, null, a subscription object, or a function\n\n      if (cleanup$0 != null) {\n        if (typeof cleanup$0.unsubscribe === \"function\") cleanup$0 = cleanupFromSubscription(cleanup$0);else if (typeof cleanup$0 !== \"function\") throw new TypeError(cleanup$0 + \" is not a function\");\n        this._cleanup = cleanup$0;\n      }\n    } catch (e) {\n      // If an error occurs during startup, then attempt to send the error\n      // to the observer\n      observer.error(e);\n      return;\n    } // If the stream is already finished, then perform cleanup\n\n\n    if (subscriptionClosed(this)) cleanupSubscription(this);\n  }\n\n  addMethods(Subscription.prototype = {}, {\n    get closed() {\n      return subscriptionClosed(this);\n    },\n\n    unsubscribe: function unsubscribe() {\n      closeSubscription(this);\n    }\n  });\n\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  addMethods(SubscriptionObserver.prototype = {}, {\n    get closed() {\n      return subscriptionClosed(this._subscription);\n    },\n\n    next: function next(value) {\n      var subscription = this._subscription; // If the stream is closed, then return undefined\n\n      if (subscriptionClosed(subscription)) return;\n      var observer = subscription._observer;\n\n      try {\n        // If the observer has a \"next\" method, send the next value\n        var m$0 = getMethod(observer, \"next\");\n        if (m$0) m$0.call(observer, value);\n      } catch (e) {\n        hostReportError(e);\n      }\n    },\n    error: function error(value) {\n      var subscription = this._subscription; // If the stream is closed, throw the error to the caller\n\n      if (subscriptionClosed(subscription)) {\n        hostReportError(value);\n        return;\n      }\n\n      var observer = subscription._observer;\n      subscription._observer = undefined;\n\n      try {\n        var m$1 = getMethod(observer, \"error\");\n        if (m$1) m$1.call(observer, value);else throw value;\n      } catch (e) {\n        hostReportError(e);\n      }\n\n      cleanupSubscription(subscription);\n    },\n    complete: function complete() {\n      var subscription = this._subscription;\n      if (subscriptionClosed(subscription)) return;\n      var observer = subscription._observer;\n      subscription._observer = undefined;\n\n      try {\n        var m$2 = getMethod(observer, \"complete\");\n        if (m$2) m$2.call(observer);\n      } catch (e) {\n        hostReportError(e);\n      }\n\n      cleanupSubscription(subscription);\n    }\n  });\n\n  function Observable(subscriber) {\n    // Constructor cannot be called as a function\n    if (!(this instanceof Observable)) throw new TypeError(\"Observable cannot be called as a function\"); // The stream subscriber must be a function\n\n    if (typeof subscriber !== \"function\") throw new TypeError(\"Observable initializer must be a function\");\n    this._subscriber = subscriber;\n  }\n\n  addMethods(Observable.prototype, {\n    subscribe: function subscribe(observer) {\n      for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]);\n\n      if (typeof observer === 'function') {\n        observer = {\n          next: observer,\n          error: args[0],\n          complete: args[1]\n        };\n      } else if (typeof observer !== 'object' || observer === null) {\n        observer = {};\n      }\n\n      return new Subscription(observer, this._subscriber);\n    },\n    forEach: function forEach(fn) {\n      var __this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== \"function\") return Promise.reject(new TypeError(fn + \" is not a function\"));\n\n        __this.subscribe({\n          _subscription: null,\n          start: function start(subscription) {\n            if (Object(subscription) !== subscription) throw new TypeError(subscription + \" is not an object\");\n            this._subscription = subscription;\n          },\n          next: function next(value) {\n            var subscription = this._subscription;\n            if (subscription.closed) return;\n\n            try {\n              fn(value);\n            } catch (err) {\n              reject(err);\n              subscription.unsubscribe();\n            }\n          },\n          error: reject,\n          complete: resolve\n        });\n      });\n    },\n    map: function map(fn) {\n      var __this = this;\n\n      if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return __this.subscribe({\n          next: function next(value) {\n            if (observer.closed) return;\n\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    },\n    filter: function filter(fn) {\n      var __this = this;\n\n      if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return __this.subscribe({\n          next: function next(value) {\n            if (observer.closed) return;\n\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    },\n    reduce: function reduce(fn) {\n      var __this = this;\n\n      if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n      return new C(function (observer) {\n        return __this.subscribe({\n          next: function next(value) {\n            if (observer.closed) return;\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            if (!hasValue && !hasSeed) {\n              return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n            }\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  });\n  Object.defineProperty(Observable.prototype, getSymbol(\"observable\"), {\n    value: function value() {\n      return this;\n    },\n    writable: true,\n    configurable: true\n  });\n  addMethods(Observable, {\n    from: function from(x) {\n      var C = typeof this === \"function\" ? this : Observable;\n      if (x == null) throw new TypeError(x + \" is not an object\");\n      var method = getMethod(x, getSymbol(\"observable\"));\n\n      if (method) {\n        var observable$0 = method.call(x);\n        if (Object(observable$0) !== observable$0) throw new TypeError(observable$0 + \" is not an object\");\n        if (observable$0.constructor === C) return observable$0;\n        return new C(function (observer) {\n          return observable$0.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol(\"iterator\") && (method = getMethod(x, getSymbol(\"iterator\")))) {\n        return new C(function (observer) {\n          for (var __$0 = method.call(x)[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) {\n            var item$0 = __$1.value;\n            observer.next(item$0);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          for (var i$0 = 0; i$0 < x.length; ++i$0) {\n            observer.next(x[i$0]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      }\n\n      throw new TypeError(x + \" is not observable\");\n    },\n    of: function of() {\n      for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) items.push(arguments[__$0]);\n\n      var C = typeof this === \"function\" ? this : Observable;\n      return new C(function (observer) {\n        for (var i$1 = 0; i$1 < items.length; ++i$1) {\n          observer.next(items[i$1]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    }\n  });\n  Object.defineProperty(Observable, getSymbol(\"species\"), {\n    get: function get() {\n      return this;\n    },\n    configurable: true\n  });\n  Object.defineProperty(Observable, \"extensions\", {\n    value: {\n      observableSymbol: getSymbol(\"observable\"),\n      setHostReportError: function setHostReportError(fn) {\n        hostReportError = fn;\n      }\n    }\n  });\n  exports.Observable = Observable;\n}, \"*\");","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/zen-push/node_modules/zen-observable/zen-observable.js"],"names":["fn","name","exports","module","self","e","hasSymbol","Symbol","Boolean","getSymbol","observable","hostReportError","setTimeout","getMethod","obj","key","value","undefined","TypeError","getSpecies","ctor","constructor","Observable","addMethods","target","methods","Object","keys","forEach","k","desc","getOwnPropertyDescriptor","enumerable","defineProperty","cleanupSubscription","subscription","cleanup","_cleanup","subscriptionClosed","_observer","closeSubscription","cleanupFromSubscription","unsubscribe","Subscription","observer","subscriber","start$0","call","SubscriptionObserver","cleanup$0","error","prototype","closed","_subscription","next","m$0","m$1","complete","m$2","_subscriber","subscribe","args","__$0","arguments","length","push","__this","Promise","resolve","reject","start","err","map","C","filter","reduce","hasSeed","hasValue","seed","acc","first","writable","configurable","from","x","method","observable$0","iterator","__$1","done","item$0","Array","isArray","i$0","of","items","i$1","get","observableSymbol","setHostReportError"],"mappings":"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","sourcesContent":["'use strict'; (function(fn, name) { if (typeof exports !== \"undefined\") { fn(exports, module); } else if (typeof self !== \"undefined\") { var e = name === \"*\" ? self : (name ? self[name] = {} : {}); fn(e, { exports: e }); } })(function(exports, module) { // === Symbol Support ===\n\nfunction hasSymbol(name) {\n  return typeof Symbol === \"function\" && Boolean(Symbol[name]);\n}\n\nfunction getSymbol(name) {\n  return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n}\n\n// Ponyfill Symbol.observable for interoperability with other libraries\nif (typeof Symbol === \"function\" && !Symbol.observable) {\n  Symbol.observable = Symbol(\"observable\");\n}\n\n// === Abstract Operations ===\n\nfunction hostReportError(e) {\n  setTimeout(function() { throw e });\n}\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null)\n    return undefined;\n\n  if (typeof value !== \"function\")\n    throw new TypeError(value + \" is not a function\");\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[getSymbol(\"species\")];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction addMethods(target, methods) {\n  Object.keys(methods).forEach(function(k) {\n    var desc = Object.getOwnPropertyDescriptor(methods, k);\n    desc.enumerable = false;\n    Object.defineProperty(target, k, desc);\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  // Assert:  observer._observer is undefined\n\n  var cleanup = subscription._cleanup;\n\n  if (!cleanup)\n    return;\n\n  // Drop the reference to the cleanup function so that we won't call it\n  // more than once\n  subscription._cleanup = undefined;\n\n  // Call the cleanup function\n  try { cleanup() }\n  catch (e) { hostReportError(e) }\n}\n\nfunction subscriptionClosed(subscription) {\n  return subscription._observer === undefined;\n}\n\nfunction closeSubscription(subscription) {\n  if (subscriptionClosed(subscription))\n    return;\n\n  subscription._observer = undefined;\n  cleanupSubscription(subscription);\n}\n\nfunction cleanupFromSubscription(subscription) {\n  return function() { subscription.unsubscribe() };\n}\n\nfunction Subscription(observer, subscriber) {\n  // Assert: subscriber is callable\n\n  // The observer must be an object\n  if (Object(observer) !== observer)\n    throw new TypeError(\"Observer must be an object\");\n\n  this._cleanup = undefined;\n  this._observer = observer;\n\n  try {\n    var start$0 = getMethod(observer, \"start\");\n    if (start$0) start$0.call(observer, this);\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscriptionClosed(this))\n    return;\n\n  observer = new SubscriptionObserver(this);\n\n  try {\n    // Call the subscriber function\n    var cleanup$0 = subscriber.call(undefined, observer);\n\n    // The return value must be undefined, null, a subscription object, or a function\n    if (cleanup$0 != null) {\n      if (typeof cleanup$0.unsubscribe === \"function\")\n        cleanup$0 = cleanupFromSubscription(cleanup$0);\n      else if (typeof cleanup$0 !== \"function\")\n        throw new TypeError(cleanup$0 + \" is not a function\");\n\n      this._cleanup = cleanup$0;\n    }\n  } catch (e) {\n    // If an error occurs during startup, then attempt to send the error\n    // to the observer\n    observer.error(e);\n    return;\n  }\n\n  // If the stream is already finished, then perform cleanup\n  if (subscriptionClosed(this))\n    cleanupSubscription(this);\n}\n\naddMethods(Subscription.prototype = {}, {\n  get closed() { return subscriptionClosed(this) },\n  unsubscribe: function() { closeSubscription(this) },\n});\n\nfunction SubscriptionObserver(subscription) {\n  this._subscription = subscription;\n}\n\naddMethods(SubscriptionObserver.prototype = {}, {\n\n  get closed() { return subscriptionClosed(this._subscription) },\n\n  next: function(value) {\n    var subscription = this._subscription;\n\n    // If the stream is closed, then return undefined\n    if (subscriptionClosed(subscription))\n      return;\n\n    var observer = subscription._observer;\n\n    try {\n      // If the observer has a \"next\" method, send the next value\n      var m$0 = getMethod(observer, \"next\");\n      if (m$0) m$0.call(observer, value);\n    } catch (e) {\n      hostReportError(e);\n    }\n  },\n\n  error: function(value) {\n    var subscription = this._subscription;\n\n    // If the stream is closed, throw the error to the caller\n    if (subscriptionClosed(subscription)) {\n      hostReportError(value);\n      return;\n    }\n\n    var observer = subscription._observer;\n    subscription._observer = undefined;\n\n    try {\n      var m$1 = getMethod(observer, \"error\");\n      if (m$1) m$1.call(observer, value);\n      else throw value;\n    } catch (e) {\n      hostReportError(e);\n    }\n\n    cleanupSubscription(subscription);\n  },\n\n  complete: function() {\n    var subscription = this._subscription;\n\n    if (subscriptionClosed(subscription))\n      return;\n\n    var observer = subscription._observer;\n    subscription._observer = undefined;\n\n    try {\n      var m$2 = getMethod(observer, \"complete\");\n      if (m$2) m$2.call(observer);\n    } catch (e) {\n      hostReportError(e);\n    }\n\n    cleanupSubscription(subscription);\n  },\n\n});\n\nfunction Observable(subscriber) {\n  // Constructor cannot be called as a function\n  if (!(this instanceof Observable))\n    throw new TypeError(\"Observable cannot be called as a function\");\n\n  // The stream subscriber must be a function\n  if (typeof subscriber !== \"function\")\n    throw new TypeError(\"Observable initializer must be a function\");\n\n  this._subscriber = subscriber;\n}\n\naddMethods(Observable.prototype, {\n\n  subscribe: function(observer) { for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); \n    if (typeof observer === 'function') {\n      observer = {\n        next: observer,\n        error: args[0],\n        complete: args[1],\n      };\n    } else if (typeof observer !== 'object' || observer === null) {\n      observer = {};\n    }\n\n    return new Subscription(observer, this._subscriber);\n  },\n\n  forEach: function(fn) { var __this = this; \n    return new Promise(function(resolve, reject) {\n      if (typeof fn !== \"function\")\n        return Promise.reject(new TypeError(fn + \" is not a function\"));\n\n      __this.subscribe({\n        _subscription: null,\n\n        start: function(subscription) {\n          if (Object(subscription) !== subscription)\n            throw new TypeError(subscription + \" is not an object\");\n\n          this._subscription = subscription;\n        },\n\n        next: function(value) {\n          var subscription = this._subscription;\n\n          if (subscription.closed)\n            return;\n\n          try {\n            fn(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        },\n\n        error: reject,\n        complete: resolve,\n      });\n    });\n  },\n\n  map: function(fn) { var __this = this; \n    if (typeof fn !== \"function\")\n      throw new TypeError(fn + \" is not a function\");\n\n    var C = getSpecies(this);\n\n    return new C(function(observer) { return __this.subscribe({\n      next: function(value) {\n        if (observer.closed)\n          return;\n\n        try { value = fn(value) }\n        catch (e) { return observer.error(e) }\n\n        observer.next(value);\n      },\n\n      error: function(e) { observer.error(e) },\n      complete: function() { observer.complete() },\n    }); });\n  },\n\n  filter: function(fn) { var __this = this; \n    if (typeof fn !== \"function\")\n      throw new TypeError(fn + \" is not a function\");\n\n    var C = getSpecies(this);\n\n    return new C(function(observer) { return __this.subscribe({\n      next: function(value) {\n        if (observer.closed)\n          return;\n\n        try { if (!fn(value)) return }\n        catch (e) { return observer.error(e) }\n\n        observer.next(value);\n      },\n\n      error: function(e) { observer.error(e) },\n      complete: function() { observer.complete() },\n    }); });\n  },\n\n  reduce: function(fn) { var __this = this; \n    if (typeof fn !== \"function\")\n      throw new TypeError(fn + \" is not a function\");\n\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n\n    return new C(function(observer) { return __this.subscribe({\n\n      next: function(value) {\n        if (observer.closed)\n          return;\n\n        var first = !hasValue;\n        hasValue = true;\n\n        if (!first || hasSeed) {\n          try { acc = fn(acc, value) }\n          catch (e) { return observer.error(e) }\n        } else {\n          acc = value;\n        }\n      },\n\n      error: function(e) { observer.error(e) },\n\n      complete: function() {\n        if (!hasValue && !hasSeed) {\n          return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n        }\n\n        observer.next(acc);\n        observer.complete();\n      },\n\n    }); });\n  },\n\n});\n\nObject.defineProperty(Observable.prototype, getSymbol(\"observable\"), {\n  value: function() { return this },\n  writable: true,\n  configurable: true,\n});\n\naddMethods(Observable, {\n\n  from: function(x) {\n    var C = typeof this === \"function\" ? this : Observable;\n\n    if (x == null)\n      throw new TypeError(x + \" is not an object\");\n\n    var method = getMethod(x, getSymbol(\"observable\"));\n\n    if (method) {\n      var observable$0 = method.call(x);\n\n      if (Object(observable$0) !== observable$0)\n        throw new TypeError(observable$0 + \" is not an object\");\n\n      if (observable$0.constructor === C)\n        return observable$0;\n\n      return new C(function(observer) { return observable$0.subscribe(observer); });\n    }\n\n    if (hasSymbol(\"iterator\") && (method = getMethod(x, getSymbol(\"iterator\")))) {\n      return new C(function(observer) {\n        for (var __$0 = (method.call(x))[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) { var item$0 = __$1.value; \n          observer.next(item$0);\n          if (observer.closed)\n            return;\n        }\n\n        observer.complete();\n      });\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function(observer) {\n        for (var i$0 = 0; i$0 < x.length; ++i$0) {\n          observer.next(x[i$0]);\n          if (observer.closed)\n            return;\n        }\n\n        observer.complete();\n      });\n    }\n\n    throw new TypeError(x + \" is not observable\");\n  },\n\n  of: function() { for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) items.push(arguments[__$0]); \n    var C = typeof this === \"function\" ? this : Observable;\n\n    return new C(function(observer) {\n      for (var i$1 = 0; i$1 < items.length; ++i$1) {\n        observer.next(items[i$1]);\n        if (observer.closed)\n          return;\n      }\n\n      observer.complete();\n    });\n  },\n\n});\n\nObject.defineProperty(Observable, getSymbol(\"species\"), {\n  get: function() { return this },\n  configurable: true,\n});\n\nObject.defineProperty(Observable, \"extensions\", {\n  value: {\n    observableSymbol: getSymbol(\"observable\"),\n    setHostReportError: function(fn) { hostReportError = fn },\n  },\n});\n\nexports.Observable = Observable;\n\n\n}, \"*\");"]},"metadata":{},"sourceType":"script"}