{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/validation/rules/PossibleFragmentSpreads.mjs"],"names":["inspect","GraphQLError","doTypesOverlap","typeFromAST","isCompositeType","typeIncompatibleSpreadMessage","fragName","parentType","fragType","concat","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"mappings":"AAAA;;;;;;;;AAQA,OAAOA,OAAP,MAAoB,uBAApB;AACA,SAASC,YAAT,QAA6B,0BAA7B;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,OAAO,SAASC,6BAAT,CAAuCC,QAAvC,EAAiDC,UAAjD,EAA6DC,QAA7D,EAAuE;AAC5E,SAAO,cAAcC,MAAd,CAAqBH,QAArB,EAA+B,yCAA/B,IAA4E,UAAUG,MAAV,CAAiBF,UAAjB,EAA6B,4BAA7B,EAA2DE,MAA3D,CAAkED,QAAlE,EAA4E,KAA5E,CAAnF;AACD;AACD,OAAO,SAASE,iCAAT,CAA2CH,UAA3C,EAAuDC,QAAvD,EAAiE;AACtE,SAAO,kDAAkD,UAAUC,MAAV,CAAiBF,UAAjB,EAA6B,4BAA7B,EAA2DE,MAA3D,CAAkED,QAAlE,EAA4E,KAA5E,CAAzD;AACD;AACD;;;;;;;;AAQA,OAAO,SAASG,uBAAT,CAAiCC,OAAjC,EAA0C;AAC/C,SAAO;AACLC,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;AAC5C,UAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAR,EAAf;AACA,UAAIR,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AAEA,UAAIZ,eAAe,CAACI,QAAD,CAAf,IAA6BJ,eAAe,CAACG,UAAD,CAA5C,IAA4D,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA/E,EAA4H;AAC1HK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBS,iCAAiC,CAACV,OAAO,CAACO,UAAD,CAAR,EAAsBP,OAAO,CAACQ,QAAD,CAA7B,CAAlD,EAA4F,CAACM,IAAD,CAA5F,CAApB;AACD;AACF,KARI;AASLK,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBL,IAAxB,EAA8B;AAC5C,UAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAL,CAAUC,KAAzB;AACA,UAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAD,EAAUN,QAAV,CAA9B;AACA,UAAIC,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AAEA,UAAIR,QAAQ,IAAID,UAAZ,IAA0B,CAACL,cAAc,CAACU,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA7C,EAA0F;AACxFK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBI,6BAA6B,CAACC,QAAD,EAAWN,OAAO,CAACO,UAAD,CAAlB,EAAgCP,OAAO,CAACQ,QAAD,CAAvC,CAA9C,EAAkG,CAACM,IAAD,CAAlG,CAApB;AACD;AACF;AAjBI,GAAP;AAmBD;;AAED,SAASQ,eAAT,CAAyBV,OAAzB,EAAkCQ,IAAlC,EAAwC;AACtC,MAAIG,IAAI,GAAGX,OAAO,CAACY,WAAR,CAAoBJ,IAApB,CAAX;;AAEA,MAAIG,IAAJ,EAAU;AACR,QAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAR,EAAD,EAAsBM,IAAI,CAACG,aAA3B,CAAtB;;AAEA,QAAItB,eAAe,CAACqB,IAAD,CAAnB,EAA2B;AACzB,aAAOA,IAAP;AACD;AACF;AACF","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { isCompositeType } from '../../type/definition';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}