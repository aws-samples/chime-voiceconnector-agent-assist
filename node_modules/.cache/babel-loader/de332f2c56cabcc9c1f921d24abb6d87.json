{"ast":null,"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr = Object.keys(oldTypeMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr2 = Object.keys(oldTypeMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr3 = Object.keys(oldTypeMap);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    var _arr4 = Object.keys(oldTypeFields);\n\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n\n            if (isRequiredArgument(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr5 = Object.keys(oldTypeMap);\n\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6]; // Check if the field is missing on the type in the new schema.\n\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr7 = Object.keys(oldTypeMap);\n\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8]; // Check if the field is missing on the type in the new schema.\n\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if (isRequiredInputField(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n\n  var _arr10 = Object.keys(oldTypeMap);\n\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n\n  var _arr11 = Object.keys(newTypeMap);\n\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n\n  var _arr12 = Object.keys(oldTypeMap);\n\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n\n  var _arr13 = Object.keys(oldTypeMap);\n\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr14 = Object.keys(oldTypeMap);\n\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  var _arr15 = Object.keys(newTypeMap);\n\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n\n          if (isRequiredArgument(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}","map":{"version":3,"sources":["/home/ec2-user/chime-voiceconnector-agent-assist/node_modules/graphql/utilities/findBreakingChanges.mjs"],"names":["isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isListType","isNamedType","isRequiredArgument","isRequiredInputField","keyMap","BreakingChangeType","FIELD_CHANGED_KIND","FIELD_REMOVED","TYPE_CHANGED_KIND","TYPE_REMOVED","TYPE_REMOVED_FROM_UNION","VALUE_REMOVED_FROM_ENUM","ARG_REMOVED","ARG_CHANGED_KIND","REQUIRED_ARG_ADDED","REQUIRED_INPUT_FIELD_ADDED","INTERFACE_REMOVED_FROM_OBJECT","DIRECTIVE_REMOVED","DIRECTIVE_ARG_REMOVED","DIRECTIVE_LOCATION_REMOVED","REQUIRED_DIRECTIVE_ARG_ADDED","DangerousChangeType","ARG_DEFAULT_VALUE_CHANGE","VALUE_ADDED_TO_ENUM","INTERFACE_ADDED_TO_OBJECT","TYPE_ADDED_TO_UNION","OPTIONAL_INPUT_FIELD_ADDED","OPTIONAL_ARG_ADDED","findBreakingChanges","oldSchema","newSchema","findRemovedTypes","concat","findTypesThatChangedKind","findFieldsThatChangedTypeOnObjectOrInterfaceTypes","findFieldsThatChangedTypeOnInputObjectTypes","breakingChanges","findTypesRemovedFromUnions","findValuesRemovedFromEnums","findArgChanges","findInterfacesRemovedFromObjectTypes","findRemovedDirectives","findRemovedDirectiveArgs","findAddedNonNullDirectiveArgs","findRemovedDirectiveLocations","findDangerousChanges","dangerousChanges","findValuesAddedToEnums","findInterfacesAddedToObjectTypes","findTypesAddedToUnions","oldTypeMap","getTypeMap","newTypeMap","_arr","Object","keys","_i","length","typeName","push","type","description","_arr2","_i2","oldType","newType","constructor","typeKindName","_arr3","_i3","oldTypeFields","getFields","newTypeFields","_arr4","_i4","fieldName","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_loop","oldArgDef","_step","value","newArgs","args","newArgDef","find","arg","name","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","toString","defaultValue","_iterator","Symbol","iterator","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_loop2","_step2","oldArgs","argName","_iterator2","TypeError","_arr5","_i5","oldTypeFieldsDef","newTypeFieldsDef","_arr6","_i6","oldFieldType","newFieldType","isChangeSafeForObjectOrInterfaceField","oldFieldTypeString","newFieldTypeString","_arr7","_i7","_arr8","_i8","_arr9","_i9","_fieldName","ofType","typesRemovedFromUnion","_arr10","_i10","typeNamesInNewUnion","create","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","getTypes","_step3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_type","typesAddedToUnion","_arr11","_i11","typeNamesInOldUnion","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_type2","valuesRemovedFromEnums","_arr12","_i12","valuesInNewEnum","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","getValues","_step7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_value","valuesAddedToEnums","_arr13","_i13","valuesInOldEnum","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_value2","_arr14","_i14","oldInterfaces","getInterfaces","newInterfaces","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_loop3","oldInterface","_step11","some","int","_iterator11","interfacesAddedToObjectTypes","_arr15","_i15","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_loop4","newInterface","_step12","_iterator12","removedDirectives","newSchemaDirectiveMap","getDirectiveMapForSchema","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","getDirectives","_step13","directive","findRemovedArgsForDirective","oldDirective","newDirective","removedArgs","newArgMap","getArgumentMapForDirective","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","removedDirectiveArgs","oldSchemaDirectiveMap","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_iterator15","_step15","_iteratorNormalCompletion16","_didIteratorError16","_iteratorError16","_iterator16","_step16","findAddedArgsForDirective","addedArgs","oldArgMap","_iteratorNormalCompletion17","_didIteratorError17","_iteratorError17","_iterator17","_step17","addedNonNullableArgs","_iteratorNormalCompletion18","_didIteratorError18","_iteratorError18","_iterator18","_step18","_iteratorNormalCompletion19","_didIteratorError19","_iteratorError19","_iterator19","_step19","findRemovedLocationsForDirective","removedLocations","newLocationSet","Set","locations","_iteratorNormalCompletion20","_didIteratorError20","_iteratorError20","_iterator20","_step20","oldLocation","has","_iteratorNormalCompletion21","_didIteratorError21","_iteratorError21","_iterator21","_step21","_iteratorNormalCompletion22","_didIteratorError22","_iteratorError22","_iterator22","_step22","location","schema","dir"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition';\nimport keyMap from '../jsutils/keyMap';\nexport var BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexport var DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\nexport function findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr = Object.keys(oldTypeMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\nexport function findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr2 = Object.keys(oldTypeMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\nexport function findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr3 = Object.keys(oldTypeMap);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    var _arr4 = Object.keys(oldTypeFields);\n\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n\n            if (isRequiredArgument(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nexport function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr5 = Object.keys(oldTypeMap);\n\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr7 = Object.keys(oldTypeMap);\n\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = isNamedType(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = isNamedType(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if (isRequiredInputField(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isNamedType(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isNamedType(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return isNamedType(newType) && oldType.name === newType.name;\n  } else if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nexport function findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n\n  var _arr10 = Object.keys(oldTypeMap);\n\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\nexport function findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n\n  var _arr11 = Object.keys(newTypeMap);\n\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isUnionType(oldType) || !isUnionType(newType)) {\n      continue;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\nexport function findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n\n  var _arr12 = Object.keys(oldTypeMap);\n\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\nexport function findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n\n  var _arr13 = Object.keys(oldTypeMap);\n\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isEnumType(oldType) || !isEnumType(newType)) {\n      continue;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n\n  return valuesAddedToEnums;\n}\nexport function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr14 = Object.keys(oldTypeMap);\n\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\nexport function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  var _arr15 = Object.keys(newTypeMap);\n\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!isObjectType(oldType) || !isObjectType(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n\n  return interfacesAddedToObjectTypes;\n}\nexport function findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  return removedArgs;\n}\n\nexport function findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n\n  return addedArgs;\n}\n\nexport function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n\n          if (isRequiredArgument(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n\n  return addedNonNullableArgs;\n}\nexport function findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n\n  return removedLocations;\n}\nexport function findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return keyMap(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return keyMap(directive.args, function (arg) {\n    return arg.name;\n  });\n}"]},"metadata":{},"sourceType":"module"}