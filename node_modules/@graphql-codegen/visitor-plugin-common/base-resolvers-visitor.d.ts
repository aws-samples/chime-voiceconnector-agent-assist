import { ParsedConfig, RawConfig, BaseVisitor } from './base-visitor';
import { NormalizedScalarsMap, EnumValuesMap, ParsedEnumValuesMap } from './types';
import { DeclarationBlockConfig } from './utils';
import { NameNode, ListTypeNode, NamedTypeNode, FieldDefinitionNode, ObjectTypeDefinitionNode, GraphQLSchema, NonNullTypeNode, UnionTypeDefinitionNode, ScalarTypeDefinitionNode, InterfaceTypeDefinitionNode, GraphQLNamedType } from 'graphql';
import { DirectiveDefinitionNode, InputValueDefinitionNode, GraphQLOutputType } from 'graphql';
import { OperationVariablesToObject } from './variables-to-object';
import { ParsedMapper } from './mappers';
import { ApolloFederation } from '@graphql-codegen/plugin-helpers';
export interface ParsedResolversConfig extends ParsedConfig {
    contextType: ParsedMapper;
    fieldContextTypes: Array<string>;
    rootValueType: ParsedMapper;
    mappers: {
        [typeName: string]: ParsedMapper;
    };
    defaultMapper: ParsedMapper | null;
    avoidOptionals: boolean;
    addUnderscoreToArgsType: boolean;
    enumValues: ParsedEnumValuesMap;
    resolverTypeWrapperSignature: string;
    federation: boolean;
    enumPrefix: boolean;
    optionalResolveType: boolean;
    immutableTypes: boolean;
}
export interface RawResolversConfig extends RawConfig {
    /**
     * @name addUnderscoreToArgsType
     * @type boolean
     * @description Adds `_` to generated `Args` types in order to avoid duplicate identifiers.
     *
     * @example With Custom Values
     * ```yml
     *   config:
     *     addUnderscoreToArgsType: true
     * ```
     *
     */
    addUnderscoreToArgsType?: boolean;
    /**
     * @name contextType
     * @type string
     * @description Use this configuration to set a custom type for your `context`, and it will
     * effect all the resolvers, without the need to override it using generics each time.
     * If you wish to use an external type and import it from another file, you can use `add` plugin
     * and add the required `import` statement, or you can use a `module#type` syntax.
     *
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     contextType: MyContext
     * ```
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     contextType: ./my-types#MyContext
     * ```
     */
    contextType?: string;
    /**
     * @name fieldContextTypes
     * @type string array
     * @description Use this to set a custom type for a specific field `context`.
     * It will only affect the targeted resolvers.
     * You can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`
     *
     * @example Custom Field Context Types
     * ```
     * plugins
     *   config:
     *     fieldContextTypes:
     *       - MyType.foo#CustomContextType
     *       - MyType.bar#./my-file#ContextTypeOne
     * ```
     *
     */
    fieldContextTypes?: Array<string>;
    /**
     * @name rootValueType
     * @type string
     * @description Use this configuration to set a custom type for the `rootValue`, and it will
     * effect resolvers of all root types (Query, Mutation and Subscription), without the need to override it using generics each time.
     * If you wish to use an external type and import it from another file, you can use `add` plugin
     * and add the required `import` statement, or you can use both `module#type` or `module#namespace#type` syntax.
     *
     * @example Custom RootValue Type
     * ```yml
     * plugins
     *   config:
     *     rootValueType: MyRootValue
     * ```
     * @example Custom RootValue Type
     * ```yml
     * plugins
     *   config:
     *     rootValueType: ./my-types#MyRootValue
     * ```
     */
    rootValueType?: string;
    /**
     * @name mappers
     * @type Object
     * @description Replaces a GraphQL type usage with a custom type, allowing you to return custom object from
     * your resolvers.
     * You can use both `module#type` and `module#namespace#type` syntax.
     *
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     mappers:
     *       User: ./my-models#UserDbObject
     *       Book: ./my-models#Collections#Book
     * ```
     */
    mappers?: {
        [typeName: string]: string;
    };
    /**
     * @name defaultMapper
     * @type string
     * @description Allow you to set the default mapper when it's not being override by `mappers` or generics.
     * You can specify a type name, or specify a string in `module#type` or `module#namespace#type` format.
     * The defualt value of mappers it the TypeScript type generated by `typescript` package.
     *
     * @example Replace with any
     * ```yml
     * plugins
     *   config:
     *     defaultMapper: any
     * ```
     *
     * @example Custom Base Object
     * ```yml
     * plugins
     *   config:
     *     defaultMapper: ./my-file#BaseObject
     * ```
     *
     * @example Wrap default types with Partial
     * You can also specify a custom wrapper for the original type, without overring the original generated types, use "{T}" to specify the identifier. (for flow, use `$Shape<{T}>`)
     * ```yml
     * plugins
     *   config:
     *     defaultMapper: Partial<{T}>
     * ```
     */
    defaultMapper?: string;
    /**
     * @name avoidOptionals
     * @type boolean
     * @description This will cause the generator to avoid using TypeScript optionals (`?`),
     * so all field resolvers must be implemented in order to avoid compilation errors.
     *
     * @default false
     *
     * @example
     * ```yml
     * generates:
     * path/to/file.ts:
     *  plugins:
     *    - typescript
     *    - typescript-resolvers
     *  config:
     *    avoidOptionals: true
     * ```
     */
    avoidOptionals?: boolean;
    /**
     * @name showUnusedMappers
     * @type boolean
     * @description Warns about unused mappers.
     * @default true
     *
     * @example
     * ```yml
     * generates:
     * path/to/file.ts:
     *  plugins:
     *    - typescript
     *    - typescript-resolvers
     *  config:
     *    showUnusedMappers: true
     * ```
     */
    showUnusedMappers?: boolean;
    /**
     * @name enumValues
     * @type EnumValuesMap
     * @description Overrides the default value of enum values declared in your GraphQL schema, supported
     * in this plugin because of the need for integeration with `typescript` package.
     * See documentation under `typescript` plugin for more information and examples.
     *
     */
    enumValues?: EnumValuesMap;
    /**
     * @name resolverTypeWrapperSignature
     * @type string
     * @default Promise<T> | T
     * @description Allow you to override `resolverTypeWrapper` definition.
     *
     */
    resolverTypeWrapperSignature?: string;
    /**
     * @name federation
     * @type boolean
     * @default false
     * @description Supports Apollo Federation
     *
     */
    federation?: boolean;
    /**
     * @name enumPrefix
     * @type boolean
     * @default true
     * @description Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.
     *
     * @example Disable enum prefixes
     * ```yml
     *   config:
     *     typesPrefix: I
     *     enumPrefix: false
     * ```
     */
    enumPrefix?: boolean;
    /**
     * @name optionalResolveType
     * @type boolean
     * @default false
     * @description Sets the `__resolveType` field as optional field.
     */
    optionalResolveType?: boolean;
    /**
     * @name immutableTypes
     * @type boolean
     * @default false
     * @description Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.
     */
    immutableTypes?: boolean;
}
export declare type ResolverTypes = {
    [gqlType: string]: string;
};
export declare type ResolverParentTypes = {
    [gqlType: string]: string;
};
export declare type GroupedMappers = Record<string, {
    identifier: string;
    asDefault?: boolean;
}[]>;
declare type FieldContextTypeMap = Record<string, ParsedMapper>;
export declare class BaseResolversVisitor<TRawConfig extends RawResolversConfig = RawResolversConfig, TPluginConfig extends ParsedResolversConfig = ParsedResolversConfig> extends BaseVisitor<TRawConfig, TPluginConfig> {
    private _schema;
    protected _parsedConfig: TPluginConfig;
    protected _declarationBlockConfig: DeclarationBlockConfig;
    protected _collectedResolvers: {
        [key: string]: string;
    };
    protected _collectedDirectiveResolvers: {
        [key: string]: string;
    };
    protected _variablesTransfomer: OperationVariablesToObject;
    protected _usedMappers: {
        [key: string]: boolean;
    };
    protected _resolversTypes: ResolverTypes;
    protected _resolversParentTypes: ResolverParentTypes;
    protected _rootTypeNames: string[];
    protected _globalDeclarations: Set<string>;
    protected _federation: ApolloFederation;
    protected _hasScalars: boolean;
    protected _hasFederation: boolean;
    protected _fieldContextTypeMap: FieldContextTypeMap;
    constructor(rawConfig: TRawConfig, additionalConfig: TPluginConfig, _schema: GraphQLSchema, defaultScalars?: NormalizedScalarsMap);
    getResolverTypeWrapperSignature(): string;
    protected shouldMapType(type: GraphQLNamedType, checkedBefore?: {
        [typeName: string]: boolean;
    }, duringCheck?: string[]): boolean;
    protected createResolversFields(applyWrapper: (str: string) => string, clearWrapper: (str: string) => string, getTypeToUse: (str: string) => string): ResolverTypes;
    protected replaceFieldsInType(typeName: string, relevantFields: {
        addOptionalSign: boolean;
        fieldName: string;
        replaceWithType: string;
    }[]): string;
    protected applyMaybe(str: string): string;
    protected applyResolverTypeWrapper(str: string): string;
    protected clearMaybe(str: string): string;
    protected clearResolverTypeWrapper(str: string): string;
    protected wrapWithArray(t: string): string;
    protected wrapTypeWithModifiers(baseType: string, type: GraphQLOutputType): string;
    protected createFieldContextTypeMap(): FieldContextTypeMap;
    buildResolversTypes(): string;
    buildResolversParentTypes(): string;
    get schema(): GraphQLSchema;
    get defaultMapperType(): string;
    get unusedMappers(): string[];
    get globalDeclarations(): string[];
    protected isMapperImported(groupedMappers: GroupedMappers, identifier: string, source: string): boolean;
    get mappersImports(): string[];
    protected buildMapperImport(source: string, types: {
        identifier: string;
        asDefault?: boolean;
    }[]): string | null;
    setDeclarationBlockConfig(config: DeclarationBlockConfig): void;
    setVariablesTransformer(variablesTransfomer: OperationVariablesToObject): void;
    hasScalars(): boolean;
    hasFederation(): boolean;
    getRootResolver(): string;
    protected formatRootResolver(schemaTypeName: string, resolverType: string): string;
    getAllDirectiveResolvers(): string;
    Name(node: NameNode): string;
    ListType(node: ListTypeNode): string;
    protected _getScalar(name: string): string;
    NamedType(node: NamedTypeNode): string;
    NonNullType(node: NonNullTypeNode): string;
    protected markMapperAsUsed(name: string): void;
    protected getTypeToUse(name: string): string;
    protected getParentTypeToUse(name: string): string;
    protected transformParentGenericType(parentType: string): string;
    FieldDefinition(node: FieldDefinitionNode, key: string | number, parent: any): (parentName: string) => string;
    protected applyRequireFields(argsType: string, fields: InputValueDefinitionNode[]): string;
    ObjectTypeDefinition(node: ObjectTypeDefinitionNode): string;
    UnionTypeDefinition(node: UnionTypeDefinitionNode, key: string | number, parent: any): string;
    ScalarTypeDefinition(node: ScalarTypeDefinitionNode): string;
    DirectiveDefinition(node: DirectiveDefinitionNode, key: any, parent: any): string;
    InterfaceTypeDefinition(node: InterfaceTypeDefinitionNode): string;
    SchemaDefinition(): any;
}
export {};
