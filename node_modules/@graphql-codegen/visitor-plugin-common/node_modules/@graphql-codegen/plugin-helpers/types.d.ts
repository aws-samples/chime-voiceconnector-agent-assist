import { GraphQLSchema, DocumentNode } from 'graphql';
import { Source } from '@graphql-toolkit/common';
export declare namespace Types {
    interface GenerateOptions {
        filename: string;
        plugins: Types.ConfiguredPlugin[];
        schema: DocumentNode;
        schemaAst?: GraphQLSchema;
        documents: Types.DocumentFile[];
        config: {
            [key: string]: any;
        };
        pluginMap: {
            [name: string]: CodegenPlugin;
        };
        skipDocumentsValidation?: boolean;
    }
    type FileOutput = {
        filename: string;
        content: string;
        hooks?: {
            beforeOneFileWrite?: LifecycleHooksDefinition<string | string[]>['beforeOneFileWrite'];
            afterOneFileWrite?: LifecycleHooksDefinition<string | string[]>['afterOneFileWrite'];
        };
    };
    type DocumentFile = Source;
    type ObjectMap<T = any> = {
        [key: string]: T;
    };
    type Promisable<T> = T | Promise<T>;
    type InstanceOrArray<T> = T | T[];
    type SchemaWithLoader = {
        [schemaString: string]: {
            loader: string;
        };
    };
    type UrlSchema = string | {
        [url: string]: {
            headers?: {
                [headerName: string]: string;
            };
        };
    };
    type LocalSchemaPath = string;
    type SchemaGlobPath = string;
    type Schema = UrlSchema | LocalSchemaPath | SchemaGlobPath | SchemaWithLoader;
    type OperationDocumentGlobPath = string;
    type CustomDocumentLoader = {
        [path: string]: {
            loader: string;
        };
    };
    type OperationDocument = OperationDocumentGlobPath | CustomDocumentLoader;
    type PluginConfig = InstanceOrArray<string> | ObjectMap;
    type ConfiguredPlugin = {
        [name: string]: PluginConfig;
    };
    type NamedPlugin = string;
    type NamedPreset = string;
    type OutputConfig = InstanceOrArray<NamedPlugin | ConfiguredPlugin>;
    type ConfiguredOutput = {
        plugins: OutputConfig;
        preset?: string | OutputPreset;
        presetConfig?: {
            [key: string]: any;
        };
        overwrite?: boolean;
        documents?: InstanceOrArray<OperationDocument>;
        schema?: InstanceOrArray<Schema>;
        config?: PluginConfig;
        hooks?: LifecycleHooksDefinition<string | string[]>;
    };
    type PresetFnArgs<Config = any, PluginConfig = {
        [key: string]: any;
    }> = {
        presetConfig: Config;
        baseOutputDir: string;
        plugins: Types.ConfiguredPlugin[];
        schema: DocumentNode;
        schemaAst?: GraphQLSchema;
        documents: Types.DocumentFile[];
        config: PluginConfig;
        pluginMap: {
            [name: string]: CodegenPlugin;
        };
    };
    type OutputPreset<TPresetConfig = any> = {
        buildGeneratesSection: (options: PresetFnArgs<TPresetConfig>) => Promisable<GenerateOptions[]>;
    };
    type RequireExtension = InstanceOrArray<string>;
    type PackageLoaderFn<TExpectedResult> = (name: string) => Promisable<TExpectedResult>;
    interface Config {
        schema?: InstanceOrArray<Schema>;
        require?: RequireExtension;
        customFetch?: string;
        documents?: InstanceOrArray<OperationDocument>;
        config?: {
            [key: string]: any;
        };
        generates: {
            [output: string]: OutputConfig | ConfiguredOutput;
        };
        overwrite?: boolean;
        watch?: boolean | string | string[];
        configFilePath?: string;
        silent?: boolean;
        pluginLoader?: PackageLoaderFn<CodegenPlugin>;
        pluckConfig?: {
            modules?: Array<{
                name: string;
                identifier?: string;
            }>;
            magicComment?: string;
            globalIdentifier?: string;
        };
        hooks?: LifecycleHooksDefinition<string | string[]>;
        cwd?: string;
    }
    type ComplexPluginOutput = {
        content: string;
        prepend?: string[];
        append?: string[];
    };
    type PluginOutput = string | ComplexPluginOutput;
    type LifecycleHooksDefinition<T = string | string[]> = {
        afterStart: T;
        beforeDone: T;
        onWatchTriggered: T;
        onError: T;
        afterOneFileWrite: T;
        afterAllFileWrite: T;
        beforeOneFileWrite: T;
        beforeAllFileWrite: T;
        [key: string]: T;
    };
}
export declare function isComplexPluginOutput(obj: Types.PluginOutput): obj is Types.ComplexPluginOutput;
export declare type PluginFunction<T = any> = (schema: GraphQLSchema, documents: Types.DocumentFile[], config: T, info?: {
    outputFile?: string;
    allPlugins?: Types.ConfiguredPlugin[];
    [key: string]: any;
}) => Types.Promisable<Types.PluginOutput>;
export declare type PluginValidateFn<T = any> = (schema: GraphQLSchema, documents: Types.DocumentFile[], config: T, outputFile: string, allPlugins: Types.ConfiguredPlugin[]) => Types.Promisable<void>;
export declare type AddToSchemaResult = string | DocumentNode | undefined;
export interface CodegenPlugin<T = any> {
    plugin: PluginFunction<T>;
    addToSchema?: AddToSchemaResult | ((config: T) => AddToSchemaResult);
    validate?: PluginValidateFn;
}
