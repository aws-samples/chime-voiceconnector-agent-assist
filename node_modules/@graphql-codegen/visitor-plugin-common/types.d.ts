import { ASTNode, FragmentDefinitionNode } from 'graphql';
import { ParsedMapper } from './mappers';
export declare type ScalarsMap = string | {
    [name: string]: string;
};
export declare type NormalizedScalarsMap = {
    [name: string]: string;
};
export declare type ParsedScalarsMap = {
    [name: string]: ParsedMapper;
};
export declare type EnumValuesMap<AdditionalProps = {}> = string | {
    [enumName: string]: string | ({
        [key: string]: string | number;
    } & AdditionalProps);
};
export declare type ParsedEnumValuesMap = {
    [enumName: string]: {
        mappedValues?: {
            [valueName: string]: string | number;
        };
        typeIdentifier: string;
        sourceIdentifier?: string;
        sourceFile?: string;
    };
};
export declare type ConvertNameFn<T = {}> = ConvertFn<T>;
export interface ConvertOptions {
    prefix?: string;
    suffix?: string;
    transformUnderscore?: boolean;
}
export declare type ConvertFn<T = {}> = (node: ASTNode | string, options?: ConvertOptions & T) => string;
export declare type NamingConventionResolvePath = string;
export declare type NamingConvention = string | Function | NamingConventionMap;
export interface NamingConventionMap {
    enumValues?: 'keep' | NamingConventionResolvePath | Function;
    typeNames?: 'keep' | NamingConventionResolvePath | Function;
    transformUnderscore?: boolean;
}
export declare type LoadedFragment<AdditionalFields = {}> = {
    name: string;
    onType: string;
    node: FragmentDefinitionNode;
    isExternal: boolean;
    importFrom?: string | null;
} & AdditionalFields;
export declare type DeclarationKind = 'type' | 'interface' | 'class' | 'abstract class';
export interface DeclarationKindConfig {
    scalar?: DeclarationKind;
    input?: DeclarationKind;
    type?: DeclarationKind;
    interface?: DeclarationKind;
    arguments?: DeclarationKind;
}
