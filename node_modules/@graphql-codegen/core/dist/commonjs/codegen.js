"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const plugin_helpers_1 = require("@graphql-codegen/plugin-helpers");
const graphql_1 = require("graphql");
const merge_schemas_1 = require("./merge-schemas");
const execute_plugin_1 = require("./execute-plugin");
const errors_1 = require("./errors");
const common_1 = require("@graphql-toolkit/common");
const graphql_2 = require("graphql");
async function codegen(options) {
    const documents = options.documents || [];
    if (documents.length > 0 && !options.skipDocumentsValidation) {
        validateDuplicateDocuments(documents);
    }
    const pluginPackages = Object.keys(options.pluginMap).map(key => options.pluginMap[key]);
    // merged schema with parts added by plugins
    let schemaChanged = false;
    let schema = pluginPackages.reduce((schema, plugin) => {
        const addToSchema = typeof plugin.addToSchema === 'function' ? plugin.addToSchema(options.config) : plugin.addToSchema;
        if (!addToSchema) {
            return schema;
        }
        schemaChanged = true;
        return merge_schemas_1.mergeSchemas([schema, addToSchema]);
    }, options.schema);
    const federationInConfig = pickFlag('federation', options.config);
    const isFederation = prioritize(federationInConfig, false);
    if (isFederation) {
        schemaChanged = true;
        schema = plugin_helpers_1.turnExtensionsIntoObjectTypes(merge_schemas_1.mergeSchemas([schema, plugin_helpers_1.federationSpec]));
    }
    if (schemaChanged) {
        options.schemaAst = graphql_1.buildASTSchema(schema, {
            assumeValidSDL: isFederation,
        });
    }
    const skipDocumentValidation = typeof options.config === 'object' && !Array.isArray(options.config) && options.config.skipDocumentsValidation;
    if (options.schemaAst && documents.length > 0 && !skipDocumentValidation) {
        const extraFragments = options.config && options.config['externalFragments'] ? options.config['externalFragments'] : [];
        const errors = await common_1.validateGraphQlDocuments(options.schemaAst, [
            ...documents.map(({ filePath, content }) => ({ location: filePath, document: content })),
            ...extraFragments.map((f) => ({ location: f.importFrom, document: { kind: graphql_2.Kind.DOCUMENT, definitions: [f.node] } })),
        ]);
        common_1.checkValidationErrors(errors);
    }
    const prepend = new Set();
    const append = new Set();
    const output$ = Promise.all(options.plugins.map(async (plugin) => {
        const name = Object.keys(plugin)[0];
        const pluginPackage = options.pluginMap[name];
        const pluginConfig = plugin[name] || {};
        const execConfig = typeof pluginConfig !== 'object'
            ? pluginConfig
            : {
                ...options.config,
                ...pluginConfig,
            };
        const result = await execute_plugin_1.executePlugin({
            name,
            config: execConfig,
            parentConfig: options.config,
            schema,
            schemaAst: options.schemaAst,
            documents: options.documents,
            outputFilename: options.filename,
            allPlugins: options.plugins,
            skipDocumentsValidation: options.skipDocumentsValidation,
        }, pluginPackage);
        if (typeof result === 'string') {
            return result || '';
        }
        else if (plugin_helpers_1.isComplexPluginOutput(result)) {
            if (result.append && result.append.length > 0) {
                for (const item of result.append) {
                    append.add(item);
                }
            }
            if (result.prepend && result.prepend.length > 0) {
                for (const item of result.prepend) {
                    prepend.add(item);
                }
            }
            return result.content || '';
        }
        return '';
    }));
    const output = await output$;
    return [...sortPrependValues(Array.from(prepend.values())), ...output, ...append.values()].join('\n');
}
exports.codegen = codegen;
function resolveCompareValue(a) {
    if (a.startsWith('/*') || a.startsWith('//') || a.startsWith(' *') || a.startsWith(' */') || a.startsWith('*/')) {
        return 0;
    }
    else if (a.startsWith('package')) {
        return 1;
    }
    else if (a.startsWith('import')) {
        return 2;
    }
    else {
        return 3;
    }
}
function sortPrependValues(values) {
    return values.sort((a, b) => {
        const aV = resolveCompareValue(a);
        const bV = resolveCompareValue(b);
        if (aV < bV) {
            return -1;
        }
        if (aV > bV) {
            return 1;
        }
        return 0;
    });
}
exports.sortPrependValues = sortPrependValues;
function validateDuplicateDocuments(files) {
    // duplicated names
    const operationMap = {};
    files.forEach(file => {
        graphql_1.visit(file.content, {
            OperationDefinition(node) {
                if (typeof node.name !== 'undefined') {
                    if (!operationMap[node.name.value]) {
                        operationMap[node.name.value] = [];
                    }
                    operationMap[node.name.value].push(file.filePath);
                }
            },
        });
    });
    const names = Object.keys(operationMap);
    if (names.length) {
        const duplicated = names.filter(name => operationMap[name].length > 1);
        if (!duplicated.length) {
            return;
        }
        const list = duplicated
            .map(name => `
      * ${name} found in:
        ${operationMap[name]
            .map(filepath => {
            return `
            - ${filepath}
          `.trimRight();
        })
            .join('')}
  `.trimRight())
            .join('');
        throw new errors_1.DetailedError(`Not all operations have an unique name: ${duplicated.join(', ')}`, `
        Not all operations have an unique name
        ${list}
      `);
    }
}
function isObjectMap(obj) {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
}
function prioritize(...values) {
    const picked = values.find(val => typeof val === 'boolean');
    if (typeof picked !== 'boolean') {
        return values[values.length - 1];
    }
    return picked;
}
function pickFlag(flag, config) {
    return isObjectMap(config) ? config[flag] : undefined;
}
//# sourceMappingURL=codegen.js.map