"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const utils_1 = require("./utils");
function isOutputConfigArray(type) {
    return Array.isArray(type);
}
exports.isOutputConfigArray = isOutputConfigArray;
function isConfiguredOutput(type) {
    return typeof type === 'object' && type['plugins'];
}
exports.isConfiguredOutput = isConfiguredOutput;
function normalizeOutputParam(config) {
    // In case of direct array with a list of plugins
    if (isOutputConfigArray(config)) {
        return {
            documents: [],
            schema: [],
            plugins: config,
        };
    }
    else if (isConfiguredOutput(config)) {
        return config;
    }
    else {
        throw new Error(`Invalid "generates" config!`);
    }
}
exports.normalizeOutputParam = normalizeOutputParam;
function normalizeInstanceOrArray(type) {
    if (Array.isArray(type)) {
        return type;
    }
    else if (!type) {
        return [];
    }
    return [type];
}
exports.normalizeInstanceOrArray = normalizeInstanceOrArray;
function normalizeConfig(config) {
    if (typeof config === 'string') {
        return [{ [config]: {} }];
    }
    else if (Array.isArray(config)) {
        return config.map(plugin => (typeof plugin === 'string' ? { [plugin]: {} } : plugin));
    }
    else if (typeof config === 'object') {
        return Object.keys(config).reduce((prev, pluginName) => [...prev, { [pluginName]: config[pluginName] }], []);
    }
    else {
        return [];
    }
}
exports.normalizeConfig = normalizeConfig;
function hasNullableTypeRecursively(type) {
    if (!graphql_1.isNonNullType(type)) {
        return true;
    }
    if (graphql_1.isListType(type) || graphql_1.isNonNullType(type)) {
        return hasNullableTypeRecursively(type.ofType);
    }
    return false;
}
exports.hasNullableTypeRecursively = hasNullableTypeRecursively;
function isUsingTypes(document, externalFragments, schema) {
    let foundFields = 0;
    let typesStack = [];
    graphql_1.visit(document, {
        InlineFragment: {
            enter: (node) => {
                if (node.typeCondition && schema) {
                    typesStack.push(schema.getType(node.typeCondition.name.value));
                }
            },
            leave: (node) => {
                if (node.typeCondition && schema) {
                    typesStack.pop();
                }
            },
        },
        Field: {
            enter: (node, key, parent, path, anscestors) => {
                if (node.name.value.startsWith('__')) {
                    return;
                }
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                if (schema) {
                    const lastType = typesStack[typesStack.length - 1];
                    if (lastType) {
                        if (graphql_1.isObjectType(lastType)) {
                            const field = lastType.getFields()[node.name.value];
                            if (!field) {
                                throw new Error(`Unable to find field "${node.name.value}" on type "${lastType}"!`);
                            }
                            const currentType = field.type;
                            // To handle `Maybe` usage
                            if (hasNullableTypeRecursively(currentType)) {
                                foundFields++;
                            }
                            typesStack.push(utils_1.getBaseType(currentType));
                        }
                    }
                }
                const selections = node.selectionSet ? node.selectionSet.selections || [] : [];
                const relevantFragmentSpreads = selections.filter(s => s.kind === graphql_1.Kind.FRAGMENT_SPREAD && !externalFragments.includes(s.name.value));
                if (selections.length === 0 || relevantFragmentSpreads.length > 0) {
                    foundFields++;
                }
            },
            leave: (node, key, parent, path, anscestors) => {
                if (node.name.value.startsWith('__')) {
                    return;
                }
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                if (schema) {
                    const currentType = typesStack[typesStack.length - 1];
                    if (currentType && graphql_1.isObjectType(currentType)) {
                        typesStack.pop();
                    }
                }
            },
        },
        FragmentDefinition: {
            enter: (node) => {
                if (schema) {
                    typesStack.push(schema.getType(node.typeCondition.name.value));
                }
            },
            leave: () => {
                if (schema) {
                    typesStack.pop();
                }
            },
        },
        OperationDefinition: {
            enter: (node) => {
                if (schema) {
                    if (node.operation === 'query') {
                        typesStack.push(schema.getQueryType());
                    }
                    else if (node.operation === 'mutation') {
                        typesStack.push(schema.getMutationType());
                    }
                    else if (node.operation === 'subscription') {
                        typesStack.push(schema.getSubscriptionType());
                    }
                }
            },
            leave: () => {
                if (schema) {
                    typesStack.pop();
                }
            },
        },
        enter: {
            VariableDefinition: (node, key, parent, path, anscestors) => {
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                foundFields++;
            },
            InputValueDefinition: (node, key, parent, path, anscestors) => {
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                foundFields++;
            },
        },
    });
    return foundFields > 0;
}
exports.isUsingTypes = isUsingTypes;
//# sourceMappingURL=helpers.js.map