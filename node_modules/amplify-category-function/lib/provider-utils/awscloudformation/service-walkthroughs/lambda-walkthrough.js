"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = exports.updateWalkthrough = exports.createWalkthrough = void 0;
const generalQuestionsWalkthrough_1 = __importDefault(require("./generalQuestionsWalkthrough"));
const autogeneratedParameters_1 = __importDefault(require("./autogeneratedParameters"));
const functionPluginLoader_1 = require("../utils/functionPluginLoader");
const lodash_1 = __importDefault(require("lodash"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const inquirer_1 = __importDefault(require("inquirer"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../utils/constants");
const cloudformationHelpers_1 = require("../utils/cloudformationHelpers");
const execPermissionsWalkthrough_1 = require("./execPermissionsWalkthrough");
const scheduleWalkthrough_1 = require("./scheduleWalkthrough");
const funcParamsUtils_1 = require("../utils/funcParamsUtils");
const constants_2 = require("../../../constants");
async function createWalkthrough(context, templateParameters) {
    templateParameters = funcParamsUtils_1.merge(templateParameters, autogeneratedParameters_1.default(context));
    templateParameters = funcParamsUtils_1.merge(templateParameters, await generalQuestionsWalkthrough_1.default(context));
    if (!templateParameters.runtime) {
        templateParameters = funcParamsUtils_1.merge(templateParameters, await functionPluginLoader_1.runtimeWalkthrough(context, templateParameters));
    }
    templateParameters = funcParamsUtils_1.merge(templateParameters, await functionPluginLoader_1.templateWalkthrough(context, templateParameters));
    let topLevelComment;
    templateParameters.parametersFileObj = {};
    if (await context.amplify.confirmPrompt.run('Do you want to access other resources created in this project from your Lambda function?')) {
        let legacyParameters = {};
        ({ topLevelComment } = await execPermissionsWalkthrough_1.askExecRolePermissionsQuestions(context, templateParameters, legacyParameters));
        templateParameters.parametersFileObj = legacyParameters;
    }
    templateParameters.topLevelComment = topLevelComment;
    templateParameters = funcParamsUtils_1.merge(templateParameters, await scheduleWalkthrough_1.scheduleWalkthrough(context, templateParameters));
    return templateParameters;
}
exports.createWalkthrough = createWalkthrough;
async function updateWalkthrough(context, lambdaToUpdate) {
    const { allResources } = await context.amplify.getResourceStatus();
    const resources = allResources.filter(resource => resource.service === constants_1.serviceName).map(resource => resource.resourceName);
    if (resources.length === 0) {
        context.print.error('No Lambda Functions resource to update. Please use "amplify add function" command to create a new Function');
        process.exit(0);
        return;
    }
    const resourceQuestion = [
        {
            name: 'resourceName',
            message: 'Please select the Lambda Function you would want to update',
            type: 'list',
            choices: resources,
        },
    ];
    const newParams = {};
    const answers = {};
    const currentDefaults = {};
    let dependsOn;
    const resourceAnswer = !lambdaToUpdate ? await inquirer_1.default.prompt(resourceQuestion) : { resourceName: lambdaToUpdate };
    answers.resourceName = resourceAnswer.resourceName;
    const projectBackendDirPath = context.amplify.pathManager.getBackendDirPath();
    const resourceDirPath = path_1.default.join(projectBackendDirPath, constants_1.categoryName, resourceAnswer.resourceName);
    const parametersFilePath = path_1.default.join(resourceDirPath, constants_1.functionParametersFileName);
    let currentParameters;
    try {
        currentParameters = context.amplify.readJsonFile(parametersFilePath);
    }
    catch (e) {
        currentParameters = {};
    }
    if (currentParameters.permissions) {
        currentDefaults.categories = Object.keys(currentParameters.permissions);
        currentDefaults.categoryPermissionMap = currentParameters.permissions;
    }
    if (await context.amplify.confirmPrompt.run('Do you want to update permissions granted to this Lambda function to perform on other resources in your project?')) {
        const amplifyMetaFilePath = context.amplify.pathManager.getAmplifyMetaFilePath();
        const amplifyMeta = context.amplify.readJsonFile(amplifyMetaFilePath);
        const resourceDependsOn = amplifyMeta.function[answers.resourceName].dependsOn || [];
        answers.dependsOn = resourceDependsOn;
        const { topLevelComment } = await execPermissionsWalkthrough_1.askExecRolePermissionsQuestions(context, answers, newParams, currentDefaults);
        const cfnFileName = `${resourceAnswer.resourceName}-cloudformation-template.json`;
        const cfnFilePath = path_1.default.join(resourceDirPath, cfnFileName);
        const cfnContent = context.amplify.readJsonFile(cfnFilePath);
        const dependsOnParams = { env: { Type: 'String' } };
        Object.keys(answers.resourcePropertiesJSON)
            .filter(resourceProperty => 'Ref' in answers.resourcePropertiesJSON[resourceProperty])
            .forEach(resourceProperty => {
            dependsOnParams[answers.resourcePropertiesJSON[resourceProperty].Ref] = {
                Type: 'String',
                Default: answers.resourcePropertiesJSON[resourceProperty].Ref,
            };
        });
        cfnContent.Parameters = cloudformationHelpers_1.getNewCFNParameters(cfnContent.Parameters, currentParameters, dependsOnParams, newParams);
        Object.assign(answers.resourcePropertiesJSON, { ENV: { Ref: 'env' }, REGION: { Ref: 'AWS::Region' } });
        if (!cfnContent.Resources.AmplifyResourcesPolicy) {
            cfnContent.Resources.AmplifyResourcesPolicy = {
                DependsOn: ['LambdaExecutionRole'],
                Type: 'AWS::IAM::Policy',
                Properties: {
                    PolicyName: 'amplify-lambda-execution-policy',
                    Roles: [
                        {
                            Ref: 'LambdaExecutionRole',
                        },
                    ],
                    PolicyDocument: {
                        Version: '2012-10-17',
                        Statement: [],
                    },
                },
            };
        }
        if (answers.categoryPolicies.length === 0) {
            delete cfnContent.Resources.AmplifyResourcesPolicy;
        }
        else {
            cfnContent.Resources.AmplifyResourcesPolicy.Properties.PolicyDocument.Statement = answers.categoryPolicies;
        }
        cfnContent.Resources.LambdaFunction.Properties.Environment.Variables = cloudformationHelpers_1.getNewCFNEnvVariables(cfnContent.Resources.LambdaFunction.Properties.Environment.Variables, currentParameters, answers.resourcePropertiesJSON, newParams);
        const updateTopLevelComment = filePath => {
            const commentRegex = new RegExp(`${lodash_1.default.escapeRegExp(constants_2.topLevelCommentPrefix)}[a-zA-Z0-9\\-\\s._=]+${lodash_1.default.escapeRegExp(constants_2.topLevelCommentSuffix)}`);
            let fileContents = fs_extra_1.default.readFileSync(filePath).toString();
            const commentMatches = fileContents.match(commentRegex);
            if (!commentMatches || commentMatches.length === 0) {
                fileContents = topLevelComment + fileContents;
            }
            else {
                fileContents = fileContents.replace(commentRegex, topLevelComment);
            }
            fs_extra_1.default.writeFileSync(filePath, fileContents);
        };
        const appJSFilePath = path_1.default.join(resourceDirPath, 'src', 'app.js');
        const indexJSFilePath = path_1.default.join(resourceDirPath, 'src', 'index.js');
        if (fs_extra_1.default.existsSync(appJSFilePath)) {
            updateTopLevelComment(appJSFilePath);
        }
        else if (fs_extra_1.default.existsSync(indexJSFilePath)) {
            updateTopLevelComment(indexJSFilePath);
        }
        fs_extra_1.default.writeFileSync(cfnFilePath, JSON.stringify(cfnContent, null, 4));
        answers.parameters = newParams;
        ({ dependsOn } = answers);
        if (!dependsOn) {
            dependsOn = [];
        }
    }
    const scheduleParametersFilePath = path_1.default.join(resourceDirPath, constants_1.parametersFileName);
    let params;
    try {
        params = context.amplify.readJsonFile(scheduleParametersFilePath);
    }
    catch (e) {
        params = {};
    }
    let scheduleParameters = params;
    scheduleParameters.cloudwatchRule = params.CloudWatchRule;
    scheduleParameters.resourceName = answers.resourceName;
    let scheduleParams = await scheduleWalkthrough_1.scheduleWalkthrough(context, scheduleParameters);
    answers.parameters = newParams;
    answers.parameters.CloudWatchRule = scheduleParams.cloudwatchRule;
    return { answers, dependsOn };
}
exports.updateWalkthrough = updateWalkthrough;
function migrate(context, projectPath, resourceName) {
    const resourceDirPath = path_1.default.join(projectPath, 'amplify', 'backend', constants_1.categoryName, resourceName);
    const cfnFilePath = path_1.default.join(resourceDirPath, `${resourceName}-cloudformation-template.json`);
    const oldCfn = context.amplify.readJsonFile(cfnFilePath);
    const newCfn = {};
    Object.assign(newCfn, oldCfn);
    if (!newCfn.Parameters) {
        newCfn.Parameters = {};
    }
    newCfn.Parameters.env = {
        Type: 'String',
    };
    if (!newCfn.Conditions) {
        newCfn.Conditions = {};
    }
    newCfn.Conditions.ShouldNotCreateEnvResources = {
        'Fn::Equals': [
            {
                Ref: 'env',
            },
            'NONE',
        ],
    };
    const oldFunctionName = newCfn.Resources.LambdaFunction.Properties.FunctionName;
    newCfn.Resources.LambdaFunction.Properties.FunctionName = {
        'Fn::If': [
            'ShouldNotCreateEnvResources',
            oldFunctionName,
            {
                'Fn::Join': [
                    '',
                    [
                        oldFunctionName,
                        '-',
                        {
                            Ref: 'env',
                        },
                    ],
                ],
            },
        ],
    };
    newCfn.Resources.LambdaFunction.Properties.Environment = { Variables: { ENV: { Ref: 'env' } } };
    const oldRoleName = newCfn.Resources.LambdaExecutionRole.Properties.RoleName;
    newCfn.Resources.LambdaExecutionRole.Properties.RoleName = {
        'Fn::If': [
            'ShouldNotCreateEnvResources',
            oldRoleName,
            {
                'Fn::Join': [
                    '',
                    [
                        oldRoleName,
                        '-',
                        {
                            Ref: 'env',
                        },
                    ],
                ],
            },
        ],
    };
    const jsonString = JSON.stringify(newCfn, null, '\t');
    fs_extra_1.default.writeFileSync(cfnFilePath, jsonString, 'utf8');
}
exports.migrate = migrate;
module.exports = {
    createWalkthrough,
    updateWalkthrough,
    migrate,
};
//# sourceMappingURL=lambda-walkthrough.js.map