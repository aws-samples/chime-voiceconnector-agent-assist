"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchableModelTransformer = void 0;
const graphql_transformer_core_1 = require("graphql-transformer-core");
const resources_1 = require("./resources");
const definitions_1 = require("./definitions");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_2 = require("graphql-transformer-common");
const path = require("path");
const STACK_NAME = 'SearchableStack';
const nonKeywordTypes = ['Int', 'Float', 'Boolean', 'AWSTimestamp', 'AWSDate', 'AWSDateTime'];
class SearchableModelTransformer extends graphql_transformer_core_1.Transformer {
    constructor() {
        super(`SearchableModelTransformer`, graphql_transformer_core_1.gql `
        directive @searchable(queries: SearchableQueryMap) on OBJECT
        input SearchableQueryMap {
          search: String
        }
      `);
        this.before = (ctx) => {
            const template = this.resources.initTemplate(ctx.isProjectUsingDataStore());
            ctx.mergeResources(template.Resources);
            ctx.mergeParameters(template.Parameters);
            ctx.mergeOutputs(template.Outputs);
            ctx.mergeMappings(template.Mappings);
            ctx.metadata.set(graphql_transformer_common_2.ResourceConstants.RESOURCES.ElasticsearchStreamingLambdaFunctionLogicalID, path.resolve(`${__dirname}/../lib/streaming-lambda.zip`));
            for (const resourceId of Object.keys(template.Resources)) {
                ctx.mapResourceToStack(STACK_NAME, resourceId);
            }
            for (const outputId of Object.keys(template.Outputs)) {
                ctx.mapResourceToStack(STACK_NAME, outputId);
            }
            for (const mappingId of Object.keys(template.Mappings)) {
                ctx.mapResourceToStack(STACK_NAME, mappingId);
            }
        };
        this.object = (def, directive, ctx) => {
            const modelDirective = def.directives.find(dir => dir.name.value === 'model');
            if (!modelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('Types annotated with @searchable must also be annotated with @model.');
            }
            const directiveArguments = graphql_transformer_core_1.getDirectiveArguments(directive);
            let shouldMakeSearch = true;
            let searchFieldNameOverride = undefined;
            if (directiveArguments.queries) {
                if (!directiveArguments.queries.search) {
                    shouldMakeSearch = false;
                }
                else {
                    searchFieldNameOverride = directiveArguments.queries.search;
                }
            }
            const typeName = def.name.value;
            ctx.setResource(graphql_transformer_common_2.SearchableResourceIDs.SearchableEventSourceMappingID(typeName), this.resources.makeDynamoDBStreamEventSourceMapping(typeName));
            ctx.mapResourceToStack(STACK_NAME, graphql_transformer_common_2.SearchableResourceIDs.SearchableEventSourceMappingID(typeName));
            const queryFields = [];
            const nonKeywordFields = [];
            def.fields.forEach(field => {
                if (nonKeywordTypes.includes(graphql_transformer_common_2.getBaseType(field.type))) {
                    nonKeywordFields.push(graphql_mapping_template_1.str(field.name.value));
                }
            });
            const primaryKey = this.getPrimaryKey(ctx, typeName);
            if (shouldMakeSearch) {
                this.generateSearchableInputs(ctx, def);
                this.generateSearchableXConnectionType(ctx, def);
                const searchResolver = this.resources.makeSearchResolver(def.name.value, nonKeywordFields, primaryKey, ctx.getQueryTypeName(), searchFieldNameOverride, ctx.isProjectUsingDataStore());
                ctx.setResource(graphql_transformer_common_2.ResolverResourceIDs.ElasticsearchSearchResolverResourceID(def.name.value), searchResolver);
                ctx.mapResourceToStack(STACK_NAME, graphql_transformer_common_2.ResolverResourceIDs.ElasticsearchSearchResolverResourceID(def.name.value));
                queryFields.push(graphql_transformer_common_1.makeField(searchResolver.Properties.FieldName.toString(), [
                    graphql_transformer_common_1.makeInputValueDefinition('filter', graphql_transformer_common_1.makeNamedType(`Searchable${def.name.value}FilterInput`)),
                    graphql_transformer_common_1.makeInputValueDefinition('sort', graphql_transformer_common_1.makeNamedType(`Searchable${def.name.value}SortInput`)),
                    graphql_transformer_common_1.makeInputValueDefinition('limit', graphql_transformer_common_1.makeNamedType('Int')),
                    graphql_transformer_common_1.makeInputValueDefinition('nextToken', graphql_transformer_common_1.makeNamedType('String')),
                ], graphql_transformer_common_1.makeNamedType(`Searchable${def.name.value}Connection`)));
            }
            ctx.addQueryFields(queryFields);
        };
        this.resources = new resources_1.ResourceFactory();
    }
    generateSearchableXConnectionType(ctx, def) {
        const searchableXConnectionName = `Searchable${def.name.value}Connection`;
        if (this.typeExist(searchableXConnectionName, ctx)) {
            return;
        }
        const connectionType = graphql_transformer_common_1.blankObject(searchableXConnectionName);
        ctx.addObject(connectionType);
        let connectionTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableXConnectionName);
        connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
            graphql_transformer_common_1.makeField('items', [], graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(def.name.value))),
        ]);
        connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
            graphql_transformer_common_1.makeField('nextToken', [], graphql_transformer_common_1.makeNamedType('String')),
            graphql_transformer_common_1.makeField('total', [], graphql_transformer_common_1.makeNamedType('Int')),
        ]);
        ctx.addObjectExtension(connectionTypeExtension);
    }
    typeExist(type, ctx) {
        return Boolean(type in ctx.nodeMap);
    }
    generateSearchableInputs(ctx, def) {
        if (!this.typeExist('SearchableStringFilterInput', ctx)) {
            const searchableStringFilterInput = definitions_1.makeSearchableScalarInputObject('String');
            ctx.addInput(searchableStringFilterInput);
        }
        if (!this.typeExist('SearchableIDFilterInput', ctx)) {
            const searchableIDFilterInput = definitions_1.makeSearchableScalarInputObject('ID');
            ctx.addInput(searchableIDFilterInput);
        }
        if (!this.typeExist('SearchableIntFilterInput', ctx)) {
            const searchableIntFilterInput = definitions_1.makeSearchableScalarInputObject('Int');
            ctx.addInput(searchableIntFilterInput);
        }
        if (!this.typeExist('SearchableFloatFilterInput', ctx)) {
            const searchableFloatFilterInput = definitions_1.makeSearchableScalarInputObject('Float');
            ctx.addInput(searchableFloatFilterInput);
        }
        if (!this.typeExist('SearchableBooleanFilterInput', ctx)) {
            const searchableBooleanFilterInput = definitions_1.makeSearchableScalarInputObject('Boolean');
            ctx.addInput(searchableBooleanFilterInput);
        }
        const searchableXQueryFilterInput = definitions_1.makeSearchableXFilterInputObject(def);
        if (!this.typeExist(searchableXQueryFilterInput.name.value, ctx)) {
            ctx.addInput(searchableXQueryFilterInput);
        }
        if (!this.typeExist('SearchableSortDirection', ctx)) {
            const searchableSortDirection = definitions_1.makeSearchableSortDirectionEnumObject();
            ctx.addEnum(searchableSortDirection);
        }
        if (!this.typeExist(`Searchable${def.name.value}SortableFields`, ctx)) {
            const searchableXSortableFieldsDirection = definitions_1.makeSearchableXSortableFieldsEnumObject(def);
            ctx.addEnum(searchableXSortableFieldsDirection);
        }
        if (!this.typeExist(`Searchable${def.name.value}SortInput`, ctx)) {
            const searchableXSortableInputDirection = definitions_1.makeSearchableXSortInputObject(def);
            ctx.addInput(searchableXSortableInputDirection);
        }
    }
    getPrimaryKey(ctx, typeName) {
        const tableResourceID = graphql_transformer_common_2.ModelResourceIDs.ModelTableResourceID(typeName);
        const tableResource = ctx.getResource(tableResourceID);
        const primaryKeySchemaElement = tableResource.Properties.KeySchema.find((keyElement) => keyElement.KeyType === 'HASH');
        return primaryKeySchemaElement.AttributeName;
    }
}
exports.SearchableModelTransformer = SearchableModelTransformer;
//# sourceMappingURL=SearchableModelTransformer.js.map