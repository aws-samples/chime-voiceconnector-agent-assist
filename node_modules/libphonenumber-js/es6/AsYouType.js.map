{"version":3,"sources":["../source/AsYouType.js"],"names":["Metadata","PhoneNumber","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","matchesEntirely","extractCountryCallingCode","findCountryCode","stripNationalPrefixAndCarrierCode","stripNationalPrefixAndCarrierCodeFromCompleteNumber","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","FIRST_GROUP_PATTERN","formatNationalNumberUsingFormat","applyInternationalSeparatorStyle","stripIDDPrefix","checkNumberLengthForType","parseDigits","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","NATIONAL_PREFIX_SEPARATORS_PATTERN","SUPPORT_LEGACY_FORMATTING_PATTERNS","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_FORMATTED_PHONE_NUMBER_PART","VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN","VALID_PHONE_NUMBER","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","AsYouType","optionsOrDefaultCountry","metadata","defaultCountry","defaultCallingCode","hasCountry","isNonGeographicCallingCode","reset","formattedOutput","international","internationalPrefix","undefined","countryCallingCode","digits","nationalNumberDigits","nationalPrefix","carrierCode","setCountry","chosenFormat","template","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","countryCode","country","callingCode","selectNumberingPlan","hasSelectedNumberingPlan","initializePhoneNumberFormatsForCountry","matchingFormats","resetFormat","text","formattedDigits","extractFormattedDigits","test","getFullNumber","inputDigits","getNonFormattedNationalNumber","extractedNumber","extractFormattedPhoneNumber","slice","length","startInternationalNumber","nextDigits","numberWithoutIDD","isInternational","isCountryCallingCodeAmbiguous","determineTheCountry","previousNationalPrefix","extractNationalPrefix","matchFormats","formatNationalNumberWithNextDigits","formattedNumber","attemptToFormatCompletePhoneNumber","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","reformatNationalNumber","format","createFormattingTemplate","formats","filter","internationalFormat","leadingDigits","leadingDigitsPatternIndex","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","indexOf","nationalPrefixFormattingRule","matcher","pattern","formattedNationalNumber","formattedNationalNumberWithNationalPrefix","getSeparatorAfterNationalPrefix","replace","options","spacing","prefix","getInternationalPrefix","number","chooseCountryByCountryCallingCode","nationalNumber","index","countryCodes","getCountryCodesForCallingCode","getTemplateForNumberFormatPattern","match","strictPattern","nationalNumberDummyDigits","numberFormat","getFormatFormat","includesNationalPrefix","numberFormatWithNationalPrefix","i","split","digit","search","cutAndStripNonPairedParens","getCountry","getCountryCallingCode","shorterNationalNumber","newCarrierCode","phoneNumber","getNumber","isPossible","isValid","getNonFormattedTemplate","stripNonPairedParens","string","dangling_braces","push","pop","start","cleared_string","cutBeforeIndex","closeNonPairedParens","cut_before","retained_template","opening_braces","countOccurences","closing_braces","symbol","count","character","times","result","startsAt","hasPlus"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AAEA,OAAOC,WAAP,MAAwB,eAAxB;AAEA,SACCC,YADD,EAECC,iBAFD,EAGCC,UAHD,QAIO,aAJP;AAMA,SAASC,eAAT,QAAgC,QAAhC;AAEA,SACCC,yBAAyB,IAAzBA,0BADD,EAECC,eAFD,EAGCC,iCAHD,EAICC,mDAJD,EAKCC,+DALD,QAMO,UANP;AAQA,SACCC,mBADD,EAECC,+BAFD,EAGCC,gCAHD,QAIO,WAJP;AAMA,SAASC,cAAT,QAA+B,OAA/B;AAEA,SAASC,wBAAT,QAAyC,kBAAzC;AAEA,OAAOC,WAAP,MAAwB,eAAxB,C,CAEA;AACA;;AACA,IAAMC,WAAW,GAAG,GAApB,C,CACA;;AACA,IAAMC,oCAAoC,GAAG,EAA7C,C,CACA;AACA;;AACA,IAAMC,0BAA0B,GAAGC,MAAM,CAACH,WAAD,EAAcC,oCAAd,CAAzC,C,CAEA;AACA;;AACA,OAAO,IAAMG,iBAAiB,GAAG,GAA1B,C,CAA8B;;AACrC,IAAMC,yBAAyB,GAAG,IAAIC,MAAJ,CAAWF,iBAAX,CAAlC,C,CAEA;AACA;;AACA,IAAMG,kCAAkC,GAAG,MAA3C,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,kCAAkC,GAAG,IAA3C,C,CAEA;AACA;;AACA,IAAMC,8BAA8B,GAAGD,kCAAkC,IAAK;AAAA,SAAM,iBAAN;AAAA,CAA9E,C,CAEA;AACA;AACA;AACA;AACA;;;AACA,IAAME,+BAA+B,GAAGF,kCAAkC,IAAK;AAAA,SAAM,mBAAN;AAAA,CAA/E,C,CAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,uBAAuB,GAAG,IAAIL,MAAJ,CAC/B,MACA,GADA,GACMpB,iBADN,GAC0B,IAD1B,GAEA,UAFA,GAEaA,iBAFb,GAEiC,MAFjC,GAGA,GAJ+B,CAAhC,C,CAOA;AACA;AACA;;AACA,IAAM0B,yBAAyB,GAAG,CAAlC;AAEA,IAAMC,iCAAiC,GACtC,MACC3B,iBADD,GAECD,YAFD,GAGA,IAJD;AAMA,IAAM6B,yCAAyC,GAAG,IAAIR,MAAJ,CAAW,MAAMO,iCAAN,GAA0C,GAArD,EAA0D,GAA1D,CAAlD;AAEA,IAAME,kBAAkB,GACvB,QACC,GADD,GACO5B,UADP,GACoB,GADpB,GAEC,GAFD,GAGED,iBAHF,GAIED,YAJF,GAKC,IALD,GAMC,GAND,GAOC,GAPD,GAQEC,iBARF,GASED,YATF,GAUC,IAVD,GAWA,GAZD;AAcA,IAAM+B,qCAAqC,GAAG,IAAIV,MAAJ,CAC7C,OACCpB,iBADD,GAECD,YAFD,GAGA,IAHA,GAIA,IAJA,GAKA,GAN6C,CAA9C;AASA,IAAMgC,+BAA+B,GAAG,KAAxC;;IAEqBC,S;;;AACpB;AACA;AACA;;AAGA;;;;AAIA,qBAAYC,uBAAZ,EAAqCC,QAArC,EAA+C;AAAA;;AAAA,qCANrC,EAMqC;;AAC9C,SAAKA,QAAL,GAAgB,IAAIrC,QAAJ,CAAaqC,QAAb,CAAhB,CAD8C,CAE9C;;AACA,QAAIC,cAAJ;AACA,QAAIC,kBAAJ,CAJ8C,CAK9C;;AACA,QAAIH,uBAAJ,EAA6B;AAC5B,UAAI,QAAOA,uBAAP,MAAmC,QAAvC,EAAiD;AAChDE,QAAAA,cAAc,GAAGF,uBAAuB,CAACE,cAAzC;AACAC,QAAAA,kBAAkB,GAAGH,uBAAuB,CAACG,kBAA7C;AACA,OAHD,MAGO;AACND,QAAAA,cAAc,GAAGF,uBAAjB;AACA;AACD;;AACD,QAAIE,cAAc,IAAI,KAAKD,QAAL,CAAcG,UAAd,CAAyBF,cAAzB,CAAtB,EAAgE;AAC/D,WAAKA,cAAL,GAAsBA,cAAtB;AACA;;AACD,QAAIC,kBAAJ,EAAwB;AACvB;AACA,UAAIL,+BAAJ,EAAqC;AACpC,YAAI,KAAKG,QAAL,CAAcI,0BAAd,CAAyCF,kBAAzC,CAAJ,EAAkE;AACjE,eAAKD,cAAL,GAAsB,KAAtB;AACA;AACD;;AACD,WAAKC,kBAAL,GAA0BA,kBAA1B;AACA,KAzB6C,CA0B9C;;;AACA,SAAKG,KAAL;AACA;;;;4BAEO;AACP,WAAKC,eAAL,GAAuB,EAAvB;AACA,WAAKC,aAAL,GAAqB,KAArB;AACA,WAAKC,mBAAL,GAA2BC,SAA3B;AACA,WAAKC,kBAAL,GAA0BD,SAA1B;AACA,WAAKE,MAAL,GAAc,EAAd;AACA,WAAKC,oBAAL,GAA4B,EAA5B;AACA,WAAKC,cAAL,GAAsB,EAAtB;AACA,WAAKC,WAAL,GAAmB,EAAnB;AACA,WAAKC,UAAL,CAAgB,KAAKd,cAArB,EAAqC,KAAKC,kBAA1C;AACA,aAAO,IAAP;AACA;;;kCAEa;AACb,WAAKc,YAAL,GAAoBP,SAApB;AACA,WAAKQ,QAAL,GAAgBR,SAAhB;AACA,WAAKS,+BAAL,GAAuCT,SAAvC;AACA,WAAKU,uCAAL,GAA+C,CAAC,CAAhD;AACA;AAED;;;;;;;;sCAKkB;AACjB,aAAO,KAAKZ,aAAZ;AACA;AAED;;;;;;;;;4CAMwB;AACvB,aAAO,KAAKG,kBAAZ;AACA;AAED;;;;;;;;;iCAMa;AACZ;AACA;AACA;AACA,UAAI,CAAC,KAAKC,MAAV,EAAkB;AACjB;AACA;;AACD,UAAIS,WAAW,GAAG,KAAKC,OAAvB;AACA;;AACA,UAAIxB,+BAAJ,EAAqC;AACpC,YAAI,KAAKwB,OAAL,KAAiB,KAArB,EAA4B;AAC3BD,UAAAA,WAAW,GAAGX,SAAd;AACA;AACD;;AACD,aAAOW,WAAP;AACA;;;+BAEUC,O,EAASC,W,EAAa;AAChC,WAAKD,OAAL,GAAeA,OAAf;AACA,WAAKrB,QAAL,CAAcuB,mBAAd,CAAkCF,OAAlC,EAA2CC,WAA3C;;AACA,UAAI,KAAKtB,QAAL,CAAcwB,wBAAd,EAAJ,EAA8C;AAC7C,aAAKC,sCAAL;AACA,OAFD,MAEO;AACN,aAAKC,eAAL,GAAuB,EAAvB;AACA;;AACD,WAAKC,WAAL;AACA;AAED;;;;;;;;0BAKMC,I,EAAM;AACX,UAAMC,eAAe,GAAG,KAAKC,sBAAL,CAA4BF,IAA5B,CAAxB,CADW,CAEX;AACA;AACA;;AACA,UAAIlC,yCAAyC,CAACqC,IAA1C,CAA+CF,eAA/C,CAAJ,EAAqE;AACpE,aAAKvB,eAAL,GAAuB,KAAK0B,aAAL,CACtB,KAAKC,WAAL,CAAiBtD,WAAW,CAACkD,eAAD,CAA5B,KACA,KAAKK,6BAAL,EAFsB,CAAvB;AAIA;;AACD,aAAO,KAAK5B,eAAZ;AACA;AAED;;;;;;;;2CAKuBsB,I,EAAM;AAC5B;AACA,UAAIO,eAAe,GAAGC,2BAA2B,CAACR,IAAD,CAA3B,IAAqC,EAA3D,CAF4B,CAG5B;;AACA,UAAIO,eAAe,CAAC,CAAD,CAAf,KAAuB,GAA3B,EAAgC;AAC/B;AACAA,QAAAA,eAAe,GAAGA,eAAe,CAACE,KAAhB,CAAsB,IAAIC,MAA1B,CAAlB;;AACA,YAAI,KAAK3B,MAAT,EAAiB,CAChB;AACA;AACA,SAHD,MAGO;AACN,eAAKL,eAAL,GAAuB,GAAvB;AACA,eAAKiC,wBAAL;AACA;AACD;;AACD,aAAOJ,eAAP;AACA;;;+CAE0B;AAC1B;AACA,WAAK5B,aAAL,GAAqB,IAArB,CAF0B,CAG1B;AACA;AACA;;AACA,WAAKQ,UAAL;AACA;AAED;;;;;;;;gCAKYyB,U,EAAY;AACvB;AACA;AACA;AACA;AACA,UAAI,CAAC,KAAK7B,MAAV,EAAkB;AACjB,YAAM8B,gBAAgB,GAAGhE,cAAc,CACtC+D,UADsC,EAEtC,KAAKvC,cAFiC,EAGtC,KAAKC,kBAHiC,EAItC,KAAKF,QAAL,CAAcA,QAJwB,CAAvC;;AAMA,YAAIyC,gBAAgB,IAAIA,gBAAgB,KAAKD,UAA7C,EAAyD;AACxD;AACA;AACA;AACA,eAAKhC,mBAAL,GAA2BgC,UAAU,CAACH,KAAX,CAAiB,CAAjB,EAAoBG,UAAU,CAACF,MAAX,GAAoBG,gBAAgB,CAACH,MAAzD,CAA3B;AACAE,UAAAA,UAAU,GAAGC,gBAAb;AACA,eAAKF,wBAAL;AACA;AACD,OApBsB,CAqBvB;;;AACA,WAAK5B,MAAL,IAAe6B,UAAf,CAtBuB,CAuBvB;;AACA,UAAI,KAAKE,eAAL,EAAJ,EAA4B;AAC3B,YAAI,KAAKhC,kBAAT,EAA6B;AAC5B,eAAKE,oBAAL,IAA6B4B,UAA7B,CAD4B,CAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,cAAI,CAAC,KAAKnB,OAAN,IAAiB,KAAKsB,6BAAL,EAArB,EAA2D;AAC1D,iBAAKC,mBAAL;AACA;AACD,SAZD,MAYO;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAI,CAAC,KAAK3E,yBAAL,EAAL,EAAuC;AACtC;AACA;AACA,WAhBK,CAiBN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAK2C,oBAAL,GAA4B,KAAKD,MAAL,CAAY0B,KAAZ,CAAkB,KAAK3B,kBAAL,CAAwB4B,MAA1C,CAA5B,CAzCM,CA0CN;AACA;AACA;;AACA,eAAKM,mBAAL;AACA;AACD,OA5DD,MA4DO;AACN,aAAKhC,oBAAL,IAA6B4B,UAA7B,CADM,CAEN;AACA;;AACA,YAAI,CAAC,KAAKnB,OAAV,EAAmB;AAClB,eAAKuB,mBAAL;AACA,SANK,CAON;AACA;AACA;;;AACA,YAAMC,sBAAsB,GAAG,KAAKhC,cAApC;AACA,aAAKD,oBAAL,GAA4B,KAAKC,cAAL,GAAsB,KAAKD,oBAAvD,CAXM,CAYN;;AACA,aAAKkC,qBAAL,GAbM,CAcN;;AACA,YAAI,KAAKjC,cAAL,KAAwBgC,sBAA5B,EAAoD;AACnD;AACA;AACA;AACA;AACA;AACA,eAAKpB,sCAAL;AACA,eAAKE,WAAL;AACA;AACD;;AAED,UAAI,KAAKf,oBAAT,EAA+B;AAC9B;AACA,aAAKmC,YAAL,CAAkB,KAAKnC,oBAAvB;AACA,OAjHsB,CAmHvB;;;AACA,aAAO,KAAKoC,kCAAL,CAAwCR,UAAxC,CAAP;AACA;;;uDAEkCA,U,EAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,UAAMS,eAAe,GAAG,KAAKC,kCAAL,EAAxB,CAN8C,CAQ9C;AACA;AACA;AACA;AACA;;AACA,UAAID,eAAJ,EAAqB;AACpB,eAAOA,eAAP;AACA,OAf6C,CAiB9C;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAME,sBAAsB,GAAG,KAAKnC,YAApC,CAxB8C,CAyB9C;;AACA,UAAMoC,iBAAiB,GAAG,KAAKC,YAAL,EAA1B;;AACA,UAAID,iBAAJ,EAAuB;AACtB,YAAIA,iBAAiB,KAAKD,sBAA1B,EAAkD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAO,KAAKG,8BAAL,CAAoCd,UAApC,CAAP;AACA,SAXD,MAWO;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAO,KAAKe,sBAAL,EAAP;AACA;AACD;AACD;;;mCAEc;AACd;AACA;AACA,2BAAqB,KAAK7B,eAA1B,kHAA2C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAhC8B,MAAgC;;AAC1C;AACA;AACA,YAAI,KAAKxC,YAAL,KAAsBwC,MAA1B,EAAkC;AACjC;AACA;;AACD,YAAI,CAAC,KAAKC,wBAAL,CAA8BD,MAA9B,CAAL,EAA4C;AAC3C;AACA;;AACD,aAAKxC,YAAL,GAAoBwC,MAApB,CAT0C,CAU1C;AACA;;AACA,aAAKrC,uCAAL,GAA+C,CAAC,CAAhD;AACA;AACA;;AACD,UAAI,CAAC,KAAKH,YAAV,EAAwB;AACvB;AACA,aAAKW,WAAL;AACA;;AACD,aAAO,KAAKX,YAAZ;AACA,K,CAED;AACA;;;;6CACyB;AACxB,aAAO,KAAKsC,8BAAL,CACN,KAAKzC,cAAL,GAAsB,KAAKD,oBADrB,CAAP;AAGA;;;6DAEwC;AACxC;AACA,WAAKc,eAAL,GAAuB,KAAK1B,QAAL,CAAc0D,OAAd,GAAwBC,MAAxB,CAA+B,UAACH,MAAD,EAAY;AACjE;AACA;AACA;AACA;AACA;AACA,eAAOjE,uBAAuB,CAACwC,IAAxB,CAA6ByB,MAAM,CAACI,mBAAP,EAA7B,CAAP;AACA,OAPsB,CAAvB;AAQA;;;iCAEYC,a,EAAe;AAAA;;AAC3B;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA,UAAIC,yBAAyB,GAAGD,aAAa,CAACvB,MAAd,GAAuB9C,yBAAvD;;AACA,UAAIsE,yBAAyB,GAAG,CAAhC,EAAmC;AAClCA,QAAAA,yBAAyB,GAAG,CAA5B;AACA;;AAED,WAAKpC,eAAL,GAAuB,KAAKA,eAAL,CAAqBiC,MAArB,CAA4B,UAACH,MAAD,EAAY;AAC9D;AACA;AACA;AACA,YAAI,CAAC,KAAI,CAACd,eAAL,EAAD,IAA2B,CAAC,KAAI,CAAC7B,cAAjC,IAAmD2C,MAAM,CAACO,uDAAP,EAAvD,EAAyH;AACxH,iBAAO,KAAP;AACA;;AACD,YAAMC,0BAA0B,GAAGR,MAAM,CAACS,qBAAP,GAA+B3B,MAAlE,CAP8D,CAQ9D;AACA;;AACA,YAAI0B,0BAA0B,KAAK,CAAnC,EAAsC;AACrC,iBAAO,IAAP;AACA,SAZ6D,CAa9D;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAIH,aAAa,CAACvB,MAAd,GAAuB9C,yBAA3B,EAAsD;AACrD,iBAAO,IAAP;AACA,SAtB6D,CAuB9D;AACA;AACA;;;AACAsE,QAAAA,yBAAyB,GAAGI,IAAI,CAACC,GAAL,CAASL,yBAAT,EAAoCE,0BAA0B,GAAG,CAAjE,CAA5B;AACA,YAAMI,oBAAoB,GAAGZ,MAAM,CAACS,qBAAP,GAA+BH,yBAA/B,CAA7B,CA3B8D,CA4B9D;AACA;;AACA,eAAO,IAAI5E,MAAJ,aAAgBkF,oBAAhB,QAAyCrC,IAAzC,CAA8C8B,aAA9C,CAAP;AACA,OA/BsB,CAAvB,CAlB2B,CAmD3B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI,KAAK7C,YAAL,IAAqB,KAAKU,eAAL,CAAqB2C,OAArB,CAA6B,KAAKrD,YAAlC,MAAoD,CAAC,CAA9E,EAAiF;AAChF,aAAKW,WAAL;AACA;AACD;;;oDAE+B6B,M,EAAQ;AACvC,UAAI,KAAKxD,QAAL,CAAcU,kBAAd,OAAuC,GAA3C,EAAgD;AAC/C,eAAO,GAAP;AACA;;AACD,UAAI8C,MAAM,IACTA,MAAM,CAACc,4BAAP,EADG,IAEHnF,kCAAkC,CAAC4C,IAAnC,CAAwCyB,MAAM,CAACc,4BAAP,EAAxC,CAFD,EAEiF;AAChF,eAAO,GAAP;AACA;;AACD,aAAO,EAAP;AACA,K,CAED;AACA;AACA;AACA;;;;yDACqC;AACpC,4BAAqB,KAAK5C,eAA1B,yHAA2C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAhC8B,MAAgC;AAC1C,YAAMe,OAAO,GAAG,IAAIrF,MAAJ,eAAkBsE,MAAM,CAACgB,OAAP,EAAlB,QAAhB;;AACA,YAAI,CAACD,OAAO,CAACxC,IAAR,CAAa,KAAKnB,oBAAlB,CAAL,EAA8C;AAC7C;AACA,SAJyC,CAK1C;AACA;AACA;AACA;;;AACA,YAAI6D,uBAAuB,GAAGlG,+BAA+B,CAC5D,KAAKqC,oBADuD,EAE5D4C,MAF4D,EAG5D,KAAKd,eAAL,EAH4D,EAI5D,KAJ4D,EAIrD;AACP,aAAK1C,QALuD,CAA7D,CAT0C,CAgB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAIrB,WAAW,CAAC8F,uBAAD,CAAX,KAAyC,KAAK7D,oBAAlD,EAAwE;AACvE;AACA,SAnCyC,CAoC1C;;;AACA,YAAI,KAAKC,cAAT,EAAyB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,cAAM6D,yCAAyC,GAAGnG,+BAA+B,CAChF,KAAKqC,oBAD2E,EAEhF4C,MAFgF,EAGhF,KAAKd,eAAL,EAHgF,EAIhF,IAJgF,EAI1E;AACN,eAAK1C,QAL2E,CAAjF;;AAOA,cAAIrB,WAAW,CAAC+F,yCAAD,CAAX,KAA2D,KAAK7D,cAAL,GAAsB,KAAKD,oBAA1F,EAAgH;AAC/G6D,YAAAA,uBAAuB,GAAGC,yCAA1B;AACA,WAFD,MAEO;AACND,YAAAA,uBAAuB,GAAG,KAAK5D,cAAL,GACzB,KAAK8D,+BAAL,CAAqCnB,MAArC,CADyB,GAEzBiB,uBAFD;AAGA;AACD,SA1DyC,CA4D1C;AACA;AACA;AACA;AACA;AAEA;;;AACA,aAAK9C,WAAL;AACA,aAAKX,YAAL,GAAoBwC,MAApB,CApE0C,CAqE1C;;AACA;;AACA,YAAI,KAAKC,wBAAL,CAA8BD,MAA9B,CAAJ,EAA2C;AAC1C;AACA,eAAKD,sBAAL;AACA,SAHD,MAGO;AACN;AACA;AACA;AACA,eAAKtC,QAAL,GAAgB,KAAKe,aAAL,CAAmByC,uBAAnB,EAA4CG,OAA5C,CAAoD,SAApD,EAA+D5F,iBAA/D,CAAhB;AACA,eAAKkC,+BAAL,GAAuCuD,uBAAvC;AACA,eAAKtD,uCAAL,GAA+C,KAAKD,+BAAL,CAAqCoB,MAArC,GAA8C,CAA7F;AACA;;AACD,eAAOmC,uBAAP;AACA;AACD;;;2CAEsBI,O,EAAS;AAC/B,aAAO,KAAKrE,mBAAL,GACNqE,OAAO,IAAIA,OAAO,CAACC,OAAR,KAAoB,KAA/B,GAAuC,KAAKtE,mBAA5C,GAAkE,KAAKA,mBAAL,GAA2B,GADvF,GAEH,GAFJ;AAGA,K,CAED;;;;kCACciE,uB,EAAyB;AACtC,UAAI,KAAK/B,eAAL,EAAJ,EAA4B;AAC3B,YAAMqC,MAAM,GAAG,KAAKC,sBAAL,EAAf;;AACA,YAAI,CAAC,KAAKtE,kBAAV,EAA8B;AAC7B,2BAAUqE,MAAV,SAAmB,KAAKpE,MAAxB;AACA;;AACD,YAAI,CAAC8D,uBAAL,EAA8B;AAC7B,2BAAUM,MAAV,SAAmB,KAAKrE,kBAAxB;AACA;;AACD,yBAAUqE,MAAV,SAAmB,KAAKrE,kBAAxB,cAA8C+D,uBAA9C;AACA;;AACD,aAAOA,uBAAP;AACA;;;oDAE+B;AAC/B,aAAO,KAAK5D,cAAL,IACL,KAAKA,cAAL,IAAuB,KAAKD,oBAA5B,IAAoD,KAAK+D,+BAAL,EAD/C,IAEN,KAAK/D,oBAFN;AAGA,K,CAED;AACA;AACA;;;;gDAC4B;AAAA,kCAIvB3C,0BAAyB,CAC5B,MAAM,KAAK0C,MADiB,EAE5B,KAAKV,cAFuB,EAG5B,KAAKC,kBAHuB,EAI5B,KAAKF,QAAL,CAAcA,QAJc,CAJF;AAAA,UAE1BU,kBAF0B,yBAE1BA,kBAF0B;AAAA,UAG1BuE,MAH0B,yBAG1BA,MAH0B;;AAU3B,UAAI,CAACvE,kBAAL,EAAyB;AACxB;AACA;;AACD,WAAKE,oBAAL,GAA4BqE,MAA5B;AACA,WAAKvE,kBAAL,GAA0BA,kBAA1B;AACA,WAAKV,QAAL,CAAckF,iCAAd,CAAgDxE,kBAAhD;AACA,WAAKe,sCAAL;AACA,WAAKE,WAAL;AACA,aAAO,KAAK3B,QAAL,CAAcwB,wBAAd,EAAP;AACA;;;4CAEuB;AACvB,WAAKX,cAAL,GAAsB,EAAtB;;AACA,UAAI,CAAC,KAAKb,QAAL,CAAcwB,wBAAd,EAAL,EAA+C;AAC9C;AACA,OAJsB,CAKvB;AACA;AACA;;;AAPuB,kCAWnBrD,iCAAiC,CACpC,KAAKyC,oBAD+B,EAEpC,KAAKZ,QAF+B,CAXd;AAAA,UAStBmF,cATsB,yBAStBA,cATsB;AAAA,UAUtBrE,WAVsB,yBAUtBA,WAVsB,EAevB;AACA;AACA;AACA;AACA;;;AACA,UAAIqE,cAAJ,EAAoB;AACnB,YAAMC,KAAK,GAAG,KAAKxE,oBAAL,CAA0ByD,OAA1B,CAAkCc,cAAlC,CAAd;;AACA,YAAIC,KAAK,GAAG,CAAR,IAAaA,KAAK,KAAK,KAAKxE,oBAAL,CAA0B0B,MAA1B,GAAmC6C,cAAc,CAAC7C,MAA7E,EAAqF;AACpF;AACA;AACD;;AACD,UAAIxB,WAAJ,EAAiB;AAChB,aAAKA,WAAL,GAAmBA,WAAnB;AACA;;AACD,WAAKD,cAAL,GAAsB,KAAKD,oBAAL,CAA0ByB,KAA1B,CAAgC,CAAhC,EAAmC,KAAKzB,oBAAL,CAA0B0B,MAA1B,GAAmC6C,cAAc,CAAC7C,MAArF,CAAtB;AACA,WAAK1B,oBAAL,GAA4BuE,cAA5B;AACA,aAAO,KAAKtE,cAAZ;AACA,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oDAEgC;AAC/B,UAAMwE,YAAY,GAAG,KAAKrF,QAAL,CAAcsF,6BAAd,CAA4C,KAAK5E,kBAAjD,CAArB;AACA,aAAO2E,YAAY,IAAIA,YAAY,CAAC/C,MAAb,GAAsB,CAA7C;AACA;;;6CAEwBkB,M,EAAQ;AAChC;AACA;AACA;;AACA;AACA,UAAIpE,kCAAkC,IAAIoE,MAAM,CAACgB,OAAP,GAAiBH,OAAjB,CAAyB,GAAzB,KAAiC,CAA3E,EAA8E;AAC7E;AACA,OAP+B,CAQhC;;;AACA,UAAIpD,QAAQ,GAAG,KAAKsE,iCAAL,CAAuC/B,MAAvC,EAA+C,KAAK3C,cAApD,CAAf,CATgC,CAUhC;AACA;;AACA,UAAI,CAACI,QAAL,EAAe;AACd;AACA;;AACD,WAAKA,QAAL,GAAgBA,QAAhB;AACA,WAAKC,+BAAL,GAAuCD,QAAvC,CAhBgC,CAiBhC;AACA;AACA;AACA;AACA;;AACA,UAAI,KAAKyB,eAAL,EAAJ,EAA4B;AAC3B,aAAKzB,QAAL,GACC,KAAK+D,sBAAL,GAA8BJ,OAA9B,CAAsC,SAAtC,EAAiD5F,iBAAjD,IACAD,MAAM,CAACC,iBAAD,EAAoB,KAAK0B,kBAAL,CAAwB4B,MAA5C,CADN,GAEA,GAFA,GAGArB,QAJD;AAKA;;AACD,aAAO,KAAKA,QAAZ;AACA;AAED;;;;;;;;;;sDAOkCuC,M,EAAQ3C,c,EAAgB;AACzD,UAAI2D,OAAO,GAAGhB,MAAM,CAACgB,OAAP,EAAd;AAEA;;AACA,UAAIpF,kCAAJ,EAAwC;AACvCoF,QAAAA,OAAO,GAAGA,OAAO,CAChB;AADgB,SAEfI,OAFQ,CAEAvF,8BAA8B,EAF9B,EAEkC,KAFlC,EAGT;AAHS,SAIRuF,OAJQ,CAIAtF,+BAA+B,EAJ/B,EAImC,KAJnC,CAAV;AAKA,OAVwD,CAYzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAIqB,MAAM,GAAG7B,0BAA0B,CAAC0G,KAA3B,CAAiChB,OAAjC,EAA0C,CAA1C,CAAb,CApByD,CAsBzD;AACA;;AACA,UAAI,KAAK5D,oBAAL,CAA0B0B,MAA1B,GAAmC3B,MAAM,CAAC2B,MAA9C,EAAsD;AACrD;AACA,OA1BwD,CA4BzD;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,UAAMmD,aAAa,GAAG,IAAIvG,MAAJ,CAAW,MAAMsF,OAAN,GAAgB,GAA3B,CAAtB;AACA,UAAMkB,yBAAyB,GAAG,KAAK9E,oBAAL,CAA0BgE,OAA1B,CAAkC,KAAlC,EAAyChG,WAAzC,CAAlC,CA5DyD,CA8DzD;AACA;AACA;;AACA,UAAI6G,aAAa,CAAC1D,IAAd,CAAmB2D,yBAAnB,CAAJ,EAAmD;AAClD/E,QAAAA,MAAM,GAAG+E,yBAAT;AACA;;AAED,UAAIC,YAAY,GAAG,KAAKC,eAAL,CAAqBpC,MAArB,CAAnB;AACA,UAAIqC,sBAAJ;;AAEA,UAAIhF,cAAJ,EAAoB;AACnB,YAAI2C,MAAM,CAACc,4BAAP,EAAJ,EAA2C;AAC1C,cAAMwB,8BAA8B,GAAGH,YAAY,CAACf,OAAb,CACtCtG,mBADsC,EAEtCkF,MAAM,CAACc,4BAAP,EAFsC,CAAvC;;AAIA,cAAI3F,WAAW,CAACmH,8BAAD,CAAX,KAAgDjF,cAAc,GAAGlC,WAAW,CAACgH,YAAD,CAAhF,EAAgG;AAC/FA,YAAAA,YAAY,GAAGG,8BAAf;AACAD,YAAAA,sBAAsB,GAAG,IAAzB;AACA,gBAAIE,CAAC,GAAGlF,cAAc,CAACyB,MAAvB;;AACA,mBAAOyD,CAAC,GAAG,CAAX,EAAc;AACbJ,cAAAA,YAAY,GAAGA,YAAY,CAACf,OAAb,CAAqB,IAArB,EAA2B5F,iBAA3B,CAAf;AACA+G,cAAAA,CAAC;AACD;AACD;AACD;AACD,OAxFwD,CA0FzD;;;AACA,UAAI9E,QAAQ,GAAGN,MAAM,CACpB;AADoB,OAEnBiE,OAFa,CAEL,IAAI1F,MAAJ,CAAWsF,OAAX,CAFK,EAEgBmB,YAFhB,EAGd;AAHc,OAIbf,OAJa,CAIL,IAAI1F,MAAJ,CAAWN,WAAX,EAAwB,GAAxB,CAJK,EAIyBI,iBAJzB,CAAf;;AAMA,UAAI6B,cAAJ,EAAoB;AACnB,YAAI,CAACgF,sBAAL,EAA6B;AAC5B;AACA5E,UAAAA,QAAQ,GAAGlC,MAAM,CAACC,iBAAD,EAAoB6B,cAAc,CAACyB,MAAnC,CAAN,GACV,KAAKqC,+BAAL,CAAqCnB,MAArC,CADU,GAEVvC,QAFD;AAGA;AACD;;AAED,aAAOA,QAAP;AACA;;;mDAE8BN,M,EAAQ;AACtC;AACA;AACA;AACA;AACA;AACA,4BAAoBA,MAAM,CAACqF,KAAP,CAAa,EAAb,CAApB,yHAAsC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAA3BC,KAA2B;;AACrC;AACA;AACA;AACA;AACA,YAAI,KAAK/E,+BAAL,CAAqCmB,KAArC,CAA2C,KAAKlB,uCAAL,GAA+C,CAA1F,EAA6F+E,MAA7F,CAAoGjH,yBAApG,IAAiI,CAArI,EAAwI;AACvI;AACA,eAAK0C,WAAL;AACA;AACA;;AAED,aAAKR,uCAAL,GAA+C,KAAKD,+BAAL,CAAqCgF,MAArC,CAA4CjH,yBAA5C,CAA/C;AACA,aAAKiC,+BAAL,GAAuC,KAAKA,+BAAL,CAAqC0D,OAArC,CAA6C3F,yBAA7C,EAAwEgH,KAAxE,CAAvC;AACA,OAnBqC,CAqBtC;;;AACA,aAAOE,0BAA0B,CAAC,KAAKjF,+BAAN,EAAuC,KAAKC,uCAAL,GAA+C,CAAtF,CAAjC,CAtBsC,CAwBtC;AACA;AACA;AACA;AACA;;;oCAEeqC,M,EAAQ;AACvB,UAAI,KAAKd,eAAL,EAAJ,EAA4B;AAC3B,eAAOlE,gCAAgC,CAACgF,MAAM,CAACI,mBAAP,EAAD,CAAvC;AACA;;AACD,aAAOJ,MAAM,CAACA,MAAP,EAAP;AACA,K,CAED;AACA;AACA;;;;0CACsB;AACrB,WAAKnC,OAAL,GAAenD,eAAe,CAC7B,KAAKwE,eAAL,KAAyB,KAAKhC,kBAA9B,GAAmD,KAAKR,kBAD3B,EAE7B,KAAKU,oBAFwB,EAG7B,KAAKZ,QAHwB,CAA9B;AAKA;AAED;;;;;;;;;gCAMY;AACX,UAAI,KAAK0C,eAAL,EAAJ,EAA4B;AAC3B,YAAI,CAAC,KAAKhC,kBAAV,EAA8B;AAC7B;AACA;AACD,OAJD,MAIO;AACN,YAAI,CAAC,KAAKW,OAAN,IAAiB,CAAC,KAAKnB,kBAA3B,EAA+C;AAC9C;AACA;AACD;;AACD,UAAI,CAAC,KAAKU,oBAAV,EAAgC;AAC/B,eAAOH,SAAP;AACA;;AACD,UAAIW,WAAW,GAAG,KAAKgF,UAAL,EAAlB;AACA,UAAM9E,WAAW,GAAG,KAAK+E,qBAAL,MAAgC,KAAKnG,kBAAzD;AACA,UAAIiF,cAAc,GAAG,KAAKvE,oBAA1B;AACA,UAAIE,WAAW,GAAG,KAAKA,WAAvB,CAhBW,CAiBX;AACA;AACA;AACA;AACA;;AACA,UAAI,CAAC,KAAK4B,eAAL,EAAD,IAA2B,KAAK9B,oBAAL,KAA8B,KAAKD,MAAlE,EAA0E;AAAA,qCAIrEtC,+DAA+D,CAClE,KAAKsC,MAD6D,EAElES,WAFkE,EAGlEE,WAHkE,EAIlE,KAAKtB,QAAL,CAAcA,QAJoD,CAJM;AAAA,YAExEU,kBAFwE,0BAExEA,kBAFwE;AAAA,YAGxEuE,MAHwE,0BAGxEA,MAHwE;;AAUzE,YAAIvE,kBAAJ,EAAwB;AAAA,uCAInBtC,mDAAmD,CACtD6G,MADsD,EAEtD,KAAKjF,QAFiD,CAJhC;AAAA,cAENsG,qBAFM,0BAEtBnB,cAFsB;AAAA,cAGToB,cAHS,0BAGtBzF,WAHsB;;AAQvBqE,UAAAA,cAAc,GAAGmB,qBAAjB;AACAxF,UAAAA,WAAW,GAAGyF,cAAd;AACA;AACD;;AACD,UAAMC,WAAW,GAAG,IAAI5I,WAAJ,CACnBwD,WAAW,IAAIE,WADI,EAEnB6D,cAFmB,EAGnB,KAAKnF,QAAL,CAAcA,QAHK,CAApB;;AAKA,UAAIc,WAAJ,EAAiB;AAChB0F,QAAAA,WAAW,CAAC1F,WAAZ,GAA0BA,WAA1B;AACA,OAnDU,CAoDX;;;AACA,aAAO0F,WAAP;AACA;AAED;;;;;;;;iCAKa;AACZ,UAAMA,WAAW,GAAG,KAAKC,SAAL,EAApB;;AACA,UAAI,CAACD,WAAL,EAAkB;AACjB,eAAO,KAAP;AACA;;AACD,aAAOA,WAAW,CAACE,UAAZ,EAAP;AACA;AAED;;;;;;;;8BAKU;AACT,UAAMF,WAAW,GAAG,KAAKC,SAAL,EAApB;;AACA,UAAI,CAACD,WAAL,EAAkB;AACjB,eAAO,KAAP;AACA;;AACD,aAAOA,WAAW,CAACG,OAAZ,EAAP;AACA;AAED;;;;;;;;wCAKoB;AACnB,aAAO,KAAK/F,oBAAZ;AACA;;;8CAEyB;AACzB,aAAO,KAAKoB,aAAL,CAAmB,KAAKE,6BAAL,EAAnB,EACL0C,OADK,CACG,SADH,EACc5F,iBADd,CAAP;AAEA;AAED;;;;;;;kCAIc;AACb,UAAI,CAAC,KAAKiC,QAAV,EAAoB;AACnB,eAAO,KAAK2F,uBAAL,EAAP;AACA;;AACD,UAAIxB,KAAK,GAAG,CAAC,CAAb;AACA,UAAIW,CAAC,GAAG,CAAR;;AACA,aAAOA,CAAC,GAAG,CAAC,KAAKrD,eAAL,KAAyB,KAAKsC,sBAAL,CAA4B;AAAEF,QAAAA,OAAO,EAAE;AAAX,OAA5B,EAAgDxC,MAAzE,GAAkF,CAAnF,IAAwF,KAAK3B,MAAL,CAAY2B,MAA/G,EAAuH;AACtH8C,QAAAA,KAAK,GAAG,KAAKnE,QAAL,CAAcoD,OAAd,CAAsBrF,iBAAtB,EAAyCoG,KAAK,GAAG,CAAjD,CAAR;AACAW,QAAAA,CAAC;AACD;;AACD,aAAOI,0BAA0B,CAAC,KAAKlF,QAAN,EAAgBmE,KAAK,GAAG,CAAxB,CAAjC;AACA;;;;;;SAv8BmBtF,S;AA08BrB,OAAO,SAAS+G,oBAAT,CAA8BC,MAA9B,EAAsC;AAC5C,MAAMC,eAAe,GAAE,EAAvB;AACA,MAAIhB,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGe,MAAM,CAACxE,MAAlB,EAA0B;AACzB,QAAIwE,MAAM,CAACf,CAAD,CAAN,KAAc,GAAlB,EAAuB;AACtBgB,MAAAA,eAAe,CAACC,IAAhB,CAAqBjB,CAArB;AACA,KAFD,MAGK,IAAIe,MAAM,CAACf,CAAD,CAAN,KAAc,GAAlB,EAAuB;AAC3BgB,MAAAA,eAAe,CAACE,GAAhB;AACA;;AACDlB,IAAAA,CAAC;AACD;;AACD,MAAImB,KAAK,GAAG,CAAZ;AACA,MAAIC,cAAc,GAAG,EAArB;AACAJ,EAAAA,eAAe,CAACC,IAAhB,CAAqBF,MAAM,CAACxE,MAA5B;;AACA,uCAAoByE,eAApB,wCAAqC;AAAhC,QAAM3B,KAAK,wBAAX;AACJ+B,IAAAA,cAAc,IAAIL,MAAM,CAACzE,KAAP,CAAa6E,KAAb,EAAoB9B,KAApB,CAAlB;AACA8B,IAAAA,KAAK,GAAG9B,KAAK,GAAG,CAAhB;AACA;;AACD,SAAO+B,cAAP;AACA;AAED,OAAO,SAAShB,0BAAT,CAAoCW,MAApC,EAA4CM,cAA5C,EAA4D;AAClE,MAAIN,MAAM,CAACM,cAAD,CAAN,KAA2B,GAA/B,EAAoC;AACnCA,IAAAA,cAAc;AACd;;AACD,SAAOP,oBAAoB,CAACC,MAAM,CAACzE,KAAP,CAAa,CAAb,EAAgB+E,cAAhB,CAAD,CAA3B;AACA;AAED,OAAO,SAASC,oBAAT,CAA8BpG,QAA9B,EAAwCqG,UAAxC,EAAoD;AAC1D,MAAMC,iBAAiB,GAAGtG,QAAQ,CAACoB,KAAT,CAAe,CAAf,EAAkBiF,UAAlB,CAA1B;AACA,MAAME,cAAc,GAAGC,eAAe,CAAC,GAAD,EAAMF,iBAAN,CAAtC;AACA,MAAMG,cAAc,GAAGD,eAAe,CAAC,GAAD,EAAMF,iBAAN,CAAtC;AACA,MAAIR,eAAe,GAAGS,cAAc,GAAGE,cAAvC;;AACA,SAAOX,eAAe,GAAG,CAAlB,IAAuBO,UAAU,GAAGrG,QAAQ,CAACqB,MAApD,EAA4D;AAC3D,QAAIrB,QAAQ,CAACqG,UAAD,CAAR,KAAyB,GAA7B,EAAkC;AACjCP,MAAAA,eAAe;AACf;;AACDO,IAAAA,UAAU;AACV;;AACD,SAAOrG,QAAQ,CAACoB,KAAT,CAAe,CAAf,EAAkBiF,UAAlB,CAAP;AACA,C,CAED;AACA;;AACA,OAAO,SAASG,eAAT,CAAyBE,MAAzB,EAAiCb,MAAjC,EAAyC;AAC/C,MAAIc,KAAK,GAAG,CAAZ,CAD+C,CAE/C;AACA;AACA;AACA;AACA;;AACA,wBAAwBd,MAAM,CAACd,KAAP,CAAa,EAAb,CAAxB,yHAA0C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,QAA/B6B,SAA+B;;AACzC,QAAIA,SAAS,KAAKF,MAAlB,EAA0B;AACzBC,MAAAA,KAAK;AACL;AACD;;AACD,SAAOA,KAAP;AACA,C,CAED;AACA;;AACA,OAAO,SAAS7I,MAAT,CAAgB+H,MAAhB,EAAwBgB,KAAxB,EAA+B;AACrC,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACd,WAAO,EAAP;AACA;;AACD,MAAIC,MAAM,GAAG,EAAb;;AACA,SAAOD,KAAK,GAAG,CAAf,EAAkB;AACjB,QAAIA,KAAK,GAAG,CAAZ,EAAe;AACdC,MAAAA,MAAM,IAAIjB,MAAV;AACA;;AACDgB,IAAAA,KAAK,KAAK,CAAV;AACAhB,IAAAA,MAAM,IAAIA,MAAV;AACA;;AACD,SAAOiB,MAAM,GAAGjB,MAAhB;AACA;AAED;;;;;;AAKA,SAAS1E,2BAAT,CAAqCR,IAArC,EAA2C;AAC1C;AACA,MAAMoG,QAAQ,GAAGpG,IAAI,CAACsE,MAAL,CAAYvG,kBAAZ,CAAjB;;AACA,MAAIqI,QAAQ,GAAG,CAAf,EAAkB;AACjB;AACA,GALyC,CAM1C;;;AACApG,EAAAA,IAAI,GAAGA,IAAI,CAACS,KAAL,CAAW2F,QAAX,CAAP,CAP0C,CAQ1C;;AACA,MAAIC,OAAJ;;AACA,MAAIrG,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqB;AACpBqG,IAAAA,OAAO,GAAG,IAAV;AACArG,IAAAA,IAAI,GAAGA,IAAI,CAACS,KAAL,CAAW,IAAIC,MAAf,CAAP;AACA,GAbyC,CAc1C;;;AACAV,EAAAA,IAAI,GAAGA,IAAI,CAACgD,OAAL,CAAahF,qCAAb,EAAoD,EAApD,CAAP,CAf0C,CAgB1C;;AACA,MAAIqI,OAAJ,EAAa;AACZrG,IAAAA,IAAI,GAAG,MAAMA,IAAb;AACA;;AACD,SAAOA,IAAP;AACA","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\r\n// `asyoutypeformatter.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\r\n//\r\n// Simplified: does not differentiate between \"local-only\" numbers\r\n// and \"internationally dialable\" numbers.\r\n// For example, doesn't include changes like this:\r\n// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\n\r\nimport {\r\n\textractCountryCallingCode,\r\n\tfindCountryCode,\r\n\tstripNationalPrefixAndCarrierCode,\r\n\tstripNationalPrefixAndCarrierCodeFromCompleteNumber,\r\n\textractCountryCallingCodeFromInternationalNumberWithoutPlusSign\r\n} from './parse_'\r\n\r\nimport {\r\n\tFIRST_GROUP_PATTERN,\r\n\tformatNationalNumberUsingFormat,\r\n\tapplyInternationalSeparatorStyle\r\n} from './format_'\r\n\r\nimport { stripIDDPrefix } from './IDD'\r\n\r\nimport { checkNumberLengthForType } from './getNumberType_'\r\n\r\nimport parseDigits from './parseDigits'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// The digits that have not been entered yet will be represented by a \\u2008,\r\n// the punctuation space.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A pattern that is used to determine if a `format` is eligible\r\n// to be used by the \"as you type formatter\".\r\n// It is eligible when the `format` contains groups of the dollar sign\r\n// followed by a single digit, separated by valid phone number punctuation.\r\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\r\n// getting into the output of the \"as you type formatter\".\r\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp(\r\n\t'^' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART =\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_PART + '$', 'i')\r\n\r\nconst VALID_PHONE_NUMBER =\r\n\t'(?:' +\r\n\t\t'[' + PLUS_CHARS + ']' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*' +\r\n\t\t'|' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']+' +\r\n\t')'\r\n\r\nconst AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp(\r\n\t'[^' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+' +\r\n\t'.*' +\r\n\t'$'\r\n)\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class AsYouType {\r\n\t// Not setting `options` to a constructor argument\r\n\t// not to break backwards compatibility\r\n\t// for older versions of the library.\r\n\toptions = {}\r\n\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (typeof optionsOrDefaultCountry === 'object') {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tthis.defaultCountry = defaultCountry\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tthis.defaultCountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\t}\r\n\t\t// Reset.\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.formattedOutput = ''\r\n\t\tthis.international = false\r\n\t\tthis.internationalPrefix = undefined\r\n\t\tthis.countryCallingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.nationalNumberDigits = ''\r\n\t\tthis.nationalPrefix = ''\r\n\t\tthis.carrierCode = ''\r\n\t\tthis.setCountry(this.defaultCountry, this.defaultCallingCode)\r\n\t\treturn this\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is being input in international format.\r\n\t * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisInternational() {\r\n\t\treturn this.international\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the \"country calling code\" part of the phone number.\r\n\t * Returns `undefined` if the number is not being input in international format.\r\n\t * Returns \"country calling code\" for \"non-geographic\" phone numbering plans too.\r\n\t * @return {string} [countryCallingCode]\r\n\t */\r\n\tgetCountryCallingCode() {\r\n\t\treturn this.countryCallingCode\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * Returns `undefined` if no phone number has been input yet.\r\n\t * @return {string} [country]\r\n\t */\r\n\tgetCountry() {\r\n\t\t// If no digits have been input yet,\r\n\t\t// then `this.country` is the `defaultCountry`.\r\n\t\t// Won't return the `defaultCountry` in such case.\r\n\t\tif (!this.digits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tlet countryCode = this.country\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\tif (this.country === '001') {\r\n\t\t\t\tcountryCode = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn countryCode\r\n\t}\r\n\r\n\tsetCountry(country, callingCode) {\r\n\t\tthis.country = country\r\n\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\t} else {\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst formattedDigits = this.extractFormattedDigits(text)\r\n\t\t// If the extracted phone number part\r\n\t\t// can possibly be a part of some valid phone number\r\n\t\t// then parse phone number characters from a formatted phone number.\r\n\t\tif (VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN.test(formattedDigits)) {\r\n\t\t\tthis.formattedOutput = this.getFullNumber(\r\n\t\t\t\tthis.inputDigits(parseDigits(formattedDigits)) ||\r\n\t\t\t\tthis.getNonFormattedNationalNumber()\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts formatted phone number digits from text (if there're any).\r\n\t * @param  {string} text\r\n\t * @return {string}\r\n\t */\r\n\textractFormattedDigits(text) {\r\n\t\t// Extract a formatted phone number part from text.\r\n\t\tlet extractedNumber = extractFormattedPhoneNumber(text) || ''\r\n\t\t// Trim a `+`.\r\n\t\tif (extractedNumber[0] === '+') {\r\n\t\t\t// Trim the `+`.\r\n\t\t\textractedNumber = extractedNumber.slice('+'.length)\r\n\t\t\tif (this.digits) {\r\n\t\t\t\t// If an out of position `+` is detected\r\n\t\t\t\t// (or a second `+`) then just ignore it.\r\n\t\t\t} else {\r\n\t\t\t\tthis.formattedOutput = '+'\r\n\t\t\t\tthis.startInternationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn extractedNumber\r\n\t}\r\n\r\n\tstartInternationalNumber() {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.setCountry()\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number digits.\r\n\t * @param  {string} digits\r\n\t * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n\t */\r\n\tinputDigits(nextDigits) {\r\n\t\t// Some users input their phone number in \"out-of-country\"\r\n\t\t// dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers.\r\n\t\tif (!this.digits) {\r\n\t\t\tconst numberWithoutIDD = stripIDDPrefix(\r\n\t\t\t\tnextDigits,\r\n\t\t\t\tthis.defaultCountry,\r\n\t\t\t\tthis.defaultCallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (numberWithoutIDD && numberWithoutIDD !== nextDigits) {\r\n\t\t\t\t// If an IDD prefix was stripped then\r\n\t\t\t\t// convert the number to international one\r\n\t\t\t\t// for subsequent parsing.\r\n\t\t\t\tthis.internationalPrefix = nextDigits.slice(0, nextDigits.length - numberWithoutIDD.length)\r\n\t\t\t\tnextDigits = numberWithoutIDD\r\n\t\t\t\tthis.startInternationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Append phone number digits.\r\n\t\tthis.digits += nextDigits\r\n\t\t// Try to format the parsed input\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (this.countryCallingCode) {\r\n\t\t\t\tthis.nationalNumberDigits += nextDigits\r\n\t\t\t\t// `this.country` could be `undefined`, for example, when there is\r\n\t\t\t\t// ambiguity in a form of several different countries,\r\n\t\t\t\t// each corresponding to the same country phone code\r\n\t\t\t\t// (e.g. NANPA: USA, Canada, etc), and there's not enough digits\r\n\t\t\t\t// to reliably determine the country the phone number belongs to.\r\n\t\t\t\t// Therefore, in cases of such ambiguity, each time something is input,\r\n\t\t\t\t// try to determine the country (if it hasn't been determined yet).\r\n\t\t\t\tif (!this.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\t\t\tthis.determineTheCountry()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Extract country calling code from the digits entered so far.\r\n\t\t\t\t// There must be some digits in order to extract anything from them.\r\n\t\t\t\t//\r\n\t\t\t\t// If one looks at country phone codes\r\n\t\t\t\t// then they can notice that no one country phone code\r\n\t\t\t\t// is ever a (leftmost) substring of another country phone code.\r\n\t\t\t\t// So if a valid country code is extracted so far\r\n\t\t\t\t// then it means that this is the country code.\r\n\t\t\t\t//\r\n\t\t\t\t// If no country phone code could be extracted so far,\r\n\t\t\t\t// then don't format the phone number.\r\n\t\t\t\t//\r\n\t\t\t\tif (!this.extractCountryCallingCode()) {\r\n\t\t\t\t\t// Don't format the phone number.\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t// Possibly extract a national prefix.\r\n\t\t\t\t// Some people incorrectly input national prefix\r\n\t\t\t\t// in an international phone number.\r\n\t\t\t\t// For example, some people write British phone numbers as `+44(0)...`.\r\n\t\t\t\t// Also, mobile phone numbers in Mexico are supposed to be dialled\r\n\t\t\t\t// internationally using a `15` national prefix.\r\n\t\t\t\t//\r\n\t\t\t\t// https://www.mexperience.com/dialing-cell-phones-in-mexico/\r\n\t\t\t\t//\r\n\t\t\t\t// \"Dialing a Mexican cell phone from abroad\r\n\t\t\t\t// When you are calling a cell phone number in Mexico from outside Mexico,\r\n\t\t\t\t// it’s necessary to dial an additional “1” after Mexico’s country code\r\n\t\t\t\t// (which is “52”) and before the area code.\r\n\t\t\t\t// You also ignore the 045, and simply dial the area code and the\r\n\t\t\t\t// cell phone’s number.\r\n\t\t\t\t//\r\n\t\t\t\t// If you don’t add the “1”, you’ll receive a recorded announcement\r\n\t\t\t\t// asking you to redial using it.\r\n\t\t\t\t//\r\n\t\t\t\t// For example, if you are calling from the USA to a cell phone\r\n\t\t\t\t// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.\r\n\t\t\t\t// (Note that this is different to calling a land line in Mexico City\r\n\t\t\t\t// from abroad, where the number dialed would be +52 – 55 – 1234 5678)\".\r\n\t\t\t\t//\r\n\t\t\t\tthis.nationalNumberDigits = this.digits.slice(this.countryCallingCode.length)\r\n\t\t\t\t// this.extractNationalPrefix()\r\n\t\t\t\t//\r\n\t\t\t\t// Determine the country from country calling code and national number.\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.nationalNumberDigits += nextDigits\r\n\t\t\t// If `defaultCallingCode` is set,\r\n\t\t\t// see if the `country` could be derived.\r\n\t\t\tif (!this.country) {\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t\t// Some national prefixes are substrings of other national prefixes\r\n\t\t\t// (for the same country), therefore try to extract national prefix each time\r\n\t\t\t// because a longer national prefix might be available at some point in time.\r\n\t\t\tconst previousNationalPrefix = this.nationalPrefix\r\n\t\t\tthis.nationalNumberDigits = this.nationalPrefix + this.nationalNumberDigits\r\n\t\t\t// Re-extract national prefix.\r\n\t\t\tthis.extractNationalPrefix()\r\n\t\t\t// If another national prefix has been extracted.\r\n\t\t\tif (this.nationalPrefix !== previousNationalPrefix) {\r\n\t\t\t\t// National number has changed\r\n\t\t\t\t// (due to another national prefix been extracted)\r\n\t\t\t\t// therefore national number has changed\r\n\t\t\t\t// therefore reset all previous formatting data.\r\n\t\t\t\t// (and leading digits matching state)\r\n\t\t\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.nationalNumberDigits) {\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tthis.matchFormats(this.nationalNumberDigits)\r\n\t\t}\r\n\r\n\t\t// Format the phone number (given the next digits)\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits)\r\n\t}\r\n\r\n\tformatNationalNumberWithNextDigits(nextDigits) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNextNationalNumberDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`.\r\n\t\tconst formattedNumber = this.attemptToFormatCompletePhoneNumber()\r\n\r\n\t\t// Just because a phone number doesn't have a suitable format\r\n\t\t// that doesn't mean that the phone number is invalid,\r\n\t\t// because phone number formats only format phone numbers,\r\n\t\t// they don't validate them and some (rare) phone numbers\r\n\t\t// are meant to stay non-formatted.\r\n\t\tif (formattedNumber) {\r\n\t\t\treturn formattedNumber\r\n\t\t}\r\n\r\n\t\t// Format the next phone number digits\r\n\t\t// using the previously chosen phone number format.\r\n\t\t//\r\n\t\t// This is done here because if `attemptToFormatCompletePhoneNumber`\r\n\t\t// was placed before this call then the `template`\r\n\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\r\n\t\t//\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat()\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If could format the next (current) digit\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the formatted number so far.\r\n\t\t\t\t//\r\n\t\t\t\t// If no new phone number format could be chosen,\r\n\t\t\t\t// and couldn't format the supplied national number\r\n\t\t\t\t// using the previously chosen phone number pattern,\r\n\t\t\t\t// then return `undefined`.\r\n\t\t\t\t//\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then format the national phone number (so far)\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\t//\r\n\t\t\t\t// Will return `undefined` if it couldn't format\r\n\t\t\t\t// the supplied national number\r\n\t\t\t\t// using the selected phone number pattern.\r\n\t\t\t\t//\r\n\t\t\t\treturn this.reformatNationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tchooseFormat() {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still possible, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif (!this.createFormattingTemplate(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\t// With a new formatting template, the matched position\r\n\t\t\t// using the old template needs to be reset.\r\n\t\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national phone number entered.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\t// Formats each digit of the national phone number (so far)\r\n\t// using the selected format.\r\n\treformatNationalNumber() {\r\n\t\treturn this.formatNextNationalNumberDigits(\r\n\t\t\tthis.nationalPrefix + this.nationalNumberDigits\r\n\t\t)\r\n\t}\r\n\r\n\tinitializePhoneNumberFormatsForCountry() {\r\n\t\t// Get all \"eligible\" phone number formats for this country\r\n\t\tthis.matchingFormats = this.metadata.formats().filter((format) => {\r\n\t\t\t// Compared to `libphonenumber`'s code, the two \"Discard a few formats\r\n\t\t\t// that we know are not relevant based on the presence of the national prefix\"\r\n\t\t\t// checks have changed: the first one has been moved to `.matchFormats()`,\r\n\t\t\t// and the second one doesn't apply to this library because it doesn't deal with\r\n\t\t\t// \"incomplete\" phone numbers (for example, phone numbers, entered without \"area code\").\r\n\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat())\r\n\t\t})\r\n\t}\r\n\r\n\tmatchFormats(leadingDigits) {\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter((format) => {\r\n\t\t\t// If national prefix is mandatory for this phone number format\r\n\t\t\t// and the user didn't input the national prefix\r\n\t\t\t// then this phone number format isn't suitable.\r\n\t\t\tif (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\t\t\t// If this format is not restricted to a certain\r\n\t\t\t// leading digits pattern then it fits.\r\n\t\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t// Start excluding any non-matching formats only when the\r\n\t\t\t// national number entered so far is at least 3 digits long,\r\n\t\t\t// otherwise format matching would give false negatives.\r\n\t\t\t// For example, when the digits entered so far are `2`\r\n\t\t\t// and the leading digits pattern is `21` –\r\n\t\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available\r\n\t\t\t// then format matching starts narrowing down the list of possible formats\r\n\t\t\t// (only previously matched formats are considered for next digits).\r\n\t\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\t\t\t// Brackets are required for `^` to be applied to\r\n\t\t\t// all or-ed (`|`) parts, not just the first one.\r\n\t\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t\t})\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\tif (this.metadata.countryCallingCode() === '1') {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\treturn ''\r\n\t}\r\n\r\n\t// This is in accordance to how Google's `libphonenumber` does it.\r\n\t// \"Check to see if there is an exact pattern match for these digits.\r\n\t// If so, we should use this instead of any other formatting template\r\n\t// whose `leadingDigitsPattern` also matches the input.\"\r\n\tattemptToFormatCompletePhoneNumber() {\r\n\t\tfor (const format of this.matchingFormats) {\r\n\t\t\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\t\t\tif (!matcher.test(this.nationalNumberDigits)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\t// Here, national number is formatted without \"national prefix\r\n\t\t\t// formatting rule\", because otherwise there'd be a bug\r\n\t\t\t// when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\tlet formattedNationalNumber = formatNationalNumberUsingFormat(\r\n\t\t\t\tthis.nationalNumberDigits,\r\n\t\t\t\tformat,\r\n\t\t\t\tthis.isInternational(),\r\n\t\t\t\tfalse, // Don't prepend national prefix (it will be prepended manually).\r\n\t\t\t\tthis.metadata\r\n\t\t\t)\r\n\t\t\t// Check if this `format` preserves all digits.\r\n\t\t\t// This is how it's done in Google's `libphonenumber`.\r\n\t\t\t// Also, it fixes the bug when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\t//\r\n\t\t\t// \"Check that we didn't remove nor add any extra digits when we matched\r\n\t\t\t// this formatting pattern. This usually happens after we entered the last\r\n\t\t\t// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\r\n\t\t\t// formatted but AYTF should retain all the number entered and not change\r\n\t\t\t// in order to match a format (of same leading digits and length) display\r\n\t\t\t// in that way.\"\r\n\t\t\t// \"If it's the same (i.e entered number and format is same), then it's\r\n\t\t\t// safe to return this in formatted number as nothing is lost / added.\"\r\n\t\t\t// Otherwise, don't use this format.\r\n\t\t\t// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\r\n\t\t\t// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\r\n\t\t\t//\r\n\t\t\tif (parseDigits(formattedNationalNumber) !== this.nationalNumberDigits) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\t// Prepend national prefix (if any).\r\n\t\t\tif (this.nationalPrefix) {\r\n\t\t\t\t// Here, national number is formatted with \"national prefix\r\n\t\t\t\t// formatting rule\". The reason is that \"national prefix\r\n\t\t\t\t// formatting rule\" often adds parentheses, and while Google's\r\n\t\t\t\t// `libphonenumber` dismisses those preferring simply prepending\r\n\t\t\t\t// national prefix followed by a \" \" character, this library\r\n\t\t\t\t// looks if the national prefix could be formatted better.\r\n\t\t\t\tconst formattedNationalNumberWithNationalPrefix = formatNationalNumberUsingFormat(\r\n\t\t\t\t\tthis.nationalNumberDigits,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\tthis.isInternational(),\r\n\t\t\t\t\ttrue, // Prepend national prefix.\r\n\t\t\t\t\tthis.metadata\r\n\t\t\t\t)\r\n\t\t\t\tif (parseDigits(formattedNationalNumberWithNationalPrefix) === this.nationalPrefix + this.nationalNumberDigits) {\r\n\t\t\t\t\tformattedNationalNumber = formattedNationalNumberWithNationalPrefix\r\n\t\t\t\t} else {\r\n\t\t\t\t\tformattedNationalNumber = this.nationalPrefix +\r\n\t\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\t\tformattedNationalNumber\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// formats national number (probably) without national prefix.\r\n\t\t\t// Formatting a national number with national prefix could result in\r\n\t\t\t// bugs when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\t// The \"are all digits preserved\" check fixes that type of bug.\r\n\r\n\t\t\t// To leave the formatter in a consistent state\r\n\t\t\tthis.resetFormat()\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\t// Set `this.template` and `this.populatedNationalNumberTemplate`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this.createFormattingTemplate(format)) {\r\n\t\t\t\t// Populate `this.populatedNationalNumberTemplate` with phone number digits.\r\n\t\t\t\tthis.reformatNationalNumber()\r\n\t\t\t} else {\r\n\t\t\t\t// If the formatting template couldn't be created for a format,\r\n\t\t\t\t// create it manually from the formatted phone number.\r\n\t\t\t\t// This case doesn't ever happen with the current metadata.\r\n\t\t\t\tthis.template = this.getFullNumber(formattedNationalNumber).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\r\n\t\t\t\tthis.populatedNationalNumberTemplate = formattedNationalNumber\r\n\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.length - 1\r\n\t\t\t}\r\n\t\t\treturn formattedNationalNumber\r\n\t\t}\r\n\t}\r\n\r\n\tgetInternationalPrefix(options) {\r\n\t\treturn this.internationalPrefix ? (\r\n\t\t\toptions && options.spacing === false ? this.internationalPrefix : this.internationalPrefix + ' '\r\n\t\t) : '+'\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tconst prefix = this.getInternationalPrefix()\r\n\t\t\tif (!this.countryCallingCode) {\r\n\t\t\t\treturn `${prefix}${this.digits}`\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn `${prefix}${this.countryCallingCode}`\r\n\t\t\t}\r\n\t\t\treturn `${prefix}${this.countryCallingCode} ${formattedNationalNumber}`\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumber() {\r\n\t\treturn this.nationalPrefix +\r\n\t\t\t(this.nationalPrefix && this.nationalNumberDigits && this.getSeparatorAfterNationalPrefix()) +\r\n\t\t\tthis.nationalNumberDigits\r\n\t}\r\n\r\n\t// Extracts the country calling code from the beginning\r\n\t// of the entered `national_number` (so far),\r\n\t// and places the remaining input into the `national_number`.\r\n\textractCountryCallingCode() {\r\n\t\tconst {\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnumber\r\n\t\t} = extractCountryCallingCode(\r\n\t\t\t'+' + this.digits,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (!countryCallingCode) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.nationalNumberDigits = number\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.metadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\tthis.resetFormat()\r\n\t\treturn this.metadata.hasSelectedNumberingPlan()\r\n\t}\r\n\r\n\textractNationalPrefix() {\r\n\t\tthis.nationalPrefix = ''\r\n\t\tif (!this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Only strip national prefixes for non-international phone numbers\r\n\t\t// because national prefixes can't be present in international phone numbers.\r\n\t\t// While `parseNumber()` is forgiving is such cases, `AsYouType` is not.\r\n\t\tconst {\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = stripNationalPrefixAndCarrierCode(\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\t// Sometimes `stripNationalPrefixAndCarrierCode()` won't actually\r\n\t\t// strip national prefix and will instead prepend some digits to the `number`:\r\n\t\t// for example, when number `2345678` is passed with `VI` country selected,\r\n\t\t// it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n\t\t// So check if the `nationalNumber` is actually at the end of `this.nationalNumberDigits`.\r\n\t\tif (nationalNumber) {\r\n\t\t\tconst index = this.nationalNumberDigits.indexOf(nationalNumber)\r\n\t\t\tif (index < 0 || index !== this.nationalNumberDigits.length - nationalNumber.length) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tthis.carrierCode = carrierCode\r\n\t\t}\r\n\t\tthis.nationalPrefix = this.nationalNumberDigits.slice(0, this.nationalNumberDigits.length - nationalNumber.length)\r\n\t\tthis.nationalNumberDigits = nationalNumber\r\n\t\treturn this.nationalPrefix\r\n\t}\r\n\r\n\t// isPossibleNumber(number) {\r\n\t// \tswitch (checkNumberLengthForType(number, undefined, this.metadata)) {\r\n\t// \t\tcase 'IS_POSSIBLE':\r\n\t// \t\t\treturn true\r\n\t// \t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t// \t\t// \treturn !this.isInternational()\r\n\t// \t\tdefault:\r\n\t// \t\t\treturn false\r\n\t// \t}\r\n\t// }\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(this.countryCallingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\tcreateFormattingTemplate(format) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tlet template = this.getTemplateForNumberFormatPattern(format, this.nationalPrefix)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (!template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.template = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.template =\r\n\t\t\t\tthis.getInternationalPrefix().replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t}\r\n\t\treturn this.template\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForNumberFormatPattern(format, nationalPrefix) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (this.nationalNumberDigits.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalNumberDigits : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalNumberDigits` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalNumberDigits`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = this.nationalNumberDigits.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalNumberDigits` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format)\r\n\t\tlet includesNationalPrefix\r\n\r\n\t\tif (nationalPrefix) {\r\n\t\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t\t)\r\n\t\t\t\tif (parseDigits(numberFormatWithNationalPrefix) === nationalPrefix + parseDigits(numberFormat)) {\r\n\t\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\t\tincludesNationalPrefix = true\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\tif (nationalPrefix) {\r\n\t\t\tif (!includesNationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\t// Using `.split('')` to iterate through a string here\r\n\t\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t\t// `.split('')` is generally not safe for Unicode,\r\n\t\t// but in this particular case for `digits` it is safe.\r\n\t\t// for (const digit of digits)\r\n\t\tfor (const digit of digits.split('')) {\r\n\t\t\t// If there is room for more digits in current `template`,\r\n\t\t\t// then set the next digit in the `template`,\r\n\t\t\t// and return the formatted digits so far.\r\n\t\t\t// If more digits are entered than the current format could handle.\r\n\t\t\tif (this.populatedNationalNumberTemplate.slice(this.populatedNationalNumberTemplatePosition + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\t\t// Reset the format.\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\t\tthis.populatedNationalNumberTemplate = this.populatedNationalNumberTemplate.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t\t}\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tgetFormatFormat(format) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn applyInternationalSeparatorStyle(format.internationalFormat())\r\n\t\t}\r\n\t\treturn format.format()\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.country = findCountryCode(\r\n\t\t\tthis.isInternational() ? this.countryCallingCode : this.defaultCallingCode,\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (!this.countryCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!this.country && !this.defaultCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.nationalNumberDigits) {\r\n\t\t\treturn undefined\r\n\t\t}\r\n\t\tlet countryCode = this.getCountry()\r\n\t\tconst callingCode = this.getCountryCallingCode() || this.defaultCallingCode\r\n\t\tlet nationalNumber = this.nationalNumberDigits\r\n\t\tlet carrierCode = this.carrierCode\r\n\t\t// When an international number without a leading `+` has been autocorrected,\r\n\t\t// extract country calling code, because normally it's only extracted\r\n\t\t// for international numbers with a leading `+`.\r\n\t\t// Could also just use `parsePhoneNumberFromString()` here\r\n\t\t// instead of hacking around this single case.\r\n\t\tif (!this.isInternational() && this.nationalNumberDigits === this.digits) {\r\n\t\t\tconst {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber\r\n\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\tthis.digits,\r\n\t\t\t\tcountryCode,\r\n\t\t\t\tcallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (countryCallingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tnationalNumber: shorterNationalNumber,\r\n\t\t\t\t\tcarrierCode: newCarrierCode\r\n\t\t\t\t} = stripNationalPrefixAndCarrierCodeFromCompleteNumber(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tthis.metadata\r\n\t\t\t\t)\r\n\t\t\t\tnationalNumber = shorterNationalNumber\r\n\t\t\t\tcarrierCode = newCarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCode || callingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"possible\".\r\n\t * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisPossible() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isPossible()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"valid\".\r\n\t * Is just a shortcut for `PhoneNumber.isValid()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisValid() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isValid()\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.nationalNumberDigits\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\treturn this.getFullNumber(this.getNonFormattedNationalNumber())\r\n\t\t\t.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns formatted phone number template.\r\n\t * @return {string} [template]\r\n\t */\r\n\tgetTemplate() {\r\n\t\tif (!this.template) {\r\n\t\t\treturn this.getNonFormattedTemplate()\r\n\t\t}\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\twhile (i < (this.isInternational() ? this.getInternationalPrefix({ spacing: false }).length : 0) + this.digits.length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\r\nfunction extractFormattedPhoneNumber(text) {\r\n\t// Attempt to extract a possible number from the string passed in.\r\n\tconst startsAt = text.search(VALID_PHONE_NUMBER)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\t// Trim everything to the left of the phone number.\r\n\ttext = text.slice(startsAt)\r\n\t// Trim the `+`.\r\n\tlet hasPlus\r\n\tif (text[0] === '+') {\r\n\t\thasPlus = true\r\n\t\ttext = text.slice('+'.length)\r\n\t}\r\n\t// Trim everything to the right of the phone number.\r\n\ttext = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '')\r\n\t// Re-add the previously trimmed `+`.\r\n\tif (hasPlus) {\r\n\t\ttext = '+' + text\r\n\t}\r\n\treturn text\r\n}"],"file":"AsYouType.js"}