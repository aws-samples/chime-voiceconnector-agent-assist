"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PredictionsTransformer = void 0;
const graphql_1 = require("graphql");
const definitions_1 = require("./definitions");
const graphql_transformer_core_1 = require("graphql-transformer-core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const resources_1 = require("./resources");
const predictions_utils_1 = require("./predictions_utils");
const cloudform_types_1 = require("cloudform-types");
const path = require("path");
const PREDICTIONS_DIRECTIVE_STACK = 'PredictionsDirectiveStack';
class PredictionsTransformer extends graphql_transformer_core_1.Transformer {
    constructor(predictionsConfig) {
        super('PredictionsTransformer', graphql_transformer_core_1.gql `
        # where the parent this field is defined on is a query type
        directive @predictions(actions: [PredictionsActions!]!) on FIELD_DEFINITION
        enum PredictionsActions {
          identifyText
          identifyLabels
          convertTextToSpeech
          translateText
        }
      `);
        this.field = (parent, definition, directive, ctx) => {
            if (parent.name.value !== ctx.getQueryTypeName()) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('@predictions directive only works under Query operations.');
            }
            const actions = this.getActions(directive);
            this.validateActions(actions);
            if (!(this.predictionsConfig) || !(this.predictionsConfig.bucketName)) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('Please configure storage in your project in order to use @predictions directive');
            }
            this.createResources(ctx, definition, actions, this.predictionsConfig.bucketName);
        };
        this.resources = new resources_1.ResourceFactory();
        this.predictionsConfig = predictionsConfig;
    }
    validateActions(actions) {
        const supportedPredictions = predictions_utils_1.allowedActions;
        const allowed = [];
        actions.forEach(action => {
            if (supportedPredictions[action] && (allowed.includes(action) || allowed.length === 0)) {
                allowed.concat(supportedPredictions[action].next);
            }
            else {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`${action} is not supported!`);
            }
        });
    }
    createResources(ctx, def, actions, storage) {
        const fieldName = def.name.value;
        const predictionFunctions = [];
        const actionInputObjectFields = [];
        let isList = false;
        let actionPolicyMap = {};
        if (ctx.metadata.has(graphql_transformer_common_1.PredictionsResourceIDs.actionMapID)) {
            actionPolicyMap = ctx.metadata.get(graphql_transformer_common_1.PredictionsResourceIDs.actionMapID);
        }
        actions.forEach((action, index) => {
            const isFirst = index === 0;
            isList = this.needsList(action, isList);
            actionInputObjectFields.push(definitions_1.createInputValueAction(action, fieldName));
            actionPolicyMap = this.resources.mergeActionRole(actionPolicyMap, action);
            const actionDSConfig = this.resources.getPredictionsDSConfig(action);
            predictionFunctions.push(cloudform_types_1.Fn.GetAtt(graphql_transformer_common_1.PredictionsResourceIDs.getPredictionFunctionName(action), 'FunctionId'));
            if (!ctx.getResource(actionDSConfig.id)) {
                ctx.setResource(actionDSConfig.id, this.resources.createPredictionsDataSource(actionDSConfig));
                ctx.mapResourceToStack(PREDICTIONS_DIRECTIVE_STACK, actionDSConfig.id);
                if (actionDSConfig.id === 'LambdaDataSource') {
                    actionPolicyMap = this.resources.mergeLambdaActionRole(actionPolicyMap);
                    ctx.metadata.set(graphql_transformer_common_1.PredictionsResourceIDs.lambdaID, path.resolve(`${__dirname}/../lib/predictionsLambdaFunction.zip`));
                    ctx.setResource(graphql_transformer_common_1.PredictionsResourceIDs.lambdaIAMRole, this.resources.createLambdaIAMRole(storage));
                    ctx.mapResourceToStack(PREDICTIONS_DIRECTIVE_STACK, graphql_transformer_common_1.PredictionsResourceIDs.lambdaIAMRole);
                    ctx.setResource(graphql_transformer_common_1.PredictionsResourceIDs.lambdaID, this.resources.createPredictionsLambda());
                    ctx.mapResourceToStack(PREDICTIONS_DIRECTIVE_STACK, graphql_transformer_common_1.PredictionsResourceIDs.lambdaID);
                }
            }
            if (!ctx.getResource(graphql_transformer_common_1.PredictionsResourceIDs.getPredictionFunctionName(action))) {
                ctx.setResource(graphql_transformer_common_1.PredictionsResourceIDs.getPredictionFunctionName(action), this.resources.createActionFunction(action, actionDSConfig.id));
                ctx.mapResourceToStack(PREDICTIONS_DIRECTIVE_STACK, graphql_transformer_common_1.PredictionsResourceIDs.getPredictionFunctionName(action));
            }
            if (!this.typeExist(definitions_1.getActionInputName(action, fieldName), ctx)) {
                const actionInput = definitions_1.getActionInputType(action, fieldName, isFirst);
                ctx.addInput(actionInput);
            }
        });
        const iamRole = this.resources.createIAMRole(actionPolicyMap, storage);
        ctx.setResource(graphql_transformer_common_1.PredictionsResourceIDs.iamRole, iamRole);
        ctx.mapResourceToStack(PREDICTIONS_DIRECTIVE_STACK, graphql_transformer_common_1.PredictionsResourceIDs.iamRole);
        ctx.metadata.set(graphql_transformer_common_1.PredictionsResourceIDs.actionMapID, actionPolicyMap);
        ctx.addInput(definitions_1.makeActionInputObject(fieldName, actionInputObjectFields));
        const type = ctx.getType(ctx.getQueryTypeName());
        if (type) {
            const field = type.fields.find(f => f.name.value === fieldName);
            if (field) {
                const newFields = [...type.fields.filter(f => f.name.value !== field.name.value), definitions_1.addInputArgument(field, fieldName, isList)];
                const newMutation = {
                    ...type,
                    fields: newFields,
                };
                ctx.putType(newMutation);
            }
        }
        const resolver = this.resources.createResolver(ctx.getQueryTypeName(), def.name.value, predictionFunctions, storage);
        const resolverId = graphql_transformer_common_1.ResolverResourceIDs.ResolverResourceID(ctx.getQueryTypeName(), def.name.value);
        ctx.setResource(resolverId, resolver);
        ctx.mapResourceToStack(PREDICTIONS_DIRECTIVE_STACK, resolverId);
    }
    getActions(directive) {
        const get = (s) => (arg) => arg.name.value === s;
        const getArg = (arg, dflt) => {
            const argument = directive.arguments.find(get(arg));
            return argument ? graphql_1.valueFromASTUntyped(argument.value) : dflt;
        };
        return getArg('actions', []);
    }
    needsList(action, flag) {
        switch (action) {
            case 'identifyLabels':
                return true;
            case 'convertTextToSpeech':
                return false;
            default:
                return flag;
        }
    }
    typeExist(type, ctx) {
        return Boolean(type in ctx.nodeMap);
    }
}
exports.PredictionsTransformer = PredictionsTransformer;
//# sourceMappingURL=PredictionsTransformer.js.map