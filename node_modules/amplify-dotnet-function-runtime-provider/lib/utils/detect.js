"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const which = __importStar(require("which"));
const execa = __importStar(require("execa"));
const constants_1 = require("../constants");
const inquirer_1 = __importDefault(require("inquirer"));
exports.detectDotNetCore = async () => {
    const executablePath = which.sync(constants_1.executableName, {
        nothrow: true,
    });
    if (executablePath === null) {
        return {
            hasRequiredDependencies: false,
            errorMessage: `Unable to find ${constants_1.executableName} version ${constants_1.currentSupportedVersion} on the path.`,
        };
    }
    const sdkResult = execa.sync(constants_1.executableName, ['--list-sdks']);
    const installedSdks = sdkResult.stdout;
    if (sdkResult.exitCode !== 0) {
        throw new Error(`${constants_1.executableName} failed SDK detection, exit code was ${sdkResult.exitCode}`);
    }
    const sdkInstalled = installedSdks && installedSdks.match(/^3\.1/m);
    const toolResult = execa.sync(constants_1.executableName, ['tool', 'list', '--global']);
    const installedToolList = toolResult.stdout;
    if (toolResult.exitCode !== 0) {
        throw new Error(`${constants_1.executableName} failed tool detection, exit code was ${toolResult.exitCode}`);
    }
    let toolInstalled = false;
    let testToolInstalled = false;
    if (installedToolList) {
        if (installedToolList.match(/^amazon\.lambda\.tools/m)) {
            toolInstalled = true;
        }
        if (installedToolList.match(/^amazon\.lambda\.testtool-3\.1/m)) {
            testToolInstalled = true;
        }
    }
    if (sdkInstalled && toolInstalled && testToolInstalled) {
        return {
            hasRequiredDependencies: true,
        };
    }
    else {
        const result = {
            hasRequiredDependencies: false,
            errorMessage: 'Unable to detect required dependencies:\n',
        };
        if (!sdkInstalled) {
            result.errorMessage += '- The .NET Core 3.1 SDK must be installed. It can be installed from https://dotnet.microsoft.com/download\n';
        }
        if (!toolInstalled) {
            result.errorMessage +=
                '- The Amazon.Lambda.Tools global tool must be installed. Please install by running "dotnet tool install -g Amazon.Lambda.Tools".\n';
        }
        if (!testToolInstalled) {
            result.errorMessage +=
                '- The Amazon.Lambda.TestTool-3.1 global tool must be installed. Please install by running "dotnet tool install -g Amazon.Lambda.TestTool-3.1".\n';
        }
        return result;
    }
};
async function installGlobalTool(toolName) {
    let response = await inquirer_1.default.prompt({
        type: 'confirm',
        name: 'installToolkit',
        message: `The ${toolName} global tool is required but was not detected.\nWould you like to install this tool?`,
        default: 'Y',
    });
    if (response.installToolkit) {
        let toolInstallationResult = execa.sync(constants_1.executableName, ['tool', 'install', '-g', toolName]);
        if (toolInstallationResult.exitCode !== 0) {
            throw new Error(`${constants_1.executableName} failed tool installation, exit code was ${toolInstallationResult.exitCode}`);
        }
        return true;
    }
    return false;
}
//# sourceMappingURL=detect.js.map