/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var CodeMarker = require('../util/CodeMarker');

var _require = require('../core/CompilerError'),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

var _require2 = require('relay-runtime'),
    ConnectionInterface = _require2.ConnectionInterface,
    getStorageKey = _require2.getStorageKey,
    stableCopy = _require2.stableCopy;

/**
 * @public
 *
 * Converts an IR node into a plain JS object representation that can be
 * used at runtime.
 */
function generate(schema, node) {
  if (node == null) {
    return node;
  }

  var metadata = null;

  if (node.metadata != null) {
    var _node$metadata = node.metadata,
        mask = _node$metadata.mask,
        plural = _node$metadata.plural,
        connection = _node$metadata.connection,
        refetch = _node$metadata.refetch;

    if (Array.isArray(connection)) {
      var _metadata;

      metadata = (_metadata = metadata) !== null && _metadata !== void 0 ? _metadata : {};
      metadata.connection = connection;
    }

    if (typeof mask === 'boolean') {
      var _metadata2;

      metadata = (_metadata2 = metadata) !== null && _metadata2 !== void 0 ? _metadata2 : {};
      metadata.mask = mask;
    }

    if (typeof plural === 'boolean') {
      var _metadata3;

      metadata = (_metadata3 = metadata) !== null && _metadata3 !== void 0 ? _metadata3 : {};
      metadata.plural = plural;
    }

    if (typeof refetch === 'object') {
      var _metadata4;

      metadata = (_metadata4 = metadata) !== null && _metadata4 !== void 0 ? _metadata4 : {};
      metadata.refetch = {
        // $FlowFixMe
        connection: refetch.connection,
        // $FlowFixMe
        operation: CodeMarker.moduleDependency(refetch.operation + '.graphql'),
        // $FlowFixMe
        fragmentPathInResult: refetch.fragmentPathInResult
      };
    }
  }

  return {
    kind: 'Fragment',
    name: node.name,
    type: schema.getTypeString(node.type),
    // $FlowFixMe
    metadata: metadata,
    argumentDefinitions: generateArgumentDefinitions(schema, node.argumentDefinitions),
    selections: generateSelections(schema, node.selections)
  };
}

function generateSelections(schema, selections) {
  return selections.map(function (selection) {
    switch (selection.kind) {
      case 'ClientExtension':
        return generateClientExtension(schema, selection);

      case 'FragmentSpread':
        return generateFragmentSpread(schema, selection);

      case 'Condition':
        return generateCondition(schema, selection);

      case 'ScalarField':
        return generateScalarField(schema, selection);

      case 'ModuleImport':
        return generateModuleImport(schema, selection);

      case 'InlineDataFragmentSpread':
        return generateInlineDataFragmentSpread(schema, selection);

      case 'InlineFragment':
        return generateInlineFragment(schema, selection);

      case 'LinkedField':
        return generateLinkedField(schema, selection);

      case 'ConnectionField':
        return generateConnectionField(schema, selection);

      case 'Connection':
        return generateConnection(schema, selection);

      case 'Defer':
        return generateDefer(schema, selection);

      case 'Stream':
        return generateStream(schema, selection);

      default:
        selection;
        throw new Error();
    }
  }).filter(Boolean);
}

function generateArgumentDefinitions(schema, nodes) {
  return nodes.map(function (node) {
    switch (node.kind) {
      case 'LocalArgumentDefinition':
        return {
          kind: 'LocalArgument',
          name: node.name,
          type: schema.getTypeString(node.type),
          defaultValue: node.defaultValue
        };

      case 'RootArgumentDefinition':
        return {
          kind: 'RootArgument',
          name: node.name,
          type: node.type ? schema.getTypeString(node.type) : null
        };

      default:
        throw new Error();
    }
  });
}

function generateClientExtension(schema, node) {
  return {
    kind: 'ClientExtension',
    selections: generateSelections(schema, node.selections)
  };
}

function generateDefer(schema, node) {
  return {
    kind: 'Defer',
    selections: generateSelections(schema, node.selections)
  };
}

function generateStream(schema, node) {
  return {
    kind: 'Stream',
    selections: generateSelections(schema, node.selections)
  };
}

function generateCondition(schema, node) {
  if (node.condition.kind !== 'Variable') {
    throw createCompilerError("ReaderCodeGenerator: Expected 'Condition' with static value to be " + 'pruned or inlined', [node.condition.loc]);
  }

  return {
    kind: 'Condition',
    passingValue: node.passingValue,
    condition: node.condition.variableName,
    selections: generateSelections(schema, node.selections)
  };
}

function generateFragmentSpread(schema, node) {
  return {
    kind: 'FragmentSpread',
    name: node.name,
    args: generateArgs(node.args)
  };
}

function generateInlineFragment(schema, node) {
  return {
    kind: 'InlineFragment',
    type: schema.getTypeString(node.typeCondition),
    selections: generateSelections(schema, node.selections)
  };
}

function generateInlineDataFragmentSpread(schema, node) {
  return {
    kind: 'InlineDataFragmentSpread',
    name: node.name,
    selections: generateSelections(schema, node.selections)
  };
}

function generateLinkedField(schema, node) {
  // Note: it is important that the arguments of this field be sorted to
  // ensure stable generation of storage keys for equivalent arguments
  // which may have originally appeared in different orders across an app.
  // TODO(T37646905) enable this invariant after splitting the
  // RelayCodeGenerator-test and running the FieldHandleTransform on
  // Reader ASTs.
  //
  //   invariant(
  //     node.handles == null,
  //     'ReaderCodeGenerator: unexpected handles',
  //   );
  var rawType = schema.getRawType(node.type);
  var field = {
    kind: 'LinkedField',
    alias: node.alias === node.name ? null : node.alias,
    name: node.name,
    storageKey: null,
    args: generateArgs(node.args),
    concreteType: !schema.isAbstractType(rawType) ? schema.getTypeString(rawType) : null,
    plural: isPlural(schema, node.type),
    selections: generateSelections(schema, node.selections)
  }; // Precompute storageKey if possible

  var storageKey = getStaticStorageKey(field, node.metadata);

  if (storageKey) {
    field = (0, _objectSpread2["default"])({}, field, {
      storageKey: storageKey
    });
  }

  return field;
}

function generateConnectionField(schema, node) {
  return generateLinkedField(schema, {
    name: node.name,
    alias: node.alias,
    loc: node.loc,
    directives: node.directives,
    metadata: node.metadata,
    selections: node.selections,
    type: node.type,
    connection: false,
    // this is only on the linked fields with @conneciton
    handles: null,
    args: node.args.filter(function (arg) {
      return !ConnectionInterface.isConnectionCall({
        name: arg.name,
        value: null
      });
    }),
    kind: 'LinkedField'
  });
}

function generateConnection(schema, node) {
  var _ConnectionInterface$ = ConnectionInterface.get(),
      EDGES = _ConnectionInterface$.EDGES,
      PAGE_INFO = _ConnectionInterface$.PAGE_INFO;

  var selections = generateSelections(schema, node.selections);
  var edges;
  var pageInfo;
  selections.forEach(function (selection) {
    if (selection.kind === 'LinkedField') {
      if (selection.name === EDGES) {
        edges = selection;
      } else if (selection.name === PAGE_INFO) {
        pageInfo = selection;
      }
    } else if (selection.kind === 'Stream') {
      selection.selections.forEach(function (subselection) {
        if (subselection.kind === 'LinkedField' && subselection.name === EDGES) {
          edges = subselection;
        }
      });
    } else if (selection.kind === 'Defer') {
      selection.selections.forEach(function (subselection) {
        if (subselection.kind === 'LinkedField' && subselection.name === PAGE_INFO) {
          pageInfo = subselection;
        }
      });
    }
  });

  if (edges == null || pageInfo == null) {
    throw createUserError("Invalid connection, expected the '".concat(EDGES, "' and '").concat(PAGE_INFO, "' fields ") + 'to exist.', [node.loc]);
  }

  return {
    kind: 'Connection',
    label: node.label,
    name: node.name,
    args: generateArgs(node.args),
    edges: edges,
    pageInfo: pageInfo
  };
}

function generateModuleImport(schema, node) {
  var fragmentName = node.name;
  var regExpMatch = fragmentName.match(/^([a-zA-Z][a-zA-Z0-9]*)(?:_([a-zA-Z][_a-zA-Z0-9]*))?$/);

  if (!regExpMatch) {
    throw createCompilerError('ReaderCodeGenerator: @match fragments should be named ' + "'FragmentName_propName', got '".concat(fragmentName, "'."), [node.loc]);
  }

  var fragmentPropName = regExpMatch[2];

  if (typeof fragmentPropName !== 'string') {
    throw createCompilerError('ReaderCodeGenerator: @module fragments should be named ' + "'FragmentName_propName', got '".concat(fragmentName, "'."), [node.loc]);
  }

  return {
    kind: 'ModuleImport',
    documentName: node.documentName,
    fragmentName: fragmentName,
    fragmentPropName: fragmentPropName
  };
}

function generateScalarField(schema, node) {
  // Note: it is important that the arguments of this field be sorted to
  // ensure stable generation of storage keys for equivalent arguments
  // which may have originally appeared in different orders across an app.
  // TODO(T37646905) enable this invariant after splitting the
  // RelayCodeGenerator-test and running the FieldHandleTransform on
  // Reader ASTs.
  //
  //   invariant(
  //     node.handles == null,
  //     'ReaderCodeGenerator: unexpected handles',
  //   );
  var field = {
    kind: 'ScalarField',
    alias: node.alias === node.name ? null : node.alias,
    name: node.name,
    args: generateArgs(node.args),
    storageKey: null
  }; // Precompute storageKey if possible

  var storageKey = getStaticStorageKey(field, node.metadata);

  if (storageKey) {
    field = (0, _objectSpread2["default"])({}, field, {
      storageKey: storageKey
    });
  }

  return field;
}

function generateArgument(name, value) {
  switch (value.kind) {
    case 'Variable':
      return {
        kind: 'Variable',
        name: name,
        variableName: value.variableName
      };

    case 'Literal':
      return value.value === null ? null : {
        kind: 'Literal',
        name: name,
        value: stableCopy(value.value)
      };

    case 'ObjectValue':
      {
        var objectKeys = value.fields.map(function (field) {
          return field.name;
        }).sort();
        var objectValues = new Map(value.fields.map(function (field) {
          return [field.name, field.value];
        }));
        return {
          kind: 'ObjectValue',
          name: name,
          fields: objectKeys.map(function (fieldName) {
            var _generateArgument;

            var fieldValue = objectValues.get(fieldName);

            if (fieldValue == null) {
              throw createCompilerError('Expected to have object field value');
            }

            return (_generateArgument = generateArgument(fieldName, fieldValue)) !== null && _generateArgument !== void 0 ? _generateArgument : {
              kind: 'Literal',
              name: fieldName,
              value: null
            };
          })
        };
      }

    case 'ListValue':
      {
        return {
          kind: 'ListValue',
          name: name,
          items: value.items.map(function (item, index) {
            return generateArgument("".concat(name, ".").concat(index), item);
          })
        };
      }

    default:
      throw createUserError('ReaderCodeGenerator: Complex argument values (Lists or ' + 'InputObjects with nested variables) are not supported.', [value.loc]);
  }
}

function generateArgs(args) {
  var concreteArguments = [];
  args.forEach(function (arg) {
    var concreteArgument = generateArgument(arg.name, arg.value);

    if (concreteArgument !== null) {
      concreteArguments.push(concreteArgument);
    }
  });
  return concreteArguments.length === 0 ? null : concreteArguments.sort(nameComparator);
}

function nameComparator(a, b) {
  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
}
/**
 * Pre-computes storage key if possible and advantageous. Storage keys are
 * generated for fields with supplied arguments that are all statically known
 * (ie. literals, no variables) at build time.
 */


function getStaticStorageKey(field, metadata) {
  var metadataStorageKey = metadata === null || metadata === void 0 ? void 0 : metadata.storageKey;

  if (typeof metadataStorageKey === 'string') {
    return metadataStorageKey;
  }

  if (!field.args || field.args.length === 0 || field.args.some(function (arg) {
    return arg.kind !== 'Literal';
  })) {
    return null;
  }

  return getStorageKey(field, {});
}

function isPlural(schema, type) {
  return schema.isList(schema.getNullableType(type));
}

module.exports = {
  generate: generate
};