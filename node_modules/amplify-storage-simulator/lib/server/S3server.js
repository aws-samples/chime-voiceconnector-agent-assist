"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const xml_1 = __importDefault(require("xml"));
const bodyParser = __importStar(require("body-parser"));
const convert = __importStar(require("xml-js"));
const event_to_promise_1 = __importDefault(require("event-to-promise"));
const serve_static_1 = __importDefault(require("serve-static"));
const glob = __importStar(require("glob"));
const object_to_xml_1 = __importDefault(require("object-to-xml"));
const uuid_1 = __importDefault(require("uuid"));
const etag_1 = __importDefault(require("etag"));
const events_1 = require("events");
const util = __importStar(require("./utils"));
const LIST_CONTENT = 'Contents';
const LIST_COMMOM_PREFIXES = 'CommonPrefixes';
const EVENT_RECORDS = 'Records';
var corsOptions = {
    maxAge: 20000,
    exposedHeaders: ['x-amz-server-side-encryption', 'x-amz-request-id', 'x-amz-id-2', 'ETag'],
};
class StorageServer extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.uploadIds = [];
        this.localDirectoryPath = config.localDirS3;
        this.app = express_1.default();
        this.app.use(cors_1.default(corsOptions));
        this.app.use(bodyParser.raw({ limit: '100mb', type: '*/*' }));
        this.app.use(serve_static_1.default(this.localDirectoryPath), this.handleRequestAll.bind(this));
        this.server = null;
        this.route = config.route;
        this.upload_bufferMap = {};
    }
    start() {
        if (this.server) {
            throw new Error('Server is already running');
        }
        this.server = this.app.listen(this.config.port);
        return event_to_promise_1.default(this.server, 'listening').then(() => {
            this.connection = this.server.address();
            this.url = `http://localhost:${this.connection.port}`;
            return this.server;
        });
    }
    stop() {
        if (this.server) {
            this.server.close();
            this.server = null;
            this.connection = null;
            this.uploadIds = null;
            this.upload_bufferMap = null;
        }
    }
    async handleRequestAll(request, response) {
        util.parseUrl(request, this.route);
        if (request.method === 'PUT') {
            this.handleRequestPut(request, response);
        }
        if (request.method === 'POST') {
            this.handleRequestPost(request, response);
        }
        if (request.method === 'GET') {
            this.handleRequestGet(request, response);
        }
        if (request.method === 'LIST') {
            this.handleRequestList(request, response);
        }
        if (request.method === 'DELETE') {
            let eventObj = this.createEvent(request);
            this.emit('event', eventObj);
            this.handleRequestDelete(request, response);
        }
    }
    async handleRequestGet(request, response) {
        const filePath = path_1.normalize(path_1.join(this.localDirectoryPath, request.params.path));
        if (fs_extra_1.existsSync(filePath)) {
            fs_extra_1.readFile(filePath, (err, data) => {
                if (err) {
                    console.log('error');
                }
                response.send(data);
            });
        }
        else {
            response.status(404);
            response.send(object_to_xml_1.default({
                '?xml version="1.0" encoding="utf-8"?': null,
                Error: {
                    Code: 'NoSuchKey',
                    Message: 'The specified key does not exist.',
                    Key: request.params.path,
                    RequestId: '',
                    HostId: '',
                },
            }));
        }
    }
    async handleRequestList(request, response) {
        let ListBucketResult = {};
        ListBucketResult[LIST_CONTENT] = [];
        ListBucketResult[LIST_COMMOM_PREFIXES] = [];
        let maxKeys;
        let prefix = request.query.prefix || '';
        if (request.query.maxKeys !== undefined) {
            maxKeys = Math.min(request.query.maxKeys, 1000);
        }
        else {
            maxKeys = 1000;
        }
        let delimiter = request.query.delimiter || '';
        let startAfter = request.query.startAfter || '';
        let keyCount = 0;
        const dirPath = path_1.normalize(path_1.join(this.localDirectoryPath, request.params.path) + '/');
        const files = glob.sync(dirPath + '/**/*');
        for (const file of files) {
            if (delimiter !== '' && util.checkfile(file, prefix, delimiter)) {
                ListBucketResult[LIST_COMMOM_PREFIXES].push({
                    prefix: request.params.path + file.split(dirPath)[1],
                });
            }
            if (!fs_extra_1.statSync(file).isDirectory()) {
                if (keyCount === maxKeys) {
                    break;
                }
                ListBucketResult[LIST_CONTENT].push({
                    Key: request.params.path + file.split(dirPath)[1],
                    LastModified: new Date(fs_extra_1.statSync(file).mtime).toISOString(),
                    Size: fs_extra_1.statSync(file).size,
                    ETag: etag_1.default(file),
                    StorageClass: 'STANDARD',
                });
                keyCount = keyCount + 1;
            }
        }
        ListBucketResult['Name'] = this.route.split('/')[1];
        ListBucketResult['Prefix'] = request.query.prefix || '';
        ListBucketResult['KeyCount'] = keyCount;
        ListBucketResult['MaxKeys'] = maxKeys;
        ListBucketResult['Delimiter'] = delimiter;
        if (keyCount === maxKeys) {
            ListBucketResult['IsTruncated'] = true;
        }
        else {
            ListBucketResult['IsTruncated'] = false;
        }
        response.set('Content-Type', 'text/xml');
        response.send(object_to_xml_1.default({
            '?xml version="1.0" encoding="utf-8"?': null,
            ListBucketResult,
        }));
    }
    async handleRequestDelete(request, response) {
        const filePath = path_1.join(this.localDirectoryPath, request.params.path);
        if (fs_extra_1.existsSync(filePath)) {
            fs_extra_1.unlink(filePath, err => {
                if (err)
                    throw err;
                response.send(xml_1.default(convert.json2xml(JSON.stringify(request.params.id + 'was deleted'))));
            });
        }
        else {
            response.sendStatus(204);
        }
    }
    async handleRequestPut(request, response) {
        const directoryPath = path_1.normalize(path_1.join(String(this.localDirectoryPath), String(request.params.path)));
        fs_extra_1.ensureFileSync(directoryPath);
        var new_data = util.stripChunkSignature(request.body);
        if (request.query.partNumber !== undefined) {
            this.upload_bufferMap[request.query.uploadId][request.query.partNumber] = request.body;
        }
        else {
            fs_extra_1.writeFileSync(directoryPath, new_data);
            let eventObj = this.createEvent(request);
            this.emit('event', eventObj);
        }
        response.send(xml_1.default(convert.json2xml(JSON.stringify('upload success'))));
    }
    async handleRequestPost(request, response) {
        const directoryPath = path_1.normalize(path_1.join(String(this.localDirectoryPath), String(request.params.path)));
        if (request.query.uploads !== undefined) {
            let id = uuid_1.default();
            this.uploadIds.push(id);
            this.upload_bufferMap[id] = {};
            response.send(object_to_xml_1.default({
                '?xml version="1.0" encoding="utf-8"?': null,
                InitiateMultipartUploadResult: {
                    Bucket: this.route,
                    Key: request.params.path,
                    UploadId: id,
                },
            }));
        }
        else if (this.uploadIds.includes(request.query.uploadId)) {
            let arr = Object.values(this.upload_bufferMap[request.query.uploadId]);
            delete this.upload_bufferMap[request.query.uploadId];
            this.uploadIds.splice(this.uploadIds.indexOf(request.query.uploadId), 1);
            response.set('Content-Type', 'text/xml');
            response.send(object_to_xml_1.default({
                '?xml version="1.0" encoding="utf-8"?': null,
                CompleteMultipartUploadResult: {
                    Location: request.url,
                    Bucket: this.route,
                    Key: request.params.path,
                    Etag: etag_1.default(directoryPath),
                },
            }));
            let buf = Buffer.concat(arr);
            fs_extra_1.writeFileSync(directoryPath, buf);
            let eventObj = this.createEvent(request);
            this.emit('event', eventObj);
        }
        else {
            const directoryPath = path_1.normalize(path_1.join(String(this.localDirectoryPath), String(request.params.path)));
            fs_extra_1.ensureFileSync(directoryPath);
            var new_data = util.stripChunkSignature(request.body);
            fs_extra_1.writeFileSync(directoryPath, new_data);
            let eventObj = this.createEvent(request);
            this.emit('event', eventObj);
            response.send(object_to_xml_1.default({
                '?xml version="1.0" encoding="utf-8"?': null,
                PostResponse: {
                    Location: request.url,
                    Bucket: this.route,
                    Key: request.params.path,
                    Etag: etag_1.default(directoryPath),
                },
            }));
        }
    }
    createEvent(request) {
        const filePath = path_1.normalize(path_1.join(this.localDirectoryPath, request.params.path));
        let eventObj = {};
        eventObj[EVENT_RECORDS] = [];
        let event = {
            eventVersion: '2.0',
            eventSource: 'aws:s3',
            awsRegion: 'local',
            eventTime: new Date().toISOString(),
            eventName: `ObjectCreated:${request.method}`,
        };
        let s3 = {
            s3SchemaVersion: '1.0',
            configurationId: 'testConfigRule',
            bucket: {
                name: String(this.route).substring(1),
                ownerIdentity: {
                    principalId: 'A3NL1KOZZKExample',
                },
                arn: `arn:aws:s3:::${String(this.route).substring(1)}`,
            },
            object: {
                key: request.params.path,
                size: fs_extra_1.statSync(filePath).size,
                eTag: etag_1.default(filePath),
                versionId: '096fKKXTRTtl3on89fVO.nfljtsv6qko',
            },
        };
        eventObj[EVENT_RECORDS].push({
            event,
            s3,
        });
        return eventObj;
    }
}
exports.StorageServer = StorageServer;
//# sourceMappingURL=S3server.js.map